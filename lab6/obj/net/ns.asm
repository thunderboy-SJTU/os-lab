
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 47 09 00 00       	call   800978 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
	...

00800040 <put_buffer>:

	return va;
}

static void
put_buffer(void *va) {
  800040:	55                   	push   %ebp
  800041:	89 e5                	mov    %esp,%ebp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  800043:	2d 00 b0 fe 0f       	sub    $0xffeb000,%eax
  800048:	c1 e8 0c             	shr    $0xc,%eax
  80004b:	c7 04 85 40 60 81 00 	movl   $0x0,0x816040(,%eax,4)
  800052:	00 00 00 00 
}
  800056:	5d                   	pop    %ebp
  800057:	c3                   	ret    

00800058 <umain>:
	serve();
}

void
umain(int argc, char **argv)
{
  800058:	55                   	push   %ebp
  800059:	89 e5                	mov    %esp,%ebp
  80005b:	53                   	push   %ebx
  80005c:	83 ec 14             	sub    $0x14,%esp
	envid_t ns_envid = sys_getenvid();
  80005f:	e8 83 1d 00 00       	call   801de7 <sys_getenvid>
  800064:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800066:	c7 05 00 50 81 00 00 	movl   $0x812400,0x815000
  80006d:	24 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800070:	e8 41 1e 00 00       	call   801eb6 <fork>
  800075:	a3 24 60 81 00       	mov    %eax,0x816024
	if (timer_envid < 0)
  80007a:	85 c0                	test   %eax,%eax
  80007c:	79 1c                	jns    80009a <umain+0x42>
		panic("error forking");
  80007e:	c7 44 24 08 03 24 81 	movl   $0x812403,0x8(%esp)
  800085:	00 
  800086:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  80008d:	00 
  80008e:	c7 04 24 11 24 81 00 	movl   $0x812411,(%esp)
  800095:	e8 4e 09 00 00       	call   8009e8 <_panic>
	else if (timer_envid == 0) {
  80009a:	85 c0                	test   %eax,%eax
  80009c:	75 15                	jne    8000b3 <umain+0x5b>
		timer(ns_envid, TIMER_INTERVAL);
  80009e:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  8000a5:	00 
  8000a6:	89 1c 24             	mov    %ebx,(%esp)
  8000a9:	e8 d2 06 00 00       	call   800780 <timer>
		return;
  8000ae:	e9 a3 00 00 00       	jmp    800156 <umain+0xfe>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8000b3:	e8 fe 1d 00 00       	call   801eb6 <fork>
  8000b8:	a3 28 60 81 00       	mov    %eax,0x816028
	if (input_envid < 0)
  8000bd:	85 c0                	test   %eax,%eax
  8000bf:	79 1c                	jns    8000dd <umain+0x85>
		panic("error forking");
  8000c1:	c7 44 24 08 03 24 81 	movl   $0x812403,0x8(%esp)
  8000c8:	00 
  8000c9:	c7 44 24 04 4d 01 00 	movl   $0x14d,0x4(%esp)
  8000d0:	00 
  8000d1:	c7 04 24 11 24 81 00 	movl   $0x812411,(%esp)
  8000d8:	e8 0b 09 00 00       	call   8009e8 <_panic>
	else if (input_envid == 0) {
  8000dd:	85 c0                	test   %eax,%eax
  8000df:	75 0a                	jne    8000eb <umain+0x93>
		input(ns_envid);
  8000e1:	89 1c 24             	mov    %ebx,(%esp)
  8000e4:	e8 5f 07 00 00       	call   800848 <input>
		return;
  8000e9:	eb 6b                	jmp    800156 <umain+0xfe>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8000eb:	90                   	nop
  8000ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8000f0:	e8 c1 1d 00 00       	call   801eb6 <fork>
  8000f5:	a3 2c 60 81 00       	mov    %eax,0x81602c
	if (output_envid < 0)
  8000fa:	85 c0                	test   %eax,%eax
  8000fc:	79 1c                	jns    80011a <umain+0xc2>
		panic("error forking");
  8000fe:	c7 44 24 08 03 24 81 	movl   $0x812403,0x8(%esp)
  800105:	00 
  800106:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
  80010d:	00 
  80010e:	c7 04 24 11 24 81 00 	movl   $0x812411,(%esp)
  800115:	e8 ce 08 00 00       	call   8009e8 <_panic>
	else if (output_envid == 0) {
  80011a:	85 c0                	test   %eax,%eax
  80011c:	75 0a                	jne    800128 <umain+0xd0>
		output(ns_envid);
  80011e:	89 1c 24             	mov    %ebx,(%esp)
  800121:	e8 e2 07 00 00       	call   800908 <output>
		return;
  800126:	eb 2e                	jmp    800156 <umain+0xfe>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  800128:	e8 e3 dc 00 00       	call   80de10 <thread_init>
	thread_create(0, "main", tmain, 0);
  80012d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800134:	00 
  800135:	c7 44 24 08 14 07 80 	movl   $0x800714,0x8(%esp)
  80013c:	00 
  80013d:	c7 44 24 04 1c 24 81 	movl   $0x81241c,0x4(%esp)
  800144:	00 
  800145:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80014c:	e8 a6 de 00 00       	call   80dff7 <thread_create>
	thread_yield();
  800151:	e8 5a dd 00 00       	call   80deb0 <thread_yield>
	// never coming here!
}
  800156:	83 c4 14             	add    $0x14,%esp
  800159:	5b                   	pop    %ebx
  80015a:	5d                   	pop    %ebp
  80015b:	c3                   	ret    

0080015c <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  80015c:	55                   	push   %ebp
  80015d:	89 e5                	mov    %esp,%ebp
  80015f:	57                   	push   %edi
  800160:	56                   	push   %esi
  800161:	53                   	push   %ebx
  800162:	83 ec 3c             	sub    $0x3c,%esp
  800165:	bb 00 00 00 00       	mov    $0x0,%ebx
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  80016a:	8d 7d e0             	lea    -0x20(%ebp),%edi
  80016d:	eb 08                	jmp    800177 <serve+0x1b>
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();
  80016f:	e8 3c dd 00 00       	call   80deb0 <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800174:	83 c3 01             	add    $0x1,%ebx
  800177:	e8 e5 dc 00 00       	call   80de61 <thread_wakeups_pending>
  80017c:	85 c0                	test   %eax,%eax
  80017e:	74 05                	je     800185 <serve+0x29>
  800180:	83 fb 1f             	cmp    $0x1f,%ebx
  800183:	7e ea                	jle    80016f <serve+0x13>
			thread_yield();

		perm = 0;
  800185:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
		if (!buse[i]) break;
  80018c:	83 3d 40 60 81 00 00 	cmpl   $0x0,0x816040
  800193:	74 3b                	je     8001d0 <serve+0x74>
  800195:	b8 01 00 00 00       	mov    $0x1,%eax
  80019a:	ba 40 60 81 00       	mov    $0x816040,%edx
  80019f:	83 3c 82 00          	cmpl   $0x0,(%edx,%eax,4)
  8001a3:	74 0a                	je     8001af <serve+0x53>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8001a5:	83 c0 01             	add    $0x1,%eax
  8001a8:	83 f8 14             	cmp    $0x14,%eax
  8001ab:	75 f2                	jne    80019f <serve+0x43>
  8001ad:	eb 05                	jmp    8001b4 <serve+0x58>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  8001af:	83 f8 14             	cmp    $0x14,%eax
  8001b2:	75 21                	jne    8001d5 <serve+0x79>
		panic("NS: buffer overflow");
  8001b4:	c7 44 24 08 21 24 81 	movl   $0x812421,0x8(%esp)
  8001bb:	00 
  8001bc:	c7 44 24 04 3f 00 00 	movl   $0x3f,0x4(%esp)
  8001c3:	00 
  8001c4:	c7 04 24 11 24 81 00 	movl   $0x812411,(%esp)
  8001cb:	e8 18 08 00 00       	call   8009e8 <_panic>
  8001d0:	b8 00 00 00 00       	mov    $0x0,%eax
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  8001d5:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  8001db:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  8001de:	c7 04 85 40 60 81 00 	movl   $0x1,0x816040(,%eax,4)
  8001e5:	01 00 00 00 
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8001e9:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8001ed:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8001f1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8001f4:	89 04 24             	mov    %eax,(%esp)
  8001f7:	e8 0d 21 00 00       	call   802309 <ipc_recv>
  8001fc:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  8001fe:	83 f8 0c             	cmp    $0xc,%eax
  800201:	75 67                	jne    80026a <serve+0x10e>
			process_timer(whom);
  800203:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800206:	3b 35 24 60 81 00    	cmp    0x816024,%esi
  80020c:	74 12                	je     800220 <serve+0xc4>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  80020e:	89 74 24 04          	mov    %esi,0x4(%esp)
  800212:	c7 04 24 b0 24 81 00 	movl   $0x8124b0,(%esp)
  800219:	e8 83 08 00 00       	call   800aa1 <cprintf>
  80021e:	eb 39                	jmp    800259 <serve+0xfd>
		return;
	}

	start = sys_time_msec();
  800220:	e8 88 17 00 00       	call   8019ad <sys_time_msec>
  800225:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800228:	e8 83 dc 00 00       	call   80deb0 <thread_yield>
	now = sys_time_msec();
  80022d:	e8 7b 17 00 00       	call   8019ad <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  800232:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800239:	00 
  80023a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  800241:	00 
  800242:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800245:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  80024b:	29 c2                	sub    %eax,%edx
  80024d:	89 54 24 04          	mov    %edx,0x4(%esp)
  800251:	89 34 24             	mov    %esi,(%esp)
  800254:	e8 32 20 00 00       	call   80228b <ipc_send>
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
  800259:	89 d8                	mov    %ebx,%eax
  80025b:	e8 e0 fd ff ff       	call   800040 <put_buffer>
  800260:	bb 00 00 00 00       	mov    $0x0,%ebx
			continue;
  800265:	e9 0d ff ff ff       	jmp    800177 <serve+0x1b>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  80026a:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80026e:	66 90                	xchg   %ax,%ax
  800270:	75 1d                	jne    80028f <serve+0x133>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800272:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800275:	89 44 24 04          	mov    %eax,0x4(%esp)
  800279:	c7 04 24 ec 24 81 00 	movl   $0x8124ec,(%esp)
  800280:	e8 1c 08 00 00       	call   800aa1 <cprintf>
  800285:	bb 00 00 00 00       	mov    $0x0,%ebx
			continue; // just leave it hanging...
  80028a:	e9 e8 fe ff ff       	jmp    800177 <serve+0x1b>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  80028f:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  800296:	e8 98 2f 00 00       	call   803233 <malloc>
		if (!args)
  80029b:	85 c0                	test   %eax,%eax
  80029d:	75 1c                	jne    8002bb <serve+0x15f>
			panic("could not allocate thread args structure");
  80029f:	c7 44 24 08 1c 25 81 	movl   $0x81251c,0x8(%esp)
  8002a6:	00 
  8002a7:	c7 44 24 04 26 01 00 	movl   $0x126,0x4(%esp)
  8002ae:	00 
  8002af:	c7 04 24 11 24 81 00 	movl   $0x812411,(%esp)
  8002b6:	e8 2d 07 00 00       	call   8009e8 <_panic>

		args->reqno = reqno;
  8002bb:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  8002bd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8002c0:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8002c3:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8002c6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8002ca:	c7 44 24 08 f5 02 80 	movl   $0x8002f5,0x8(%esp)
  8002d1:	00 
  8002d2:	c7 44 24 04 35 24 81 	movl   $0x812435,0x4(%esp)
  8002d9:	00 
  8002da:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8002e1:	e8 11 dd 00 00       	call   80dff7 <thread_create>
		thread_yield(); // let the thread created run
  8002e6:	e8 c5 db 00 00       	call   80deb0 <thread_yield>
  8002eb:	bb 00 00 00 00       	mov    $0x0,%ebx
  8002f0:	e9 82 fe ff ff       	jmp    800177 <serve+0x1b>

008002f5 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8002f5:	55                   	push   %ebp
  8002f6:	89 e5                	mov    %esp,%ebp
  8002f8:	81 ec 98 00 00 00    	sub    $0x98,%esp
  8002fe:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  800301:	89 75 f8             	mov    %esi,-0x8(%ebp)
  800304:	89 7d fc             	mov    %edi,-0x4(%ebp)
	struct st_args *args = (struct st_args *)a;
  800307:	8b 5d 08             	mov    0x8(%ebp),%ebx
	union Nsipc *req = args->req;
  80030a:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  80030d:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800310:	0f 87 34 01 00 00    	ja     80044a <serve_thread+0x155>
  800316:	8b 03                	mov    (%ebx),%eax
  800318:	ff 24 85 e8 25 81 00 	jmp    *0x8125e8(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  80031f:	8d 45 94             	lea    -0x6c(%ebp),%eax
  800322:	89 44 24 08          	mov    %eax,0x8(%esp)
  800326:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800329:	89 44 24 04          	mov    %eax,0x4(%esp)
  80032d:	8b 06                	mov    (%esi),%eax
  80032f:	89 04 24             	mov    %eax,(%esp)
  800332:	e8 9b 49 00 00       	call   804cd2 <lwip_accept>
  800337:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  800339:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  800340:	00 
  800341:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800344:	89 44 24 04          	mov    %eax,0x4(%esp)
  800348:	89 34 24             	mov    %esi,(%esp)
  80034b:	e8 65 12 00 00       	call   8015b5 <memmove>
		break;
  800350:	e9 13 01 00 00       	jmp    800468 <serve_thread+0x173>
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800355:	8b 46 14             	mov    0x14(%esi),%eax
  800358:	89 44 24 08          	mov    %eax,0x8(%esp)
  80035c:	8d 46 04             	lea    0x4(%esi),%eax
  80035f:	89 44 24 04          	mov    %eax,0x4(%esp)
  800363:	8b 06                	mov    (%esi),%eax
  800365:	89 04 24             	mov    %eax,(%esp)
  800368:	e8 ac 48 00 00       	call   804c19 <lwip_bind>
  80036d:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  80036f:	e9 f4 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800374:	8b 46 04             	mov    0x4(%esi),%eax
  800377:	89 44 24 04          	mov    %eax,0x4(%esp)
  80037b:	8b 06                	mov    (%esi),%eax
  80037d:	89 04 24             	mov    %eax,(%esp)
  800380:	e8 39 47 00 00       	call   804abe <lwip_shutdown>
  800385:	89 c7                	mov    %eax,%edi
		break;
  800387:	e9 dc 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  80038c:	8b 06                	mov    (%esi),%eax
  80038e:	89 04 24             	mov    %eax,(%esp)
  800391:	e8 ac 46 00 00       	call   804a42 <lwip_close>
  800396:	89 c7                	mov    %eax,%edi
		break;
  800398:	e9 cb 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80039d:	8b 46 14             	mov    0x14(%esi),%eax
  8003a0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8003a4:	8d 46 04             	lea    0x4(%esi),%eax
  8003a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003ab:	8b 06                	mov    (%esi),%eax
  8003ad:	89 04 24             	mov    %eax,(%esp)
  8003b0:	e8 ab 47 00 00       	call   804b60 <lwip_connect>
  8003b5:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  8003b7:	e9 ac 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8003bc:	8b 46 04             	mov    0x4(%esi),%eax
  8003bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003c3:	8b 06                	mov    (%esi),%eax
  8003c5:	89 04 24             	mov    %eax,(%esp)
  8003c8:	e8 04 47 00 00       	call   804ad1 <lwip_listen>
  8003cd:	89 c7                	mov    %eax,%edi
		break;
  8003cf:	e9 94 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8003d4:	8b 46 08             	mov    0x8(%esi),%eax
  8003d7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8003db:	8b 46 04             	mov    0x4(%esi),%eax
  8003de:	89 44 24 08          	mov    %eax,0x8(%esp)
  8003e2:	89 74 24 04          	mov    %esi,0x4(%esp)
  8003e6:	8b 06                	mov    (%esi),%eax
  8003e8:	89 04 24             	mov    %eax,(%esp)
  8003eb:	e8 e1 45 00 00       	call   8049d1 <lwip_recv>
  8003f0:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  8003f2:	eb 74                	jmp    800468 <serve_thread+0x173>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8003f4:	8b 46 08             	mov    0x8(%esi),%eax
  8003f7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8003fb:	8b 46 04             	mov    0x4(%esi),%eax
  8003fe:	89 44 24 08          	mov    %eax,0x8(%esp)
  800402:	8d 46 0c             	lea    0xc(%esi),%eax
  800405:	89 44 24 04          	mov    %eax,0x4(%esp)
  800409:	8b 06                	mov    (%esi),%eax
  80040b:	89 04 24             	mov    %eax,(%esp)
  80040e:	e8 37 41 00 00       	call   80454a <lwip_send>
  800413:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  800415:	eb 51                	jmp    800468 <serve_thread+0x173>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  800417:	8b 46 08             	mov    0x8(%esi),%eax
  80041a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80041e:	8b 46 04             	mov    0x4(%esi),%eax
  800421:	89 44 24 04          	mov    %eax,0x4(%esp)
  800425:	8b 06                	mov    (%esi),%eax
  800427:	89 04 24             	mov    %eax,(%esp)
  80042a:	e8 2d 40 00 00       	call   80445c <lwip_socket>
  80042f:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  800431:	eb 35                	jmp    800468 <serve_thread+0x173>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  800433:	89 74 24 04          	mov    %esi,0x4(%esp)
  800437:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  80043e:	e8 e3 df 00 00       	call   80e426 <jif_input>
  800443:	bf 00 00 00 00       	mov    $0x0,%edi
		r = 0;
		break;
  800448:	eb 4c                	jmp    800496 <serve_thread+0x1a1>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80044a:	89 74 24 08          	mov    %esi,0x8(%esp)
  80044e:	8b 43 04             	mov    0x4(%ebx),%eax
  800451:	89 44 24 04          	mov    %eax,0x4(%esp)
  800455:	c7 04 24 48 25 81 00 	movl   $0x812548,(%esp)
  80045c:	e8 40 06 00 00       	call   800aa1 <cprintf>
  800461:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
  800466:	eb 2e                	jmp    800496 <serve_thread+0x1a1>
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  800468:	83 ff ff             	cmp    $0xffffffff,%edi
  80046b:	75 29                	jne    800496 <serve_thread+0x1a1>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  80046d:	8b 03                	mov    (%ebx),%eax
  80046f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800473:	c7 44 24 08 42 24 81 	movl   $0x812442,0x8(%esp)
  80047a:	00 
  80047b:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  800482:	00 
  800483:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800486:	89 34 24             	mov    %esi,(%esp)
  800489:	e8 a1 0e 00 00       	call   80132f <snprintf>
		perror(buf);
  80048e:	89 34 24             	mov    %esi,(%esp)
  800491:	e8 71 dd 00 00       	call   80e207 <perror>
	}

	if (args->reqno != NSREQ_INPUT)
  800496:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800499:	74 1f                	je     8004ba <serve_thread+0x1c5>
		ipc_send(args->whom, r, 0, 0);
  80049b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8004a2:	00 
  8004a3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8004aa:	00 
  8004ab:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8004af:	8b 43 04             	mov    0x4(%ebx),%eax
  8004b2:	89 04 24             	mov    %eax,(%esp)
  8004b5:	e8 d1 1d 00 00       	call   80228b <ipc_send>

	put_buffer(args->req);
  8004ba:	8b 43 08             	mov    0x8(%ebx),%eax
  8004bd:	e8 7e fb ff ff       	call   800040 <put_buffer>
	sys_page_unmap(0, (void*) args->req);
  8004c2:	8b 43 08             	mov    0x8(%ebx),%eax
  8004c5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8004c9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8004d0:	e8 49 17 00 00       	call   801c1e <sys_page_unmap>
	free(args);
  8004d5:	89 1c 24             	mov    %ebx,(%esp)
  8004d8:	e8 83 2c 00 00       	call   803160 <free>
}
  8004dd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8004e0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8004e3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8004e6:	89 ec                	mov    %ebp,%esp
  8004e8:	5d                   	pop    %ebp
  8004e9:	c3                   	ret    

008004ea <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  8004ea:	55                   	push   %ebp
  8004eb:	89 e5                	mov    %esp,%ebp
  8004ed:	56                   	push   %esi
  8004ee:	53                   	push   %ebx
  8004ef:	83 ec 10             	sub    $0x10,%esp
	struct timer_thread *t = (struct timer_thread *) arg;
  8004f2:	8b 5d 08             	mov    0x8(%ebp),%ebx

	for (;;) {
		uint32_t cur = sys_time_msec();
  8004f5:	e8 b3 14 00 00       	call   8019ad <sys_time_msec>
  8004fa:	89 c6                	mov    %eax,%esi

		lwip_core_lock();
  8004fc:	e8 f8 cf 00 00       	call   80d4f9 <lwip_core_lock>
		t->func();
  800501:	ff 53 04             	call   *0x4(%ebx)
		lwip_core_unlock();
  800504:	e8 f5 cf 00 00       	call   80d4fe <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  800509:	03 33                	add    (%ebx),%esi
  80050b:	89 74 24 08          	mov    %esi,0x8(%esp)
  80050f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800516:	00 
  800517:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80051e:	e8 1c dc 00 00       	call   80e13f <thread_wait>
  800523:	eb d0                	jmp    8004f5 <net_timer+0xb>

00800525 <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800525:	55                   	push   %ebp
  800526:	89 e5                	mov    %esp,%ebp
  800528:	53                   	push   %ebx
  800529:	83 ec 14             	sub    $0x14,%esp
	t->msec = msec;
  80052c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80052f:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800531:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800534:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  800537:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80053b:	c7 44 24 08 ea 04 80 	movl   $0x8004ea,0x8(%esp)
  800542:	00 
  800543:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800547:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80054e:	e8 a4 da 00 00       	call   80dff7 <thread_create>
	if (r < 0)
  800553:	85 c0                	test   %eax,%eax
  800555:	79 28                	jns    80057f <start_timer+0x5a>
		panic("cannot create timer thread: %s", e2s(r));
  800557:	89 04 24             	mov    %eax,(%esp)
  80055a:	e8 99 dc 00 00       	call   80e1f8 <e2s>
  80055f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800563:	c7 44 24 08 6c 25 81 	movl   $0x81256c,0x8(%esp)
  80056a:	00 
  80056b:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  800572:	00 
  800573:	c7 04 24 11 24 81 00 	movl   $0x812411,(%esp)
  80057a:	e8 69 04 00 00       	call   8009e8 <_panic>
}
  80057f:	83 c4 14             	add    $0x14,%esp
  800582:	5b                   	pop    %ebx
  800583:	5d                   	pop    %ebp
  800584:	c3                   	ret    

00800585 <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800585:	55                   	push   %ebp
  800586:	89 e5                	mov    %esp,%ebp
  800588:	56                   	push   %esi
  800589:	53                   	push   %ebx
  80058a:	83 ec 30             	sub    $0x30,%esp
  80058d:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  800590:	e8 64 cf 00 00       	call   80d4f9 <lwip_core_lock>

	uint32_t done = 0;
  800595:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  80059c:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80059f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8005a3:	c7 04 24 67 07 80 00 	movl   $0x800767,(%esp)
  8005aa:	e8 14 49 00 00       	call   804ec3 <tcpip_init>
	lwip_core_unlock();
  8005af:	e8 4a cf 00 00       	call   80d4fe <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8005b4:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  8005bb:	ff 
  8005bc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8005c3:	00 
  8005c4:	89 1c 24             	mov    %ebx,(%esp)
  8005c7:	e8 73 db 00 00       	call   80e13f <thread_wait>
	lwip_core_lock();
  8005cc:	e8 28 cf 00 00       	call   80d4f9 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  8005d1:	89 75 f0             	mov    %esi,-0x10(%ebp)
	netmask.addr = init_mask;
  8005d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8005d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8005da:	8b 45 10             	mov    0x10(%ebp),%eax
  8005dd:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8005e0:	c7 44 24 18 34 9b 80 	movl   $0x809b34,0x18(%esp)
  8005e7:	00 
  8005e8:	c7 44 24 14 40 e2 80 	movl   $0x80e240,0x14(%esp)
  8005ef:	00 
  8005f0:	c7 44 24 10 2c 60 81 	movl   $0x81602c,0x10(%esp)
  8005f7:	00 
  8005f8:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8005fb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8005ff:	8d 45 ec             	lea    -0x14(%ebp),%eax
  800602:	89 44 24 08          	mov    %eax,0x8(%esp)
  800606:	8d 45 f0             	lea    -0x10(%ebp),%eax
  800609:	89 44 24 04          	mov    %eax,0x4(%esp)
  80060d:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  800614:	e8 68 73 00 00       	call   807981 <netif_add>
  800619:	85 c0                	test   %eax,%eax
  80061b:	75 1c                	jne    800639 <serve_init+0xb4>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  80061d:	c7 44 24 08 8c 25 81 	movl   $0x81258c,0x8(%esp)
  800624:	00 
  800625:	c7 44 24 04 5c 00 00 	movl   $0x5c,0x4(%esp)
  80062c:	00 
  80062d:	c7 04 24 11 24 81 00 	movl   $0x812411,(%esp)
  800634:	e8 af 03 00 00       	call   8009e8 <_panic>

	netif_set_default(nif);
  800639:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  800640:	e8 bc 71 00 00       	call   807801 <netif_set_default>
	netif_set_up(nif);
  800645:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  80064c:	e8 3d 72 00 00       	call   80788e <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  800651:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800658:	b9 51 24 81 00       	mov    $0x812451,%ecx
  80065d:	ba 9c cf 80 00       	mov    $0x80cf9c,%edx
  800662:	b8 00 60 81 00       	mov    $0x816000,%eax
  800667:	e8 b9 fe ff ff       	call   800525 <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  80066c:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  800673:	b9 5b 24 81 00       	mov    $0x81245b,%ecx
  800678:	ba 2b 89 80 00       	mov    $0x80892b,%edx
  80067d:	b8 0c 60 81 00       	mov    $0x81600c,%eax
  800682:	e8 9e fe ff ff       	call   800525 <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800687:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  80068e:	b9 67 24 81 00       	mov    $0x812467,%ecx
  800693:	ba 5e 92 80 00       	mov    $0x80925e,%edx
  800698:	b8 18 60 81 00       	mov    $0x816018,%eax
  80069d:	e8 83 fe ff ff       	call   800525 <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8006a2:	89 34 24             	mov    %esi,(%esp)
  8006a5:	e8 06 a5 00 00       	call   80abb0 <inet_ntoa>
  8006aa:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  8006ae:	0f b6 05 6a c2 b3 00 	movzbl 0xb3c26a,%eax
  8006b5:	89 44 24 18          	mov    %eax,0x18(%esp)
  8006b9:	0f b6 05 69 c2 b3 00 	movzbl 0xb3c269,%eax
  8006c0:	89 44 24 14          	mov    %eax,0x14(%esp)
  8006c4:	0f b6 05 68 c2 b3 00 	movzbl 0xb3c268,%eax
  8006cb:	89 44 24 10          	mov    %eax,0x10(%esp)
  8006cf:	0f b6 05 67 c2 b3 00 	movzbl 0xb3c267,%eax
  8006d6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8006da:	0f b6 05 66 c2 b3 00 	movzbl 0xb3c266,%eax
  8006e1:	89 44 24 08          	mov    %eax,0x8(%esp)
  8006e5:	0f b6 05 65 c2 b3 00 	movzbl 0xb3c265,%eax
  8006ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  8006f0:	c7 04 24 ac 25 81 00 	movl   $0x8125ac,(%esp)
  8006f7:	e8 a5 03 00 00       	call   800aa1 <cprintf>
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  8006fc:	e8 fd cd 00 00       	call   80d4fe <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  800701:	c7 04 24 73 24 81 00 	movl   $0x812473,(%esp)
  800708:	e8 94 03 00 00       	call   800aa1 <cprintf>
}
  80070d:	83 c4 30             	add    $0x30,%esp
  800710:	5b                   	pop    %ebx
  800711:	5e                   	pop    %esi
  800712:	5d                   	pop    %ebp
  800713:	c3                   	ret    

00800714 <tmain>:
		thread_yield(); // let the thread created run
	}
}

static void
tmain(uint32_t arg) {
  800714:	55                   	push   %ebp
  800715:	89 e5                	mov    %esp,%ebp
  800717:	83 ec 18             	sub    $0x18,%esp
  80071a:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80071d:	89 75 fc             	mov    %esi,-0x4(%ebp)
	serve_init(inet_addr(IP),
  800720:	c7 04 24 8c 24 81 00 	movl   $0x81248c,(%esp)
  800727:	e8 6c a7 00 00       	call   80ae98 <inet_addr>
  80072c:	89 c3                	mov    %eax,%ebx
  80072e:	c7 04 24 95 24 81 00 	movl   $0x812495,(%esp)
  800735:	e8 5e a7 00 00       	call   80ae98 <inet_addr>
  80073a:	89 c6                	mov    %eax,%esi
  80073c:	c7 04 24 a3 24 81 00 	movl   $0x8124a3,(%esp)
  800743:	e8 50 a7 00 00       	call   80ae98 <inet_addr>
  800748:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80074c:	89 74 24 04          	mov    %esi,0x4(%esp)
  800750:	89 04 24             	mov    %eax,(%esp)
  800753:	e8 2d fe ff ff       	call   800585 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800758:	e8 ff f9 ff ff       	call   80015c <serve>
}
  80075d:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  800760:	8b 75 fc             	mov    -0x4(%ebp),%esi
  800763:	89 ec                	mov    %ebp,%esp
  800765:	5d                   	pop    %ebp
  800766:	c3                   	ret    

00800767 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800767:	55                   	push   %ebp
  800768:	89 e5                	mov    %esp,%ebp
  80076a:	83 ec 18             	sub    $0x18,%esp
  80076d:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  800770:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800776:	89 04 24             	mov    %eax,(%esp)
  800779:	e8 c1 d6 00 00       	call   80de3f <thread_wakeup>
}
  80077e:	c9                   	leave  
  80077f:	c3                   	ret    

00800780 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800780:	55                   	push   %ebp
  800781:	89 e5                	mov    %esp,%ebp
  800783:	57                   	push   %edi
  800784:	56                   	push   %esi
  800785:	53                   	push   %ebx
  800786:	83 ec 2c             	sub    $0x2c,%esp
  800789:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80078c:	e8 1c 12 00 00       	call   8019ad <sys_time_msec>
  800791:	89 c3                	mov    %eax,%ebx
  800793:	03 5d 0c             	add    0xc(%ebp),%ebx

	binaryname = "ns_timer";
  800796:	c7 05 00 50 81 00 14 	movl   $0x812614,0x815000
  80079d:	26 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007a0:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  8007a3:	eb 05                	jmp    8007aa <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
  8007a5:	e8 bb 15 00 00       	call   801d65 <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  8007aa:	e8 fe 11 00 00       	call   8019ad <sys_time_msec>
  8007af:	39 c3                	cmp    %eax,%ebx
  8007b1:	76 07                	jbe    8007ba <timer+0x3a>
  8007b3:	85 c0                	test   %eax,%eax
  8007b5:	79 ee                	jns    8007a5 <timer+0x25>
  8007b7:	90                   	nop
  8007b8:	eb 08                	jmp    8007c2 <timer+0x42>
			sys_yield();
		}
		if (r < 0)
  8007ba:	85 c0                	test   %eax,%eax
  8007bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8007c0:	79 20                	jns    8007e2 <timer+0x62>
			panic("sys_time_msec: %e", r);
  8007c2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8007c6:	c7 44 24 08 1d 26 81 	movl   $0x81261d,0x8(%esp)
  8007cd:	00 
  8007ce:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  8007d5:	00 
  8007d6:	c7 04 24 2f 26 81 00 	movl   $0x81262f,(%esp)
  8007dd:	e8 06 02 00 00       	call   8009e8 <_panic>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8007e2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8007e9:	00 
  8007ea:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007f1:	00 
  8007f2:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  8007f9:	00 
  8007fa:	89 34 24             	mov    %esi,(%esp)
  8007fd:	e8 89 1a 00 00       	call   80228b <ipc_send>

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800802:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  800809:	00 
  80080a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800811:	00 
  800812:	89 3c 24             	mov    %edi,(%esp)
  800815:	e8 ef 1a 00 00       	call   802309 <ipc_recv>
  80081a:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  80081c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80081f:	39 c6                	cmp    %eax,%esi
  800821:	74 12                	je     800835 <timer+0xb5>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800823:	89 44 24 04          	mov    %eax,0x4(%esp)
  800827:	c7 04 24 3c 26 81 00 	movl   $0x81263c,(%esp)
  80082e:	e8 6e 02 00 00       	call   800aa1 <cprintf>
				continue;
			}

			stop = sys_time_msec() + to;
			break;
		}
  800833:	eb cd                	jmp    800802 <timer+0x82>
			if (whom != ns_envid) {
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  800835:	e8 73 11 00 00       	call   8019ad <sys_time_msec>
  80083a:	01 c3                	add    %eax,%ebx
  80083c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  800840:	e9 65 ff ff ff       	jmp    8007aa <timer+0x2a>
  800845:	00 00                	add    %al,(%eax)
	...

00800848 <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  800848:	55                   	push   %ebp
  800849:	89 e5                	mov    %esp,%ebp
  80084b:	57                   	push   %edi
  80084c:	56                   	push   %esi
  80084d:	53                   	push   %ebx
  80084e:	81 ec 2c 08 00 00    	sub    $0x82c,%esp
  800854:	8b 7d 08             	mov    0x8(%ebp),%edi
	binaryname = "ns_input";
  800857:	c7 05 00 50 81 00 77 	movl   $0x812677,0x815000
  80085e:	26 81 00 
	// another packet in to the same physical page.
        int r;
        int len;
        char buf[MAXBUFLEN];
        while(1){
          while((r = sys_receive_packet((uint32_t)buf,&len))<0)
  800861:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  800864:	8d 9d e4 f7 ff ff    	lea    -0x81c(%ebp),%ebx
  80086a:	eb 05                	jmp    800871 <input+0x29>
             sys_yield();
  80086c:	e8 f4 14 00 00       	call   801d65 <sys_yield>
	// another packet in to the same physical page.
        int r;
        int len;
        char buf[MAXBUFLEN];
        while(1){
          while((r = sys_receive_packet((uint32_t)buf,&len))<0)
  800871:	89 74 24 04          	mov    %esi,0x4(%esp)
  800875:	89 1c 24             	mov    %ebx,(%esp)
  800878:	e8 ff 0f 00 00       	call   80187c <sys_receive_packet>
  80087d:	85 c0                	test   %eax,%eax
  80087f:	78 eb                	js     80086c <input+0x24>
             sys_yield();
          r = sys_page_alloc(0,&nsipcbuf,PTE_P|PTE_U|PTE_W);
  800881:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  800888:	00 
  800889:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  800890:	00 
  800891:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800898:	e8 5b 14 00 00       	call   801cf8 <sys_page_alloc>
          if(r < 0)
  80089d:	85 c0                	test   %eax,%eax
  80089f:	79 20                	jns    8008c1 <input+0x79>
             panic("error: %e",r);
  8008a1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8008a5:	c7 44 24 08 80 26 81 	movl   $0x812680,0x8(%esp)
  8008ac:	00 
  8008ad:	c7 44 24 04 1a 00 00 	movl   $0x1a,0x4(%esp)
  8008b4:	00 
  8008b5:	c7 04 24 8a 26 81 00 	movl   $0x81268a,(%esp)
  8008bc:	e8 27 01 00 00       	call   8009e8 <_panic>
          memmove(nsipcbuf.pkt.jp_data,(void*)buf,len);
  8008c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8008c4:	89 44 24 08          	mov    %eax,0x8(%esp)
  8008c8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8008cc:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  8008d3:	e8 dd 0c 00 00       	call   8015b5 <memmove>
          nsipcbuf.pkt.jp_len = len;
  8008d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8008db:	a3 00 e0 b3 00       	mov    %eax,0xb3e000

          ipc_send(ns_envid,NSREQ_INPUT,&nsipcbuf,PTE_P|PTE_U|PTE_W);    
  8008e0:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  8008e7:	00 
  8008e8:	c7 44 24 08 00 e0 b3 	movl   $0xb3e000,0x8(%esp)
  8008ef:	00 
  8008f0:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  8008f7:	00 
  8008f8:	89 3c 24             	mov    %edi,(%esp)
  8008fb:	e8 8b 19 00 00       	call   80228b <ipc_send>
  800900:	e9 6c ff ff ff       	jmp    800871 <input+0x29>
  800905:	00 00                	add    %al,(%eax)
	...

00800908 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  800908:	55                   	push   %ebp
  800909:	89 e5                	mov    %esp,%ebp
  80090b:	53                   	push   %ebx
  80090c:	83 ec 14             	sub    $0x14,%esp
  80090f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	binaryname = "ns_output";
  800912:	c7 05 00 50 81 00 96 	movl   $0x812696,0x815000
  800919:	26 81 00 
	// 	- read a packet from the network server
	//	- send the packet to the device driver
        int r = 0;
        struct tx_desc td;
        while(1){            
            r = sys_ipc_recv(&nsipcbuf);
  80091c:	c7 04 24 00 e0 b3 00 	movl   $0xb3e000,(%esp)
  800923:	e8 06 11 00 00       	call   801a2e <sys_ipc_recv>
            if(r != 0 || thisenv->env_ipc_from != ns_envid || thisenv->env_ipc_value != NSREQ_OUTPUT)
  800928:	85 c0                	test   %eax,%eax
  80092a:	75 f0                	jne    80091c <output+0x14>
  80092c:	a1 78 c2 b3 00       	mov    0xb3c278,%eax
  800931:	8b 50 78             	mov    0x78(%eax),%edx
  800934:	39 da                	cmp    %ebx,%edx
  800936:	75 e4                	jne    80091c <output+0x14>
  800938:	8b 40 74             	mov    0x74(%eax),%eax
  80093b:	83 f8 0b             	cmp    $0xb,%eax
  80093e:	75 dc                	jne    80091c <output+0x14>
                continue;
          
            uint32_t addr = (uint32_t)nsipcbuf.pkt.jp_data;
            uint32_t length = nsipcbuf.pkt.jp_len;
            r = sys_transmit_packet(addr,length);
  800940:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
  800945:	89 44 24 04          	mov    %eax,0x4(%esp)
  800949:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  800950:	e8 69 0f 00 00       	call   8018be <sys_transmit_packet>
            if(r < 0)
  800955:	85 c0                	test   %eax,%eax
  800957:	79 c3                	jns    80091c <output+0x14>
               panic("transmit_packet error\n");
  800959:	c7 44 24 08 a0 26 81 	movl   $0x8126a0,0x8(%esp)
  800960:	00 
  800961:	c7 44 24 04 1a 00 00 	movl   $0x1a,0x4(%esp)
  800968:	00 
  800969:	c7 04 24 b7 26 81 00 	movl   $0x8126b7,(%esp)
  800970:	e8 73 00 00 00       	call   8009e8 <_panic>
  800975:	00 00                	add    %al,(%eax)
	...

00800978 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  800978:	55                   	push   %ebp
  800979:	89 e5                	mov    %esp,%ebp
  80097b:	83 ec 18             	sub    $0x18,%esp
  80097e:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  800981:	89 75 fc             	mov    %esi,-0x4(%ebp)
  800984:	8b 75 08             	mov    0x8(%ebp),%esi
  800987:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = envs + ENVX(sys_getenvid());
  80098a:	e8 58 14 00 00       	call   801de7 <sys_getenvid>
  80098f:	25 ff 03 00 00       	and    $0x3ff,%eax
  800994:	89 c2                	mov    %eax,%edx
  800996:	c1 e2 07             	shl    $0x7,%edx
  800999:	8d 84 82 00 00 c0 ee 	lea    -0x11400000(%edx,%eax,4),%eax
  8009a0:	a3 78 c2 b3 00       	mov    %eax,0xb3c278
        //cprintf("ENVX sys_get_envid(): %d\n",ENVX(sys_getenvid()));
	// save the name of the program so that panic() can use it
	if (argc > 0)
  8009a5:	85 f6                	test   %esi,%esi
  8009a7:	7e 07                	jle    8009b0 <libmain+0x38>
		binaryname = argv[0];
  8009a9:	8b 03                	mov    (%ebx),%eax
  8009ab:	a3 00 50 81 00       	mov    %eax,0x815000

	// call user main routine
	umain(argc, argv);
  8009b0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8009b4:	89 34 24             	mov    %esi,(%esp)
  8009b7:	e8 9c f6 ff ff       	call   800058 <umain>

	// exit gracefully
	exit();
  8009bc:	e8 0b 00 00 00       	call   8009cc <exit>
}
  8009c1:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8009c4:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8009c7:	89 ec                	mov    %ebp,%esp
  8009c9:	5d                   	pop    %ebp
  8009ca:	c3                   	ret    
	...

008009cc <exit>:

#include <inc/lib.h>

void
exit(void)
{
  8009cc:	55                   	push   %ebp
  8009cd:	89 e5                	mov    %esp,%ebp
  8009cf:	83 ec 18             	sub    $0x18,%esp
	close_all();
  8009d2:	e8 84 1e 00 00       	call   80285b <close_all>
	sys_env_destroy(0);
  8009d7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8009de:	e8 44 14 00 00       	call   801e27 <sys_env_destroy>
}
  8009e3:	c9                   	leave  
  8009e4:	c3                   	ret    
  8009e5:	00 00                	add    %al,(%eax)
	...

008009e8 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  8009e8:	55                   	push   %ebp
  8009e9:	89 e5                	mov    %esp,%ebp
  8009eb:	56                   	push   %esi
  8009ec:	53                   	push   %ebx
  8009ed:	83 ec 20             	sub    $0x20,%esp
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
  8009f0:	8d 75 14             	lea    0x14(%ebp),%esi
	va_list ap;

	va_start(ap, fmt);

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  8009f3:	8b 1d 00 50 81 00    	mov    0x815000,%ebx
  8009f9:	e8 e9 13 00 00       	call   801de7 <sys_getenvid>
  8009fe:	8b 55 0c             	mov    0xc(%ebp),%edx
  800a01:	89 54 24 10          	mov    %edx,0x10(%esp)
  800a05:	8b 55 08             	mov    0x8(%ebp),%edx
  800a08:	89 54 24 0c          	mov    %edx,0xc(%esp)
  800a0c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800a10:	89 44 24 04          	mov    %eax,0x4(%esp)
  800a14:	c7 04 24 d0 26 81 00 	movl   $0x8126d0,(%esp)
  800a1b:	e8 81 00 00 00       	call   800aa1 <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  800a20:	89 74 24 04          	mov    %esi,0x4(%esp)
  800a24:	8b 45 10             	mov    0x10(%ebp),%eax
  800a27:	89 04 24             	mov    %eax,(%esp)
  800a2a:	e8 11 00 00 00       	call   800a40 <vcprintf>
	cprintf("\n");
  800a2f:	c7 04 24 8a 24 81 00 	movl   $0x81248a,(%esp)
  800a36:	e8 66 00 00 00       	call   800aa1 <cprintf>

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  800a3b:	cc                   	int3   
  800a3c:	eb fd                	jmp    800a3b <_panic+0x53>
	...

00800a40 <vcprintf>:
	b->cnt++;
}

int
vcprintf(const char *fmt, va_list ap)
{
  800a40:	55                   	push   %ebp
  800a41:	89 e5                	mov    %esp,%ebp
  800a43:	81 ec 28 01 00 00    	sub    $0x128,%esp
	struct printbuf b;

	b.idx = 0;
  800a49:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  800a50:	00 00 00 
	b.cnt = 0;
  800a53:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  800a5a:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  800a5d:	8b 45 0c             	mov    0xc(%ebp),%eax
  800a60:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800a64:	8b 45 08             	mov    0x8(%ebp),%eax
  800a67:	89 44 24 08          	mov    %eax,0x8(%esp)
  800a6b:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  800a71:	89 44 24 04          	mov    %eax,0x4(%esp)
  800a75:	c7 04 24 bb 0a 80 00 	movl   $0x800abb,(%esp)
  800a7c:	e8 cb 01 00 00       	call   800c4c <vprintfmt>
	sys_cputs(b.buf, b.idx);
  800a81:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
  800a87:	89 44 24 04          	mov    %eax,0x4(%esp)
  800a8b:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  800a91:	89 04 24             	mov    %eax,(%esp)
  800a94:	e8 63 0d 00 00       	call   8017fc <sys_cputs>

	return b.cnt;
}
  800a99:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  800a9f:	c9                   	leave  
  800aa0:	c3                   	ret    

00800aa1 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  800aa1:	55                   	push   %ebp
  800aa2:	89 e5                	mov    %esp,%ebp
  800aa4:	83 ec 18             	sub    $0x18,%esp

	return b.cnt;
}

int
cprintf(const char *fmt, ...)
  800aa7:	8d 45 0c             	lea    0xc(%ebp),%eax
{
	va_list ap;
	int cnt;

	va_start(ap, fmt);
	cnt = vcprintf(fmt, ap);
  800aaa:	89 44 24 04          	mov    %eax,0x4(%esp)
  800aae:	8b 45 08             	mov    0x8(%ebp),%eax
  800ab1:	89 04 24             	mov    %eax,(%esp)
  800ab4:	e8 87 ff ff ff       	call   800a40 <vcprintf>
	va_end(ap);

	return cnt;
}
  800ab9:	c9                   	leave  
  800aba:	c3                   	ret    

00800abb <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  800abb:	55                   	push   %ebp
  800abc:	89 e5                	mov    %esp,%ebp
  800abe:	53                   	push   %ebx
  800abf:	83 ec 14             	sub    $0x14,%esp
  800ac2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  800ac5:	8b 03                	mov    (%ebx),%eax
  800ac7:	8b 55 08             	mov    0x8(%ebp),%edx
  800aca:	88 54 03 08          	mov    %dl,0x8(%ebx,%eax,1)
  800ace:	83 c0 01             	add    $0x1,%eax
  800ad1:	89 03                	mov    %eax,(%ebx)
	if (b->idx == 256-1) {
  800ad3:	3d ff 00 00 00       	cmp    $0xff,%eax
  800ad8:	75 19                	jne    800af3 <putch+0x38>
		sys_cputs(b->buf, b->idx);
  800ada:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  800ae1:	00 
  800ae2:	8d 43 08             	lea    0x8(%ebx),%eax
  800ae5:	89 04 24             	mov    %eax,(%esp)
  800ae8:	e8 0f 0d 00 00       	call   8017fc <sys_cputs>
		b->idx = 0;
  800aed:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	}
	b->cnt++;
  800af3:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  800af7:	83 c4 14             	add    $0x14,%esp
  800afa:	5b                   	pop    %ebx
  800afb:	5d                   	pop    %ebp
  800afc:	c3                   	ret    
  800afd:	00 00                	add    %al,(%eax)
	...

00800b00 <printnum_v2>:
 */

static void 
printnum_v2(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800b00:	55                   	push   %ebp
  800b01:	89 e5                	mov    %esp,%ebp
  800b03:	57                   	push   %edi
  800b04:	56                   	push   %esi
  800b05:	53                   	push   %ebx
  800b06:	83 ec 4c             	sub    $0x4c,%esp
  800b09:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  800b0c:	89 d6                	mov    %edx,%esi
  800b0e:	8b 45 08             	mov    0x8(%ebp),%eax
  800b11:	89 45 d8             	mov    %eax,-0x28(%ebp)
  800b14:	8b 55 0c             	mov    0xc(%ebp),%edx
  800b17:	89 55 e0             	mov    %edx,-0x20(%ebp)
  800b1a:	8b 45 10             	mov    0x10(%ebp),%eax
  800b1d:	8b 5d 14             	mov    0x14(%ebp),%ebx
  800b20:	8b 7d 18             	mov    0x18(%ebp),%edi
    if (num >= base) {
  800b23:	89 45 dc             	mov    %eax,-0x24(%ebp)
  800b26:	b9 00 00 00 00       	mov    $0x0,%ecx
  800b2b:	39 d1                	cmp    %edx,%ecx
  800b2d:	72 07                	jb     800b36 <printnum_v2+0x36>
  800b2f:	8b 55 d8             	mov    -0x28(%ebp),%edx
  800b32:	39 d0                	cmp    %edx,%eax
  800b34:	77 5f                	ja     800b95 <printnum_v2+0x95>
		printnum_v2(putch, putdat, num / base, base, width - 1, padc);
  800b36:	89 7c 24 10          	mov    %edi,0x10(%esp)
  800b3a:	83 eb 01             	sub    $0x1,%ebx
  800b3d:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  800b41:	89 44 24 08          	mov    %eax,0x8(%esp)
  800b45:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  800b49:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  800b4d:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  800b50:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  800b53:	8b 5d dc             	mov    -0x24(%ebp),%ebx
  800b56:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800b5a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800b61:	00 
  800b62:	8b 45 d8             	mov    -0x28(%ebp),%eax
  800b65:	89 04 24             	mov    %eax,(%esp)
  800b68:	8b 55 e0             	mov    -0x20(%ebp),%edx
  800b6b:	89 54 24 04          	mov    %edx,0x4(%esp)
  800b6f:	e8 0c 16 01 00       	call   812180 <__udivdi3>
  800b74:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  800b77:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  800b7a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  800b7e:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  800b82:	89 04 24             	mov    %eax,(%esp)
  800b85:	89 54 24 04          	mov    %edx,0x4(%esp)
  800b89:	89 f2                	mov    %esi,%edx
  800b8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b8e:	e8 6d ff ff ff       	call   800b00 <printnum_v2>
  800b93:	eb 1e                	jmp    800bb3 <printnum_v2+0xb3>
	} else {
		// print any needed pad characters before first digit
                if(padc != '-'){
  800b95:	83 ff 2d             	cmp    $0x2d,%edi
  800b98:	74 19                	je     800bb3 <printnum_v2+0xb3>
		while (--width > 0)
  800b9a:	83 eb 01             	sub    $0x1,%ebx
  800b9d:	85 db                	test   %ebx,%ebx
  800b9f:	90                   	nop
  800ba0:	7e 11                	jle    800bb3 <printnum_v2+0xb3>
			putch(padc, putdat);
  800ba2:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ba6:	89 3c 24             	mov    %edi,(%esp)
  800ba9:	ff 55 e4             	call   *-0x1c(%ebp)
    if (num >= base) {
		printnum_v2(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
                if(padc != '-'){
		while (--width > 0)
  800bac:	83 eb 01             	sub    $0x1,%ebx
  800baf:	85 db                	test   %ebx,%ebx
  800bb1:	7f ef                	jg     800ba2 <printnum_v2+0xa2>
			putch(padc, putdat);
                }
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800bb3:	89 74 24 04          	mov    %esi,0x4(%esp)
  800bb7:	8b 74 24 04          	mov    0x4(%esp),%esi
  800bbb:	8b 45 dc             	mov    -0x24(%ebp),%eax
  800bbe:	89 44 24 08          	mov    %eax,0x8(%esp)
  800bc2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800bc9:	00 
  800bca:	8b 55 d8             	mov    -0x28(%ebp),%edx
  800bcd:	89 14 24             	mov    %edx,(%esp)
  800bd0:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  800bd3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800bd7:	e8 d4 16 01 00       	call   8122b0 <__umoddi3>
  800bdc:	89 74 24 04          	mov    %esi,0x4(%esp)
  800be0:	0f be 80 f3 26 81 00 	movsbl 0x8126f3(%eax),%eax
  800be7:	89 04 24             	mov    %eax,(%esp)
  800bea:	ff 55 e4             	call   *-0x1c(%ebp)
}
  800bed:	83 c4 4c             	add    $0x4c,%esp
  800bf0:	5b                   	pop    %ebx
  800bf1:	5e                   	pop    %esi
  800bf2:	5f                   	pop    %edi
  800bf3:	5d                   	pop    %ebp
  800bf4:	c3                   	ret    

00800bf5 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800bf5:	55                   	push   %ebp
  800bf6:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  800bf8:	83 fa 01             	cmp    $0x1,%edx
  800bfb:	7e 0e                	jle    800c0b <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  800bfd:	8b 10                	mov    (%eax),%edx
  800bff:	8d 4a 08             	lea    0x8(%edx),%ecx
  800c02:	89 08                	mov    %ecx,(%eax)
  800c04:	8b 02                	mov    (%edx),%eax
  800c06:	8b 52 04             	mov    0x4(%edx),%edx
  800c09:	eb 22                	jmp    800c2d <getuint+0x38>
	else if (lflag)
  800c0b:	85 d2                	test   %edx,%edx
  800c0d:	74 10                	je     800c1f <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  800c0f:	8b 10                	mov    (%eax),%edx
  800c11:	8d 4a 04             	lea    0x4(%edx),%ecx
  800c14:	89 08                	mov    %ecx,(%eax)
  800c16:	8b 02                	mov    (%edx),%eax
  800c18:	ba 00 00 00 00       	mov    $0x0,%edx
  800c1d:	eb 0e                	jmp    800c2d <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  800c1f:	8b 10                	mov    (%eax),%edx
  800c21:	8d 4a 04             	lea    0x4(%edx),%ecx
  800c24:	89 08                	mov    %ecx,(%eax)
  800c26:	8b 02                	mov    (%edx),%eax
  800c28:	ba 00 00 00 00       	mov    $0x0,%edx
}
  800c2d:	5d                   	pop    %ebp
  800c2e:	c3                   	ret    

00800c2f <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800c2f:	55                   	push   %ebp
  800c30:	89 e5                	mov    %esp,%ebp
  800c32:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  800c35:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  800c39:	8b 10                	mov    (%eax),%edx
  800c3b:	3b 50 04             	cmp    0x4(%eax),%edx
  800c3e:	73 0a                	jae    800c4a <sprintputch+0x1b>
		*b->buf++ = ch;
  800c40:	8b 4d 08             	mov    0x8(%ebp),%ecx
  800c43:	88 0a                	mov    %cl,(%edx)
  800c45:	83 c2 01             	add    $0x1,%edx
  800c48:	89 10                	mov    %edx,(%eax)
}
  800c4a:	5d                   	pop    %ebp
  800c4b:	c3                   	ret    

00800c4c <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800c4c:	55                   	push   %ebp
  800c4d:	89 e5                	mov    %esp,%ebp
  800c4f:	57                   	push   %edi
  800c50:	56                   	push   %esi
  800c51:	53                   	push   %ebx
  800c52:	83 ec 6c             	sub    $0x6c,%esp
  800c55:	8b 7d 10             	mov    0x10(%ebp),%edi
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  800c58:	c7 45 c8 ff ff ff ff 	movl   $0xffffffff,-0x38(%ebp)
  800c5f:	eb 1a                	jmp    800c7b <vprintfmt+0x2f>
	int base, lflag, width, precision, altflag,signflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  800c61:	85 c0                	test   %eax,%eax
  800c63:	0f 84 66 06 00 00    	je     8012cf <vprintfmt+0x683>
				return;
			putch(ch, putdat);
  800c69:	8b 55 0c             	mov    0xc(%ebp),%edx
  800c6c:	89 54 24 04          	mov    %edx,0x4(%esp)
  800c70:	89 04 24             	mov    %eax,(%esp)
  800c73:	ff 55 08             	call   *0x8(%ebp)
  800c76:	eb 03                	jmp    800c7b <vprintfmt+0x2f>
  800c78:	8b 7d e4             	mov    -0x1c(%ebp),%edi
	unsigned long long num;
	int base, lflag, width, precision, altflag,signflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800c7b:	0f b6 07             	movzbl (%edi),%eax
  800c7e:	83 c7 01             	add    $0x1,%edi
  800c81:	83 f8 25             	cmp    $0x25,%eax
  800c84:	75 db                	jne    800c61 <vprintfmt+0x15>
  800c86:	c6 45 cc 20          	movb   $0x20,-0x34(%ebp)
  800c8a:	b9 00 00 00 00       	mov    $0x0,%ecx
  800c8f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  800c96:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  800c9b:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
  800ca2:	be 00 00 00 00       	mov    $0x0,%esi
  800ca7:	eb 06                	jmp    800caf <vprintfmt+0x63>
  800ca9:	c6 45 cc 2d          	movb   $0x2d,-0x34(%ebp)
  800cad:	89 c7                	mov    %eax,%edi
		precision = -1;
		lflag = 0;
		altflag = 0;
                signflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800caf:	0f b6 17             	movzbl (%edi),%edx
  800cb2:	0f b6 c2             	movzbl %dl,%eax
  800cb5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  800cb8:	8d 47 01             	lea    0x1(%edi),%eax
  800cbb:	83 ea 23             	sub    $0x23,%edx
  800cbe:	80 fa 55             	cmp    $0x55,%dl
  800cc1:	0f 87 60 05 00 00    	ja     801227 <vprintfmt+0x5db>
  800cc7:	0f b6 d2             	movzbl %dl,%edx
  800cca:	ff 24 95 e0 28 81 00 	jmp    *0x8128e0(,%edx,4)
  800cd1:	b9 01 00 00 00       	mov    $0x1,%ecx
  800cd6:	eb d5                	jmp    800cad <vprintfmt+0x61>
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  800cd8:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  800cdb:	83 eb 30             	sub    $0x30,%ebx
				ch = *fmt;
  800cde:	0f be 10             	movsbl (%eax),%edx
				if (ch < '0' || ch > '9')
  800ce1:	8d 7a d0             	lea    -0x30(%edx),%edi
  800ce4:	83 ff 09             	cmp    $0x9,%edi
  800ce7:	76 08                	jbe    800cf1 <vprintfmt+0xa5>
  800ce9:	eb 40                	jmp    800d2b <vprintfmt+0xdf>
  800ceb:	c6 45 cc 30          	movb   $0x30,-0x34(%ebp)
                        signflag = 1;
                        goto reswitch;
		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
			goto reswitch;
  800cef:	eb bc                	jmp    800cad <vprintfmt+0x61>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800cf1:	83 c0 01             	add    $0x1,%eax
				precision = precision * 10 + ch - '0';
  800cf4:	8d 1c 9b             	lea    (%ebx,%ebx,4),%ebx
  800cf7:	8d 5c 5a d0          	lea    -0x30(%edx,%ebx,2),%ebx
				ch = *fmt;
  800cfb:	0f be 10             	movsbl (%eax),%edx
				if (ch < '0' || ch > '9')
  800cfe:	8d 7a d0             	lea    -0x30(%edx),%edi
  800d01:	83 ff 09             	cmp    $0x9,%edi
  800d04:	76 eb                	jbe    800cf1 <vprintfmt+0xa5>
  800d06:	eb 23                	jmp    800d2b <vprintfmt+0xdf>
					break;
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  800d08:	8b 55 14             	mov    0x14(%ebp),%edx
  800d0b:	8d 5a 04             	lea    0x4(%edx),%ebx
  800d0e:	89 5d 14             	mov    %ebx,0x14(%ebp)
  800d11:	8b 1a                	mov    (%edx),%ebx
			goto process_precision;
  800d13:	eb 16                	jmp    800d2b <vprintfmt+0xdf>

		case '.':
			if (width < 0)
  800d15:	8b 55 d8             	mov    -0x28(%ebp),%edx
  800d18:	c1 fa 1f             	sar    $0x1f,%edx
  800d1b:	f7 d2                	not    %edx
  800d1d:	21 55 d8             	and    %edx,-0x28(%ebp)
  800d20:	eb 8b                	jmp    800cad <vprintfmt+0x61>
  800d22:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
			goto reswitch;
  800d29:	eb 82                	jmp    800cad <vprintfmt+0x61>

		process_precision:
			if (width < 0)
  800d2b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  800d2f:	0f 89 78 ff ff ff    	jns    800cad <vprintfmt+0x61>
  800d35:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  800d38:	8b 5d c8             	mov    -0x38(%ebp),%ebx
  800d3b:	e9 6d ff ff ff       	jmp    800cad <vprintfmt+0x61>
				width = precision, precision = -1;
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  800d40:	83 c6 01             	add    $0x1,%esi
			goto reswitch;
  800d43:	e9 65 ff ff ff       	jmp    800cad <vprintfmt+0x61>
  800d48:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  800d4b:	8b 45 14             	mov    0x14(%ebp),%eax
  800d4e:	8d 50 04             	lea    0x4(%eax),%edx
  800d51:	89 55 14             	mov    %edx,0x14(%ebp)
  800d54:	8b 55 0c             	mov    0xc(%ebp),%edx
  800d57:	89 54 24 04          	mov    %edx,0x4(%esp)
  800d5b:	8b 00                	mov    (%eax),%eax
  800d5d:	89 04 24             	mov    %eax,(%esp)
  800d60:	ff 55 08             	call   *0x8(%ebp)
  800d63:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			break;
  800d66:	e9 10 ff ff ff       	jmp    800c7b <vprintfmt+0x2f>
  800d6b:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		// error message
		case 'e':
			err = va_arg(ap, int);
  800d6e:	8b 45 14             	mov    0x14(%ebp),%eax
  800d71:	8d 50 04             	lea    0x4(%eax),%edx
  800d74:	89 55 14             	mov    %edx,0x14(%ebp)
  800d77:	8b 00                	mov    (%eax),%eax
  800d79:	89 c2                	mov    %eax,%edx
  800d7b:	c1 fa 1f             	sar    $0x1f,%edx
  800d7e:	31 d0                	xor    %edx,%eax
  800d80:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800d82:	83 f8 0f             	cmp    $0xf,%eax
  800d85:	7f 0b                	jg     800d92 <vprintfmt+0x146>
  800d87:	8b 14 85 40 2a 81 00 	mov    0x812a40(,%eax,4),%edx
  800d8e:	85 d2                	test   %edx,%edx
  800d90:	75 26                	jne    800db8 <vprintfmt+0x16c>
				printfmt(putch, putdat, "error %d", err);
  800d92:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800d96:	c7 44 24 08 04 27 81 	movl   $0x812704,0x8(%esp)
  800d9d:	00 
  800d9e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  800da1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800da5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800da8:	89 1c 24             	mov    %ebx,(%esp)
  800dab:	e8 a7 05 00 00       	call   801357 <printfmt>
  800db0:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		// error message
		case 'e':
			err = va_arg(ap, int);
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800db3:	e9 c3 fe ff ff       	jmp    800c7b <vprintfmt+0x2f>
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800db8:	89 54 24 0c          	mov    %edx,0xc(%esp)
  800dbc:	c7 44 24 08 32 2c 81 	movl   $0x812c32,0x8(%esp)
  800dc3:	00 
  800dc4:	8b 45 0c             	mov    0xc(%ebp),%eax
  800dc7:	89 44 24 04          	mov    %eax,0x4(%esp)
  800dcb:	8b 55 08             	mov    0x8(%ebp),%edx
  800dce:	89 14 24             	mov    %edx,(%esp)
  800dd1:	e8 81 05 00 00       	call   801357 <printfmt>
  800dd6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  800dd9:	e9 9d fe ff ff       	jmp    800c7b <vprintfmt+0x2f>
  800dde:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  800de1:	89 c7                	mov    %eax,%edi
  800de3:	89 d9                	mov    %ebx,%ecx
  800de5:	8b 45 d8             	mov    -0x28(%ebp),%eax
  800de8:	89 45 c0             	mov    %eax,-0x40(%ebp)
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  800deb:	8b 45 14             	mov    0x14(%ebp),%eax
  800dee:	8d 50 04             	lea    0x4(%eax),%edx
  800df1:	89 55 14             	mov    %edx,0x14(%ebp)
  800df4:	8b 30                	mov    (%eax),%esi
  800df6:	85 f6                	test   %esi,%esi
  800df8:	75 05                	jne    800dff <vprintfmt+0x1b3>
  800dfa:	be 0d 27 81 00       	mov    $0x81270d,%esi
				p = "(null)";
			if (width > 0 && padc != '-')
  800dff:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  800e03:	7e 06                	jle    800e0b <vprintfmt+0x1bf>
  800e05:	80 7d cc 2d          	cmpb   $0x2d,-0x34(%ebp)
  800e09:	75 10                	jne    800e1b <vprintfmt+0x1cf>
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800e0b:	0f be 06             	movsbl (%esi),%eax
  800e0e:	85 c0                	test   %eax,%eax
  800e10:	0f 85 a2 00 00 00    	jne    800eb8 <vprintfmt+0x26c>
  800e16:	e9 92 00 00 00       	jmp    800ead <vprintfmt+0x261>
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800e1b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800e1f:	89 34 24             	mov    %esi,(%esp)
  800e22:	e8 74 05 00 00       	call   80139b <strnlen>
  800e27:	8b 55 c0             	mov    -0x40(%ebp),%edx
  800e2a:	29 c2                	sub    %eax,%edx
  800e2c:	89 55 d8             	mov    %edx,-0x28(%ebp)
  800e2f:	85 d2                	test   %edx,%edx
  800e31:	7e d8                	jle    800e0b <vprintfmt+0x1bf>
					putch(padc, putdat);
  800e33:	0f be 4d cc          	movsbl -0x34(%ebp),%ecx
  800e37:	89 5d c0             	mov    %ebx,-0x40(%ebp)
  800e3a:	89 d3                	mov    %edx,%ebx
  800e3c:	89 75 d8             	mov    %esi,-0x28(%ebp)
  800e3f:	89 7d bc             	mov    %edi,-0x44(%ebp)
  800e42:	8b 7d 0c             	mov    0xc(%ebp),%edi
  800e45:	89 ce                	mov    %ecx,%esi
  800e47:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800e4b:	89 34 24             	mov    %esi,(%esp)
  800e4e:	ff 55 08             	call   *0x8(%ebp)
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800e51:	83 eb 01             	sub    $0x1,%ebx
  800e54:	85 db                	test   %ebx,%ebx
  800e56:	7f ef                	jg     800e47 <vprintfmt+0x1fb>
  800e58:	8b 5d c0             	mov    -0x40(%ebp),%ebx
  800e5b:	8b 75 d8             	mov    -0x28(%ebp),%esi
  800e5e:	8b 7d bc             	mov    -0x44(%ebp),%edi
  800e61:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  800e68:	eb a1                	jmp    800e0b <vprintfmt+0x1bf>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  800e6a:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  800e6e:	74 1b                	je     800e8b <vprintfmt+0x23f>
  800e70:	8d 50 e0             	lea    -0x20(%eax),%edx
  800e73:	83 fa 5e             	cmp    $0x5e,%edx
  800e76:	76 13                	jbe    800e8b <vprintfmt+0x23f>
					putch('?', putdat);
  800e78:	8b 45 0c             	mov    0xc(%ebp),%eax
  800e7b:	89 44 24 04          	mov    %eax,0x4(%esp)
  800e7f:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
  800e86:	ff 55 08             	call   *0x8(%ebp)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  800e89:	eb 0d                	jmp    800e98 <vprintfmt+0x24c>
					putch('?', putdat);
				else
					putch(ch, putdat);
  800e8b:	8b 55 0c             	mov    0xc(%ebp),%edx
  800e8e:	89 54 24 04          	mov    %edx,0x4(%esp)
  800e92:	89 04 24             	mov    %eax,(%esp)
  800e95:	ff 55 08             	call   *0x8(%ebp)
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800e98:	83 ef 01             	sub    $0x1,%edi
  800e9b:	0f be 06             	movsbl (%esi),%eax
  800e9e:	85 c0                	test   %eax,%eax
  800ea0:	74 05                	je     800ea7 <vprintfmt+0x25b>
  800ea2:	83 c6 01             	add    $0x1,%esi
  800ea5:	eb 1a                	jmp    800ec1 <vprintfmt+0x275>
  800ea7:	89 7d d8             	mov    %edi,-0x28(%ebp)
  800eaa:	8b 7d cc             	mov    -0x34(%ebp),%edi
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800ead:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  800eb1:	7f 1f                	jg     800ed2 <vprintfmt+0x286>
  800eb3:	e9 c0 fd ff ff       	jmp    800c78 <vprintfmt+0x2c>
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800eb8:	83 c6 01             	add    $0x1,%esi
  800ebb:	89 7d cc             	mov    %edi,-0x34(%ebp)
  800ebe:	8b 7d d8             	mov    -0x28(%ebp),%edi
  800ec1:	85 db                	test   %ebx,%ebx
  800ec3:	78 a5                	js     800e6a <vprintfmt+0x21e>
  800ec5:	83 eb 01             	sub    $0x1,%ebx
  800ec8:	79 a0                	jns    800e6a <vprintfmt+0x21e>
  800eca:	89 7d d8             	mov    %edi,-0x28(%ebp)
  800ecd:	8b 7d cc             	mov    -0x34(%ebp),%edi
  800ed0:	eb db                	jmp    800ead <vprintfmt+0x261>
  800ed2:	8b 5d d8             	mov    -0x28(%ebp),%ebx
  800ed5:	8b 75 0c             	mov    0xc(%ebp),%esi
  800ed8:	89 7d d8             	mov    %edi,-0x28(%ebp)
  800edb:	8b 7d 08             	mov    0x8(%ebp),%edi
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  800ede:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ee2:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  800ee9:	ff d7                	call   *%edi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800eeb:	83 eb 01             	sub    $0x1,%ebx
  800eee:	85 db                	test   %ebx,%ebx
  800ef0:	7f ec                	jg     800ede <vprintfmt+0x292>
  800ef2:	8b 7d d8             	mov    -0x28(%ebp),%edi
  800ef5:	e9 81 fd ff ff       	jmp    800c7b <vprintfmt+0x2f>
  800efa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  800efd:	83 fe 01             	cmp    $0x1,%esi
  800f00:	7e 10                	jle    800f12 <vprintfmt+0x2c6>
		return va_arg(*ap, long long);
  800f02:	8b 45 14             	mov    0x14(%ebp),%eax
  800f05:	8d 50 08             	lea    0x8(%eax),%edx
  800f08:	89 55 14             	mov    %edx,0x14(%ebp)
  800f0b:	8b 18                	mov    (%eax),%ebx
  800f0d:	8b 70 04             	mov    0x4(%eax),%esi
  800f10:	eb 26                	jmp    800f38 <vprintfmt+0x2ec>
	else if (lflag)
  800f12:	85 f6                	test   %esi,%esi
  800f14:	74 12                	je     800f28 <vprintfmt+0x2dc>
		return va_arg(*ap, long);
  800f16:	8b 45 14             	mov    0x14(%ebp),%eax
  800f19:	8d 50 04             	lea    0x4(%eax),%edx
  800f1c:	89 55 14             	mov    %edx,0x14(%ebp)
  800f1f:	8b 18                	mov    (%eax),%ebx
  800f21:	89 de                	mov    %ebx,%esi
  800f23:	c1 fe 1f             	sar    $0x1f,%esi
  800f26:	eb 10                	jmp    800f38 <vprintfmt+0x2ec>
	else
		return va_arg(*ap, int);
  800f28:	8b 45 14             	mov    0x14(%ebp),%eax
  800f2b:	8d 50 04             	lea    0x4(%eax),%edx
  800f2e:	89 55 14             	mov    %edx,0x14(%ebp)
  800f31:	8b 18                	mov    (%eax),%ebx
  800f33:	89 de                	mov    %ebx,%esi
  800f35:	c1 fe 1f             	sar    $0x1f,%esi
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
                        if(signflag == 1){
  800f38:	83 f9 01             	cmp    $0x1,%ecx
  800f3b:	75 1e                	jne    800f5b <vprintfmt+0x30f>
                               if((long long)num > 0){
  800f3d:	85 f6                	test   %esi,%esi
  800f3f:	78 1a                	js     800f5b <vprintfmt+0x30f>
  800f41:	85 f6                	test   %esi,%esi
  800f43:	7f 05                	jg     800f4a <vprintfmt+0x2fe>
  800f45:	83 fb 00             	cmp    $0x0,%ebx
  800f48:	76 11                	jbe    800f5b <vprintfmt+0x30f>
                                   putch('+',putdat);
  800f4a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  800f4d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800f51:	c7 04 24 2b 00 00 00 	movl   $0x2b,(%esp)
  800f58:	ff 55 08             	call   *0x8(%ebp)
                               }
                        }
			if ((long long) num < 0) {
  800f5b:	85 f6                	test   %esi,%esi
  800f5d:	78 13                	js     800f72 <vprintfmt+0x326>
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  800f5f:	89 5d b0             	mov    %ebx,-0x50(%ebp)
  800f62:	89 75 b4             	mov    %esi,-0x4c(%ebp)
  800f65:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  800f68:	b8 0a 00 00 00       	mov    $0xa,%eax
  800f6d:	e9 da 00 00 00       	jmp    80104c <vprintfmt+0x400>
                               if((long long)num > 0){
                                   putch('+',putdat);
                               }
                        }
			if ((long long) num < 0) {
				putch('-', putdat);
  800f72:	8b 45 0c             	mov    0xc(%ebp),%eax
  800f75:	89 44 24 04          	mov    %eax,0x4(%esp)
  800f79:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  800f80:	ff 55 08             	call   *0x8(%ebp)
				num = -(long long) num;
  800f83:	89 da                	mov    %ebx,%edx
  800f85:	89 f1                	mov    %esi,%ecx
  800f87:	f7 da                	neg    %edx
  800f89:	83 d1 00             	adc    $0x0,%ecx
  800f8c:	f7 d9                	neg    %ecx
  800f8e:	89 55 b0             	mov    %edx,-0x50(%ebp)
  800f91:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
  800f94:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  800f97:	b8 0a 00 00 00       	mov    $0xa,%eax
  800f9c:	e9 ab 00 00 00       	jmp    80104c <vprintfmt+0x400>
  800fa1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			base = 10;
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  800fa4:	89 f2                	mov    %esi,%edx
  800fa6:	8d 45 14             	lea    0x14(%ebp),%eax
  800fa9:	e8 47 fc ff ff       	call   800bf5 <getuint>
  800fae:	89 45 b0             	mov    %eax,-0x50(%ebp)
  800fb1:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  800fb4:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  800fb7:	b8 0a 00 00 00       	mov    $0xa,%eax
			base = 10;
			goto number;
  800fbc:	e9 8b 00 00 00       	jmp    80104c <vprintfmt+0x400>
  800fc1:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			// display a number in octal form and the form should begin with '0'
			putch('0', putdat);
  800fc4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  800fc7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800fcb:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  800fd2:	ff 55 08             	call   *0x8(%ebp)
			num = getuint(&ap,lflag);
  800fd5:	89 f2                	mov    %esi,%edx
  800fd7:	8d 45 14             	lea    0x14(%ebp),%eax
  800fda:	e8 16 fc ff ff       	call   800bf5 <getuint>
  800fdf:	89 45 b0             	mov    %eax,-0x50(%ebp)
  800fe2:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  800fe5:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  800fe8:	b8 08 00 00 00       	mov    $0x8,%eax
                        base = 8;
			goto number;
  800fed:	eb 5d                	jmp    80104c <vprintfmt+0x400>
  800fef:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		// pointer
		case 'p':
			putch('0', putdat);
  800ff2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  800ff5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  800ff9:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  801000:	ff 55 08             	call   *0x8(%ebp)
			putch('x', putdat);
  801003:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  801007:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
  80100e:	ff 55 08             	call   *0x8(%ebp)
			num = (unsigned long long)
  801011:	8b 45 14             	mov    0x14(%ebp),%eax
  801014:	8d 50 04             	lea    0x4(%eax),%edx
  801017:	89 55 14             	mov    %edx,0x14(%ebp)
  80101a:	8b 10                	mov    (%eax),%edx
  80101c:	b9 00 00 00 00       	mov    $0x0,%ecx
  801021:	89 55 b0             	mov    %edx,-0x50(%ebp)
  801024:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
  801027:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80102a:	b8 10 00 00 00       	mov    $0x10,%eax
				(uintptr_t) va_arg(ap, void *);
			base = 16;
			goto number;
  80102f:	eb 1b                	jmp    80104c <vprintfmt+0x400>
  801031:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  801034:	89 f2                	mov    %esi,%edx
  801036:	8d 45 14             	lea    0x14(%ebp),%eax
  801039:	e8 b7 fb ff ff       	call   800bf5 <getuint>
  80103e:	89 45 b0             	mov    %eax,-0x50(%ebp)
  801041:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  801044:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  801047:	b8 10 00 00 00       	mov    $0x10,%eax
			base = 16;
		number:
			printnum(putch, putdat, num, base, width, padc);
  80104c:	0f be 4d cc          	movsbl -0x34(%ebp),%ecx
  801050:	89 4d d0             	mov    %ecx,-0x30(%ebp)
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  801053:	89 45 cc             	mov    %eax,-0x34(%ebp)
  801056:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  80105a:	77 09                	ja     801065 <vprintfmt+0x419>
  80105c:	39 45 b0             	cmp    %eax,-0x50(%ebp)
  80105f:	0f 82 ac 00 00 00    	jb     801111 <vprintfmt+0x4c5>
		printnum_v2(putch, putdat, num / base, base, width - 1, padc);
  801065:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  801068:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  80106c:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80106f:	83 ea 01             	sub    $0x1,%edx
  801072:	89 54 24 0c          	mov    %edx,0xc(%esp)
  801076:	89 44 24 08          	mov    %eax,0x8(%esp)
  80107a:	8b 44 24 08          	mov    0x8(%esp),%eax
  80107e:	8b 54 24 0c          	mov    0xc(%esp),%edx
  801082:	89 45 c0             	mov    %eax,-0x40(%ebp)
  801085:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  801088:	8b 55 cc             	mov    -0x34(%ebp),%edx
  80108b:	89 54 24 08          	mov    %edx,0x8(%esp)
  80108f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801096:	00 
  801097:	8b 4d b0             	mov    -0x50(%ebp),%ecx
  80109a:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
  80109d:	89 0c 24             	mov    %ecx,(%esp)
  8010a0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8010a4:	e8 d7 10 01 00       	call   812180 <__udivdi3>
  8010a9:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  8010ac:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
  8010af:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8010b3:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  8010b7:	89 04 24             	mov    %eax,(%esp)
  8010ba:	89 54 24 04          	mov    %edx,0x4(%esp)
  8010be:	8b 55 0c             	mov    0xc(%ebp),%edx
  8010c1:	8b 45 08             	mov    0x8(%ebp),%eax
  8010c4:	e8 37 fa ff ff       	call   800b00 <printnum_v2>
			putch(padc, putdat);
                }
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  8010c9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8010cc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8010d0:	8b 74 24 04          	mov    0x4(%esp),%esi
  8010d4:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8010d7:	89 44 24 08          	mov    %eax,0x8(%esp)
  8010db:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8010e2:	00 
  8010e3:	8b 55 b0             	mov    -0x50(%ebp),%edx
  8010e6:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
  8010e9:	89 14 24             	mov    %edx,(%esp)
  8010ec:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  8010f0:	e8 bb 11 01 00       	call   8122b0 <__umoddi3>
  8010f5:	89 74 24 04          	mov    %esi,0x4(%esp)
  8010f9:	0f be 80 f3 26 81 00 	movsbl 0x8126f3(%eax),%eax
  801100:	89 04 24             	mov    %eax,(%esp)
  801103:	ff 55 08             	call   *0x8(%ebp)
        if(padc == '-'){
  801106:	83 7d d0 2d          	cmpl   $0x2d,-0x30(%ebp)
  80110a:	74 54                	je     801160 <vprintfmt+0x514>
  80110c:	e9 67 fb ff ff       	jmp    800c78 <vprintfmt+0x2c>
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum_v2(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
                if(padc != '-'){
  801111:	83 7d d0 2d          	cmpl   $0x2d,-0x30(%ebp)
  801115:	8d 76 00             	lea    0x0(%esi),%esi
  801118:	0f 84 2a 01 00 00    	je     801248 <vprintfmt+0x5fc>
		while (--width > 0)
  80111e:	8b 7d d8             	mov    -0x28(%ebp),%edi
  801121:	83 ef 01             	sub    $0x1,%edi
  801124:	85 ff                	test   %edi,%edi
  801126:	0f 8e 5e 01 00 00    	jle    80128a <vprintfmt+0x63e>
  80112c:	8b 4d b0             	mov    -0x50(%ebp),%ecx
  80112f:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
  801132:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  801135:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  801138:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  80113b:	8b 75 0c             	mov    0xc(%ebp),%esi
			putch(padc, putdat);
  80113e:	89 74 24 04          	mov    %esi,0x4(%esp)
  801142:	89 1c 24             	mov    %ebx,(%esp)
  801145:	ff 55 08             	call   *0x8(%ebp)
	if (num >= base) {
		printnum_v2(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
                if(padc != '-'){
		while (--width > 0)
  801148:	83 ef 01             	sub    $0x1,%edi
  80114b:	85 ff                	test   %edi,%edi
  80114d:	7f ef                	jg     80113e <vprintfmt+0x4f2>
  80114f:	8b 45 d8             	mov    -0x28(%ebp),%eax
  801152:	8b 55 dc             	mov    -0x24(%ebp),%edx
  801155:	89 45 b0             	mov    %eax,-0x50(%ebp)
  801158:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  80115b:	e9 2a 01 00 00       	jmp    80128a <vprintfmt+0x63e>
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
        if(padc == '-'){
           while (--width > 0)
  801160:	8b 5d d8             	mov    -0x28(%ebp),%ebx
  801163:	83 eb 01             	sub    $0x1,%ebx
  801166:	85 db                	test   %ebx,%ebx
  801168:	0f 8e 0a fb ff ff    	jle    800c78 <vprintfmt+0x2c>
  80116e:	8b 75 0c             	mov    0xc(%ebp),%esi
  801171:	89 7d d8             	mov    %edi,-0x28(%ebp)
  801174:	8b 7d 08             	mov    0x8(%ebp),%edi
			putch(' ', putdat);
  801177:	89 74 24 04          	mov    %esi,0x4(%esp)
  80117b:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  801182:	ff d7                	call   *%edi
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
        if(padc == '-'){
           while (--width > 0)
  801184:	83 eb 01             	sub    $0x1,%ebx
  801187:	85 db                	test   %ebx,%ebx
  801189:	7f ec                	jg     801177 <vprintfmt+0x52b>
  80118b:	8b 7d d8             	mov    -0x28(%ebp),%edi
  80118e:	e9 e8 fa ff ff       	jmp    800c7b <vprintfmt+0x2f>
  801193:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            const char *null_error = "\nerror! writing through NULL pointer! (%n argument)\n";
            const char *overflow_error = "\nwarning! The value %n argument pointed to has been overflowed!\n";

            // Your code here
            char* n;
            if ((n = va_arg(ap, char *)) == NULL)
  801196:	8b 45 14             	mov    0x14(%ebp),%eax
  801199:	8d 50 04             	lea    0x4(%eax),%edx
  80119c:	89 55 14             	mov    %edx,0x14(%ebp)
  80119f:	8b 00                	mov    (%eax),%eax
  8011a1:	85 c0                	test   %eax,%eax
  8011a3:	75 2a                	jne    8011cf <vprintfmt+0x583>
		  printfmt(putch,putdat,"%s",null_error);
  8011a5:	c7 44 24 0c 28 28 81 	movl   $0x812828,0xc(%esp)
  8011ac:	00 
  8011ad:	c7 44 24 08 32 2c 81 	movl   $0x812c32,0x8(%esp)
  8011b4:	00 
  8011b5:	8b 55 0c             	mov    0xc(%ebp),%edx
  8011b8:	89 54 24 04          	mov    %edx,0x4(%esp)
  8011bc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8011bf:	89 0c 24             	mov    %ecx,(%esp)
  8011c2:	e8 90 01 00 00       	call   801357 <printfmt>
  8011c7:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8011ca:	e9 ac fa ff ff       	jmp    800c7b <vprintfmt+0x2f>
            else if((*(int*)putdat) > 127){
  8011cf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8011d2:	8b 13                	mov    (%ebx),%edx
  8011d4:	83 fa 7f             	cmp    $0x7f,%edx
  8011d7:	7e 29                	jle    801202 <vprintfmt+0x5b6>
                  *n = *(int*)putdat;
  8011d9:	88 10                	mov    %dl,(%eax)
                  printfmt(putch,putdat,"%s",overflow_error);
  8011db:	c7 44 24 0c 60 28 81 	movl   $0x812860,0xc(%esp)
  8011e2:	00 
  8011e3:	c7 44 24 08 32 2c 81 	movl   $0x812c32,0x8(%esp)
  8011ea:	00 
  8011eb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8011ef:	8b 45 08             	mov    0x8(%ebp),%eax
  8011f2:	89 04 24             	mov    %eax,(%esp)
  8011f5:	e8 5d 01 00 00       	call   801357 <printfmt>
  8011fa:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8011fd:	e9 79 fa ff ff       	jmp    800c7b <vprintfmt+0x2f>
            }
            else
                  *n = *(int*)putdat;
  801202:	88 10                	mov    %dl,(%eax)
  801204:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  801207:	e9 6f fa ff ff       	jmp    800c7b <vprintfmt+0x2f>
  80120c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80120f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            break;
        }
		// escaped '%' character
		case '%':
			putch(ch, putdat);
  801212:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801215:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  801219:	89 14 24             	mov    %edx,(%esp)
  80121c:	ff 55 08             	call   *0x8(%ebp)
  80121f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			break;
  801222:	e9 54 fa ff ff       	jmp    800c7b <vprintfmt+0x2f>
			
		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  801227:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80122a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80122e:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  801235:	ff 55 08             	call   *0x8(%ebp)
			for (fmt--; fmt[-1] != '%'; fmt--)
  801238:	8d 47 ff             	lea    -0x1(%edi),%eax
  80123b:	80 38 25             	cmpb   $0x25,(%eax)
  80123e:	0f 84 37 fa ff ff    	je     800c7b <vprintfmt+0x2f>
  801244:	89 c7                	mov    %eax,%edi
  801246:	eb f0                	jmp    801238 <vprintfmt+0x5ec>
			putch(padc, putdat);
                }
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  801248:	8b 45 0c             	mov    0xc(%ebp),%eax
  80124b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80124f:	8b 74 24 04          	mov    0x4(%esp),%esi
  801253:	8b 55 cc             	mov    -0x34(%ebp),%edx
  801256:	89 54 24 08          	mov    %edx,0x8(%esp)
  80125a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801261:	00 
  801262:	8b 45 b0             	mov    -0x50(%ebp),%eax
  801265:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  801268:	89 04 24             	mov    %eax,(%esp)
  80126b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80126f:	e8 3c 10 01 00       	call   8122b0 <__umoddi3>
  801274:	89 74 24 04          	mov    %esi,0x4(%esp)
  801278:	0f be 80 f3 26 81 00 	movsbl 0x8126f3(%eax),%eax
  80127f:	89 04 24             	mov    %eax,(%esp)
  801282:	ff 55 08             	call   *0x8(%ebp)
  801285:	e9 d6 fe ff ff       	jmp    801160 <vprintfmt+0x514>
  80128a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80128d:	89 54 24 04          	mov    %edx,0x4(%esp)
  801291:	8b 74 24 04          	mov    0x4(%esp),%esi
  801295:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  801298:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80129c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8012a3:	00 
  8012a4:	8b 45 b0             	mov    -0x50(%ebp),%eax
  8012a7:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  8012aa:	89 04 24             	mov    %eax,(%esp)
  8012ad:	89 54 24 04          	mov    %edx,0x4(%esp)
  8012b1:	e8 fa 0f 01 00       	call   8122b0 <__umoddi3>
  8012b6:	89 74 24 04          	mov    %esi,0x4(%esp)
  8012ba:	0f be 80 f3 26 81 00 	movsbl 0x8126f3(%eax),%eax
  8012c1:	89 04 24             	mov    %eax,(%esp)
  8012c4:	ff 55 08             	call   *0x8(%ebp)
  8012c7:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8012ca:	e9 ac f9 ff ff       	jmp    800c7b <vprintfmt+0x2f>
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
  8012cf:	83 c4 6c             	add    $0x6c,%esp
  8012d2:	5b                   	pop    %ebx
  8012d3:	5e                   	pop    %esi
  8012d4:	5f                   	pop    %edi
  8012d5:	5d                   	pop    %ebp
  8012d6:	c3                   	ret    

008012d7 <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  8012d7:	55                   	push   %ebp
  8012d8:	89 e5                	mov    %esp,%ebp
  8012da:	83 ec 28             	sub    $0x28,%esp
  8012dd:	8b 45 08             	mov    0x8(%ebp),%eax
  8012e0:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
  8012e3:	85 c0                	test   %eax,%eax
  8012e5:	74 04                	je     8012eb <vsnprintf+0x14>
  8012e7:	85 d2                	test   %edx,%edx
  8012e9:	7f 07                	jg     8012f2 <vsnprintf+0x1b>
  8012eb:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8012f0:	eb 3b                	jmp    80132d <vsnprintf+0x56>
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};
  8012f2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  8012f5:	8d 44 10 ff          	lea    -0x1(%eax,%edx,1),%eax
  8012f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  8012fc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  801303:	8b 45 14             	mov    0x14(%ebp),%eax
  801306:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80130a:	8b 45 10             	mov    0x10(%ebp),%eax
  80130d:	89 44 24 08          	mov    %eax,0x8(%esp)
  801311:	8d 45 ec             	lea    -0x14(%ebp),%eax
  801314:	89 44 24 04          	mov    %eax,0x4(%esp)
  801318:	c7 04 24 2f 0c 80 00 	movl   $0x800c2f,(%esp)
  80131f:	e8 28 f9 ff ff       	call   800c4c <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  801324:	8b 45 ec             	mov    -0x14(%ebp),%eax
  801327:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80132a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  80132d:	c9                   	leave  
  80132e:	c3                   	ret    

0080132f <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80132f:	55                   	push   %ebp
  801330:	89 e5                	mov    %esp,%ebp
  801332:	83 ec 18             	sub    $0x18,%esp

	return b.cnt;
}

int
snprintf(char *buf, int n, const char *fmt, ...)
  801335:	8d 45 14             	lea    0x14(%ebp),%eax
{
	va_list ap;
	int rc;

	va_start(ap, fmt);
	rc = vsnprintf(buf, n, fmt, ap);
  801338:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80133c:	8b 45 10             	mov    0x10(%ebp),%eax
  80133f:	89 44 24 08          	mov    %eax,0x8(%esp)
  801343:	8b 45 0c             	mov    0xc(%ebp),%eax
  801346:	89 44 24 04          	mov    %eax,0x4(%esp)
  80134a:	8b 45 08             	mov    0x8(%ebp),%eax
  80134d:	89 04 24             	mov    %eax,(%esp)
  801350:	e8 82 ff ff ff       	call   8012d7 <vsnprintf>
	va_end(ap);

	return rc;
}
  801355:	c9                   	leave  
  801356:	c3                   	ret    

00801357 <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  801357:	55                   	push   %ebp
  801358:	89 e5                	mov    %esp,%ebp
  80135a:	83 ec 18             	sub    $0x18,%esp
		}
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
  80135d:	8d 45 14             	lea    0x14(%ebp),%eax
{
	va_list ap;

	va_start(ap, fmt);
	vprintfmt(putch, putdat, fmt, ap);
  801360:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801364:	8b 45 10             	mov    0x10(%ebp),%eax
  801367:	89 44 24 08          	mov    %eax,0x8(%esp)
  80136b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80136e:	89 44 24 04          	mov    %eax,0x4(%esp)
  801372:	8b 45 08             	mov    0x8(%ebp),%eax
  801375:	89 04 24             	mov    %eax,(%esp)
  801378:	e8 cf f8 ff ff       	call   800c4c <vprintfmt>
	va_end(ap);
}
  80137d:	c9                   	leave  
  80137e:	c3                   	ret    
	...

00801380 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  801380:	55                   	push   %ebp
  801381:	89 e5                	mov    %esp,%ebp
  801383:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  801386:	b8 00 00 00 00       	mov    $0x0,%eax
  80138b:	80 3a 00             	cmpb   $0x0,(%edx)
  80138e:	74 09                	je     801399 <strlen+0x19>
		n++;
  801390:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  801393:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  801397:	75 f7                	jne    801390 <strlen+0x10>
		n++;
	return n;
}
  801399:	5d                   	pop    %ebp
  80139a:	c3                   	ret    

0080139b <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80139b:	55                   	push   %ebp
  80139c:	89 e5                	mov    %esp,%ebp
  80139e:	53                   	push   %ebx
  80139f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8013a2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  8013a5:	85 c9                	test   %ecx,%ecx
  8013a7:	74 19                	je     8013c2 <strnlen+0x27>
  8013a9:	80 3b 00             	cmpb   $0x0,(%ebx)
  8013ac:	74 14                	je     8013c2 <strnlen+0x27>
  8013ae:	b8 00 00 00 00       	mov    $0x0,%eax
		n++;
  8013b3:	83 c0 01             	add    $0x1,%eax
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  8013b6:	39 c8                	cmp    %ecx,%eax
  8013b8:	74 0d                	je     8013c7 <strnlen+0x2c>
  8013ba:	80 3c 03 00          	cmpb   $0x0,(%ebx,%eax,1)
  8013be:	75 f3                	jne    8013b3 <strnlen+0x18>
  8013c0:	eb 05                	jmp    8013c7 <strnlen+0x2c>
  8013c2:	b8 00 00 00 00       	mov    $0x0,%eax
		n++;
	return n;
}
  8013c7:	5b                   	pop    %ebx
  8013c8:	5d                   	pop    %ebp
  8013c9:	c3                   	ret    

008013ca <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  8013ca:	55                   	push   %ebp
  8013cb:	89 e5                	mov    %esp,%ebp
  8013cd:	53                   	push   %ebx
  8013ce:	8b 45 08             	mov    0x8(%ebp),%eax
  8013d1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8013d4:	ba 00 00 00 00       	mov    $0x0,%edx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  8013d9:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  8013dd:	88 0c 10             	mov    %cl,(%eax,%edx,1)
  8013e0:	83 c2 01             	add    $0x1,%edx
  8013e3:	84 c9                	test   %cl,%cl
  8013e5:	75 f2                	jne    8013d9 <strcpy+0xf>
		/* do nothing */;
	return ret;
}
  8013e7:	5b                   	pop    %ebx
  8013e8:	5d                   	pop    %ebp
  8013e9:	c3                   	ret    

008013ea <strcat>:

char *
strcat(char *dst, const char *src)
{
  8013ea:	55                   	push   %ebp
  8013eb:	89 e5                	mov    %esp,%ebp
  8013ed:	53                   	push   %ebx
  8013ee:	83 ec 08             	sub    $0x8,%esp
  8013f1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  8013f4:	89 1c 24             	mov    %ebx,(%esp)
  8013f7:	e8 84 ff ff ff       	call   801380 <strlen>
	strcpy(dst + len, src);
  8013fc:	8b 55 0c             	mov    0xc(%ebp),%edx
  8013ff:	89 54 24 04          	mov    %edx,0x4(%esp)
  801403:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  801406:	89 04 24             	mov    %eax,(%esp)
  801409:	e8 bc ff ff ff       	call   8013ca <strcpy>
	return dst;
}
  80140e:	89 d8                	mov    %ebx,%eax
  801410:	83 c4 08             	add    $0x8,%esp
  801413:	5b                   	pop    %ebx
  801414:	5d                   	pop    %ebp
  801415:	c3                   	ret    

00801416 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  801416:	55                   	push   %ebp
  801417:	89 e5                	mov    %esp,%ebp
  801419:	56                   	push   %esi
  80141a:	53                   	push   %ebx
  80141b:	8b 45 08             	mov    0x8(%ebp),%eax
  80141e:	8b 55 0c             	mov    0xc(%ebp),%edx
  801421:	8b 75 10             	mov    0x10(%ebp),%esi
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801424:	85 f6                	test   %esi,%esi
  801426:	74 18                	je     801440 <strncpy+0x2a>
  801428:	b9 00 00 00 00       	mov    $0x0,%ecx
		*dst++ = *src;
  80142d:	0f b6 1a             	movzbl (%edx),%ebx
  801430:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  801433:	80 3a 01             	cmpb   $0x1,(%edx)
  801436:	83 da ff             	sbb    $0xffffffff,%edx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801439:	83 c1 01             	add    $0x1,%ecx
  80143c:	39 ce                	cmp    %ecx,%esi
  80143e:	77 ed                	ja     80142d <strncpy+0x17>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  801440:	5b                   	pop    %ebx
  801441:	5e                   	pop    %esi
  801442:	5d                   	pop    %ebp
  801443:	c3                   	ret    

00801444 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  801444:	55                   	push   %ebp
  801445:	89 e5                	mov    %esp,%ebp
  801447:	56                   	push   %esi
  801448:	53                   	push   %ebx
  801449:	8b 75 08             	mov    0x8(%ebp),%esi
  80144c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80144f:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  801452:	89 f0                	mov    %esi,%eax
  801454:	85 c9                	test   %ecx,%ecx
  801456:	74 27                	je     80147f <strlcpy+0x3b>
		while (--size > 0 && *src != '\0')
  801458:	83 e9 01             	sub    $0x1,%ecx
  80145b:	74 1d                	je     80147a <strlcpy+0x36>
  80145d:	0f b6 1a             	movzbl (%edx),%ebx
  801460:	84 db                	test   %bl,%bl
  801462:	74 16                	je     80147a <strlcpy+0x36>
			*dst++ = *src++;
  801464:	88 18                	mov    %bl,(%eax)
  801466:	83 c0 01             	add    $0x1,%eax
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  801469:	83 e9 01             	sub    $0x1,%ecx
  80146c:	74 0e                	je     80147c <strlcpy+0x38>
			*dst++ = *src++;
  80146e:	83 c2 01             	add    $0x1,%edx
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  801471:	0f b6 1a             	movzbl (%edx),%ebx
  801474:	84 db                	test   %bl,%bl
  801476:	75 ec                	jne    801464 <strlcpy+0x20>
  801478:	eb 02                	jmp    80147c <strlcpy+0x38>
  80147a:	89 f0                	mov    %esi,%eax
			*dst++ = *src++;
		*dst = '\0';
  80147c:	c6 00 00             	movb   $0x0,(%eax)
  80147f:	29 f0                	sub    %esi,%eax
	}
	return dst - dst_in;
}
  801481:	5b                   	pop    %ebx
  801482:	5e                   	pop    %esi
  801483:	5d                   	pop    %ebp
  801484:	c3                   	ret    

00801485 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  801485:	55                   	push   %ebp
  801486:	89 e5                	mov    %esp,%ebp
  801488:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80148b:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80148e:	0f b6 01             	movzbl (%ecx),%eax
  801491:	84 c0                	test   %al,%al
  801493:	74 15                	je     8014aa <strcmp+0x25>
  801495:	3a 02                	cmp    (%edx),%al
  801497:	75 11                	jne    8014aa <strcmp+0x25>
		p++, q++;
  801499:	83 c1 01             	add    $0x1,%ecx
  80149c:	83 c2 01             	add    $0x1,%edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  80149f:	0f b6 01             	movzbl (%ecx),%eax
  8014a2:	84 c0                	test   %al,%al
  8014a4:	74 04                	je     8014aa <strcmp+0x25>
  8014a6:	3a 02                	cmp    (%edx),%al
  8014a8:	74 ef                	je     801499 <strcmp+0x14>
  8014aa:	0f b6 c0             	movzbl %al,%eax
  8014ad:	0f b6 12             	movzbl (%edx),%edx
  8014b0:	29 d0                	sub    %edx,%eax
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
}
  8014b2:	5d                   	pop    %ebp
  8014b3:	c3                   	ret    

008014b4 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  8014b4:	55                   	push   %ebp
  8014b5:	89 e5                	mov    %esp,%ebp
  8014b7:	53                   	push   %ebx
  8014b8:	8b 55 08             	mov    0x8(%ebp),%edx
  8014bb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8014be:	8b 45 10             	mov    0x10(%ebp),%eax
	while (n > 0 && *p && *p == *q)
  8014c1:	85 c0                	test   %eax,%eax
  8014c3:	74 23                	je     8014e8 <strncmp+0x34>
  8014c5:	0f b6 1a             	movzbl (%edx),%ebx
  8014c8:	84 db                	test   %bl,%bl
  8014ca:	74 25                	je     8014f1 <strncmp+0x3d>
  8014cc:	3a 19                	cmp    (%ecx),%bl
  8014ce:	75 21                	jne    8014f1 <strncmp+0x3d>
  8014d0:	83 e8 01             	sub    $0x1,%eax
  8014d3:	74 13                	je     8014e8 <strncmp+0x34>
		n--, p++, q++;
  8014d5:	83 c2 01             	add    $0x1,%edx
  8014d8:	83 c1 01             	add    $0x1,%ecx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  8014db:	0f b6 1a             	movzbl (%edx),%ebx
  8014de:	84 db                	test   %bl,%bl
  8014e0:	74 0f                	je     8014f1 <strncmp+0x3d>
  8014e2:	3a 19                	cmp    (%ecx),%bl
  8014e4:	74 ea                	je     8014d0 <strncmp+0x1c>
  8014e6:	eb 09                	jmp    8014f1 <strncmp+0x3d>
  8014e8:	b8 00 00 00 00       	mov    $0x0,%eax
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  8014ed:	5b                   	pop    %ebx
  8014ee:	5d                   	pop    %ebp
  8014ef:	90                   	nop
  8014f0:	c3                   	ret    
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  8014f1:	0f b6 02             	movzbl (%edx),%eax
  8014f4:	0f b6 11             	movzbl (%ecx),%edx
  8014f7:	29 d0                	sub    %edx,%eax
  8014f9:	eb f2                	jmp    8014ed <strncmp+0x39>

008014fb <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  8014fb:	55                   	push   %ebp
  8014fc:	89 e5                	mov    %esp,%ebp
  8014fe:	8b 45 08             	mov    0x8(%ebp),%eax
  801501:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  801505:	0f b6 10             	movzbl (%eax),%edx
  801508:	84 d2                	test   %dl,%dl
  80150a:	74 18                	je     801524 <strchr+0x29>
		if (*s == c)
  80150c:	38 ca                	cmp    %cl,%dl
  80150e:	75 0a                	jne    80151a <strchr+0x1f>
  801510:	eb 17                	jmp    801529 <strchr+0x2e>
  801512:	38 ca                	cmp    %cl,%dl
  801514:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  801518:	74 0f                	je     801529 <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80151a:	83 c0 01             	add    $0x1,%eax
  80151d:	0f b6 10             	movzbl (%eax),%edx
  801520:	84 d2                	test   %dl,%dl
  801522:	75 ee                	jne    801512 <strchr+0x17>
  801524:	b8 00 00 00 00       	mov    $0x0,%eax
		if (*s == c)
			return (char *) s;
	return 0;
}
  801529:	5d                   	pop    %ebp
  80152a:	c3                   	ret    

0080152b <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80152b:	55                   	push   %ebp
  80152c:	89 e5                	mov    %esp,%ebp
  80152e:	8b 45 08             	mov    0x8(%ebp),%eax
  801531:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  801535:	0f b6 10             	movzbl (%eax),%edx
  801538:	84 d2                	test   %dl,%dl
  80153a:	74 18                	je     801554 <strfind+0x29>
		if (*s == c)
  80153c:	38 ca                	cmp    %cl,%dl
  80153e:	75 0a                	jne    80154a <strfind+0x1f>
  801540:	eb 12                	jmp    801554 <strfind+0x29>
  801542:	38 ca                	cmp    %cl,%dl
  801544:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  801548:	74 0a                	je     801554 <strfind+0x29>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  80154a:	83 c0 01             	add    $0x1,%eax
  80154d:	0f b6 10             	movzbl (%eax),%edx
  801550:	84 d2                	test   %dl,%dl
  801552:	75 ee                	jne    801542 <strfind+0x17>
		if (*s == c)
			break;
	return (char *) s;
}
  801554:	5d                   	pop    %ebp
  801555:	c3                   	ret    

00801556 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  801556:	55                   	push   %ebp
  801557:	89 e5                	mov    %esp,%ebp
  801559:	83 ec 0c             	sub    $0xc,%esp
  80155c:	89 1c 24             	mov    %ebx,(%esp)
  80155f:	89 74 24 04          	mov    %esi,0x4(%esp)
  801563:	89 7c 24 08          	mov    %edi,0x8(%esp)
  801567:	8b 7d 08             	mov    0x8(%ebp),%edi
  80156a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80156d:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  801570:	85 c9                	test   %ecx,%ecx
  801572:	74 30                	je     8015a4 <memset+0x4e>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  801574:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80157a:	75 25                	jne    8015a1 <memset+0x4b>
  80157c:	f6 c1 03             	test   $0x3,%cl
  80157f:	75 20                	jne    8015a1 <memset+0x4b>
		c &= 0xFF;
  801581:	0f b6 d0             	movzbl %al,%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  801584:	89 d3                	mov    %edx,%ebx
  801586:	c1 e3 08             	shl    $0x8,%ebx
  801589:	89 d6                	mov    %edx,%esi
  80158b:	c1 e6 18             	shl    $0x18,%esi
  80158e:	89 d0                	mov    %edx,%eax
  801590:	c1 e0 10             	shl    $0x10,%eax
  801593:	09 f0                	or     %esi,%eax
  801595:	09 d0                	or     %edx,%eax
		asm volatile("cld; rep stosl\n"
  801597:	09 d8                	or     %ebx,%eax
  801599:	c1 e9 02             	shr    $0x2,%ecx
  80159c:	fc                   	cld    
  80159d:	f3 ab                	rep stos %eax,%es:(%edi)
{
	char *p;

	if (n == 0)
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80159f:	eb 03                	jmp    8015a4 <memset+0x4e>
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  8015a1:	fc                   	cld    
  8015a2:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  8015a4:	89 f8                	mov    %edi,%eax
  8015a6:	8b 1c 24             	mov    (%esp),%ebx
  8015a9:	8b 74 24 04          	mov    0x4(%esp),%esi
  8015ad:	8b 7c 24 08          	mov    0x8(%esp),%edi
  8015b1:	89 ec                	mov    %ebp,%esp
  8015b3:	5d                   	pop    %ebp
  8015b4:	c3                   	ret    

008015b5 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  8015b5:	55                   	push   %ebp
  8015b6:	89 e5                	mov    %esp,%ebp
  8015b8:	83 ec 08             	sub    $0x8,%esp
  8015bb:	89 34 24             	mov    %esi,(%esp)
  8015be:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8015c2:	8b 45 08             	mov    0x8(%ebp),%eax
  8015c5:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;
	
	s = src;
  8015c8:	8b 75 0c             	mov    0xc(%ebp),%esi
	d = dst;
  8015cb:	89 c7                	mov    %eax,%edi
	if (s < d && s + n > d) {
  8015cd:	39 c6                	cmp    %eax,%esi
  8015cf:	73 35                	jae    801606 <memmove+0x51>
  8015d1:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  8015d4:	39 d0                	cmp    %edx,%eax
  8015d6:	73 2e                	jae    801606 <memmove+0x51>
		s += n;
		d += n;
  8015d8:	01 cf                	add    %ecx,%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  8015da:	f6 c2 03             	test   $0x3,%dl
  8015dd:	75 1b                	jne    8015fa <memmove+0x45>
  8015df:	f7 c7 03 00 00 00    	test   $0x3,%edi
  8015e5:	75 13                	jne    8015fa <memmove+0x45>
  8015e7:	f6 c1 03             	test   $0x3,%cl
  8015ea:	75 0e                	jne    8015fa <memmove+0x45>
			asm volatile("std; rep movsl\n"
  8015ec:	83 ef 04             	sub    $0x4,%edi
  8015ef:	8d 72 fc             	lea    -0x4(%edx),%esi
  8015f2:	c1 e9 02             	shr    $0x2,%ecx
  8015f5:	fd                   	std    
  8015f6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  8015f8:	eb 09                	jmp    801603 <memmove+0x4e>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  8015fa:	83 ef 01             	sub    $0x1,%edi
  8015fd:	8d 72 ff             	lea    -0x1(%edx),%esi
  801600:	fd                   	std    
  801601:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  801603:	fc                   	cld    
	const char *s;
	char *d;
	
	s = src;
	d = dst;
	if (s < d && s + n > d) {
  801604:	eb 20                	jmp    801626 <memmove+0x71>
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801606:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80160c:	75 15                	jne    801623 <memmove+0x6e>
  80160e:	f7 c7 03 00 00 00    	test   $0x3,%edi
  801614:	75 0d                	jne    801623 <memmove+0x6e>
  801616:	f6 c1 03             	test   $0x3,%cl
  801619:	75 08                	jne    801623 <memmove+0x6e>
			asm volatile("cld; rep movsl\n"
  80161b:	c1 e9 02             	shr    $0x2,%ecx
  80161e:	fc                   	cld    
  80161f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801621:	eb 03                	jmp    801626 <memmove+0x71>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  801623:	fc                   	cld    
  801624:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  801626:	8b 34 24             	mov    (%esp),%esi
  801629:	8b 7c 24 04          	mov    0x4(%esp),%edi
  80162d:	89 ec                	mov    %ebp,%esp
  80162f:	5d                   	pop    %ebp
  801630:	c3                   	ret    

00801631 <memcpy>:

/* sigh - gcc emits references to this for structure assignments! */
/* it is *not* prototyped in inc/string.h - do not use directly. */
void *
memcpy(void *dst, void *src, size_t n)
{
  801631:	55                   	push   %ebp
  801632:	89 e5                	mov    %esp,%ebp
  801634:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  801637:	8b 45 10             	mov    0x10(%ebp),%eax
  80163a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80163e:	8b 45 0c             	mov    0xc(%ebp),%eax
  801641:	89 44 24 04          	mov    %eax,0x4(%esp)
  801645:	8b 45 08             	mov    0x8(%ebp),%eax
  801648:	89 04 24             	mov    %eax,(%esp)
  80164b:	e8 65 ff ff ff       	call   8015b5 <memmove>
}
  801650:	c9                   	leave  
  801651:	c3                   	ret    

00801652 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  801652:	55                   	push   %ebp
  801653:	89 e5                	mov    %esp,%ebp
  801655:	57                   	push   %edi
  801656:	56                   	push   %esi
  801657:	53                   	push   %ebx
  801658:	8b 75 08             	mov    0x8(%ebp),%esi
  80165b:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80165e:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  801661:	85 c9                	test   %ecx,%ecx
  801663:	74 36                	je     80169b <memcmp+0x49>
		if (*s1 != *s2)
  801665:	0f b6 06             	movzbl (%esi),%eax
  801668:	0f b6 1f             	movzbl (%edi),%ebx
  80166b:	38 d8                	cmp    %bl,%al
  80166d:	74 20                	je     80168f <memcmp+0x3d>
  80166f:	eb 14                	jmp    801685 <memcmp+0x33>
  801671:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  801676:	0f b6 5c 17 01       	movzbl 0x1(%edi,%edx,1),%ebx
  80167b:	83 c2 01             	add    $0x1,%edx
  80167e:	83 e9 01             	sub    $0x1,%ecx
  801681:	38 d8                	cmp    %bl,%al
  801683:	74 12                	je     801697 <memcmp+0x45>
			return (int) *s1 - (int) *s2;
  801685:	0f b6 c0             	movzbl %al,%eax
  801688:	0f b6 db             	movzbl %bl,%ebx
  80168b:	29 d8                	sub    %ebx,%eax
  80168d:	eb 11                	jmp    8016a0 <memcmp+0x4e>
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80168f:	83 e9 01             	sub    $0x1,%ecx
  801692:	ba 00 00 00 00       	mov    $0x0,%edx
  801697:	85 c9                	test   %ecx,%ecx
  801699:	75 d6                	jne    801671 <memcmp+0x1f>
  80169b:	b8 00 00 00 00       	mov    $0x0,%eax
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
}
  8016a0:	5b                   	pop    %ebx
  8016a1:	5e                   	pop    %esi
  8016a2:	5f                   	pop    %edi
  8016a3:	5d                   	pop    %ebp
  8016a4:	c3                   	ret    

008016a5 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  8016a5:	55                   	push   %ebp
  8016a6:	89 e5                	mov    %esp,%ebp
  8016a8:	8b 45 08             	mov    0x8(%ebp),%eax
	const void *ends = (const char *) s + n;
  8016ab:	89 c2                	mov    %eax,%edx
  8016ad:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  8016b0:	39 d0                	cmp    %edx,%eax
  8016b2:	73 15                	jae    8016c9 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
  8016b4:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
  8016b8:	38 08                	cmp    %cl,(%eax)
  8016ba:	75 06                	jne    8016c2 <memfind+0x1d>
  8016bc:	eb 0b                	jmp    8016c9 <memfind+0x24>
  8016be:	38 08                	cmp    %cl,(%eax)
  8016c0:	74 07                	je     8016c9 <memfind+0x24>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  8016c2:	83 c0 01             	add    $0x1,%eax
  8016c5:	39 c2                	cmp    %eax,%edx
  8016c7:	77 f5                	ja     8016be <memfind+0x19>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  8016c9:	5d                   	pop    %ebp
  8016ca:	c3                   	ret    

008016cb <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  8016cb:	55                   	push   %ebp
  8016cc:	89 e5                	mov    %esp,%ebp
  8016ce:	57                   	push   %edi
  8016cf:	56                   	push   %esi
  8016d0:	53                   	push   %ebx
  8016d1:	83 ec 04             	sub    $0x4,%esp
  8016d4:	8b 55 08             	mov    0x8(%ebp),%edx
  8016d7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  8016da:	0f b6 02             	movzbl (%edx),%eax
  8016dd:	3c 20                	cmp    $0x20,%al
  8016df:	74 04                	je     8016e5 <strtol+0x1a>
  8016e1:	3c 09                	cmp    $0x9,%al
  8016e3:	75 0e                	jne    8016f3 <strtol+0x28>
		s++;
  8016e5:	83 c2 01             	add    $0x1,%edx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  8016e8:	0f b6 02             	movzbl (%edx),%eax
  8016eb:	3c 20                	cmp    $0x20,%al
  8016ed:	74 f6                	je     8016e5 <strtol+0x1a>
  8016ef:	3c 09                	cmp    $0x9,%al
  8016f1:	74 f2                	je     8016e5 <strtol+0x1a>
		s++;

	// plus/minus sign
	if (*s == '+')
  8016f3:	3c 2b                	cmp    $0x2b,%al
  8016f5:	75 0c                	jne    801703 <strtol+0x38>
		s++;
  8016f7:	83 c2 01             	add    $0x1,%edx
  8016fa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  801701:	eb 15                	jmp    801718 <strtol+0x4d>
	else if (*s == '-')
  801703:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  80170a:	3c 2d                	cmp    $0x2d,%al
  80170c:	75 0a                	jne    801718 <strtol+0x4d>
		s++, neg = 1;
  80170e:	83 c2 01             	add    $0x1,%edx
  801711:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  801718:	85 db                	test   %ebx,%ebx
  80171a:	0f 94 c0             	sete   %al
  80171d:	74 05                	je     801724 <strtol+0x59>
  80171f:	83 fb 10             	cmp    $0x10,%ebx
  801722:	75 18                	jne    80173c <strtol+0x71>
  801724:	80 3a 30             	cmpb   $0x30,(%edx)
  801727:	75 13                	jne    80173c <strtol+0x71>
  801729:	80 7a 01 78          	cmpb   $0x78,0x1(%edx)
  80172d:	8d 76 00             	lea    0x0(%esi),%esi
  801730:	75 0a                	jne    80173c <strtol+0x71>
		s += 2, base = 16;
  801732:	83 c2 02             	add    $0x2,%edx
  801735:	bb 10 00 00 00       	mov    $0x10,%ebx
		s++;
	else if (*s == '-')
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80173a:	eb 15                	jmp    801751 <strtol+0x86>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80173c:	84 c0                	test   %al,%al
  80173e:	66 90                	xchg   %ax,%ax
  801740:	74 0f                	je     801751 <strtol+0x86>
  801742:	bb 0a 00 00 00       	mov    $0xa,%ebx
  801747:	80 3a 30             	cmpb   $0x30,(%edx)
  80174a:	75 05                	jne    801751 <strtol+0x86>
		s++, base = 8;
  80174c:	83 c2 01             	add    $0x1,%edx
  80174f:	b3 08                	mov    $0x8,%bl
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  801751:	b8 00 00 00 00       	mov    $0x0,%eax
  801756:	89 de                	mov    %ebx,%esi

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  801758:	0f b6 0a             	movzbl (%edx),%ecx
  80175b:	89 cf                	mov    %ecx,%edi
  80175d:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  801760:	80 fb 09             	cmp    $0x9,%bl
  801763:	77 08                	ja     80176d <strtol+0xa2>
			dig = *s - '0';
  801765:	0f be c9             	movsbl %cl,%ecx
  801768:	83 e9 30             	sub    $0x30,%ecx
  80176b:	eb 1e                	jmp    80178b <strtol+0xc0>
		else if (*s >= 'a' && *s <= 'z')
  80176d:	8d 5f 9f             	lea    -0x61(%edi),%ebx
  801770:	80 fb 19             	cmp    $0x19,%bl
  801773:	77 08                	ja     80177d <strtol+0xb2>
			dig = *s - 'a' + 10;
  801775:	0f be c9             	movsbl %cl,%ecx
  801778:	83 e9 57             	sub    $0x57,%ecx
  80177b:	eb 0e                	jmp    80178b <strtol+0xc0>
		else if (*s >= 'A' && *s <= 'Z')
  80177d:	8d 5f bf             	lea    -0x41(%edi),%ebx
  801780:	80 fb 19             	cmp    $0x19,%bl
  801783:	77 15                	ja     80179a <strtol+0xcf>
			dig = *s - 'A' + 10;
  801785:	0f be c9             	movsbl %cl,%ecx
  801788:	83 e9 37             	sub    $0x37,%ecx
		else
			break;
		if (dig >= base)
  80178b:	39 f1                	cmp    %esi,%ecx
  80178d:	7d 0b                	jge    80179a <strtol+0xcf>
			break;
		s++, val = (val * base) + dig;
  80178f:	83 c2 01             	add    $0x1,%edx
  801792:	0f af c6             	imul   %esi,%eax
  801795:	8d 04 01             	lea    (%ecx,%eax,1),%eax
		// we don't properly detect overflow!
	}
  801798:	eb be                	jmp    801758 <strtol+0x8d>
  80179a:	89 c1                	mov    %eax,%ecx

	if (endptr)
  80179c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8017a0:	74 05                	je     8017a7 <strtol+0xdc>
		*endptr = (char *) s;
  8017a2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8017a5:	89 13                	mov    %edx,(%ebx)
	return (neg ? -val : val);
  8017a7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  8017ab:	74 04                	je     8017b1 <strtol+0xe6>
  8017ad:	89 c8                	mov    %ecx,%eax
  8017af:	f7 d8                	neg    %eax
}
  8017b1:	83 c4 04             	add    $0x4,%esp
  8017b4:	5b                   	pop    %ebx
  8017b5:	5e                   	pop    %esi
  8017b6:	5f                   	pop    %edi
  8017b7:	5d                   	pop    %ebp
  8017b8:	c3                   	ret    
  8017b9:	00 00                	add    %al,(%eax)
	...

008017bc <sys_cgetc>:
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}

int
sys_cgetc(void)
{
  8017bc:	55                   	push   %ebp
  8017bd:	89 e5                	mov    %esp,%ebp
  8017bf:	83 ec 08             	sub    $0x8,%esp
  8017c2:	89 1c 24             	mov    %ebx,(%esp)
  8017c5:	89 7c 24 04          	mov    %edi,0x4(%esp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  8017c9:	ba 00 00 00 00       	mov    $0x0,%edx
  8017ce:	b8 01 00 00 00       	mov    $0x1,%eax
  8017d3:	89 d1                	mov    %edx,%ecx
  8017d5:	89 d3                	mov    %edx,%ebx
  8017d7:	89 d7                	mov    %edx,%edi
  8017d9:	51                   	push   %ecx
  8017da:	52                   	push   %edx
  8017db:	53                   	push   %ebx
  8017dc:	54                   	push   %esp
  8017dd:	55                   	push   %ebp
  8017de:	56                   	push   %esi
  8017df:	57                   	push   %edi
  8017e0:	54                   	push   %esp
  8017e1:	5d                   	pop    %ebp
  8017e2:	8d 35 ea 17 80 00    	lea    0x8017ea,%esi
  8017e8:	0f 34                	sysenter 
  8017ea:	5f                   	pop    %edi
  8017eb:	5e                   	pop    %esi
  8017ec:	5d                   	pop    %ebp
  8017ed:	5c                   	pop    %esp
  8017ee:	5b                   	pop    %ebx
  8017ef:	5a                   	pop    %edx
  8017f0:	59                   	pop    %ecx

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  8017f1:	8b 1c 24             	mov    (%esp),%ebx
  8017f4:	8b 7c 24 04          	mov    0x4(%esp),%edi
  8017f8:	89 ec                	mov    %ebp,%esp
  8017fa:	5d                   	pop    %ebp
  8017fb:	c3                   	ret    

008017fc <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  8017fc:	55                   	push   %ebp
  8017fd:	89 e5                	mov    %esp,%ebp
  8017ff:	83 ec 08             	sub    $0x8,%esp
  801802:	89 1c 24             	mov    %ebx,(%esp)
  801805:	89 7c 24 04          	mov    %edi,0x4(%esp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801809:	b8 00 00 00 00       	mov    $0x0,%eax
  80180e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801811:	8b 55 08             	mov    0x8(%ebp),%edx
  801814:	89 c3                	mov    %eax,%ebx
  801816:	89 c7                	mov    %eax,%edi
  801818:	51                   	push   %ecx
  801819:	52                   	push   %edx
  80181a:	53                   	push   %ebx
  80181b:	54                   	push   %esp
  80181c:	55                   	push   %ebp
  80181d:	56                   	push   %esi
  80181e:	57                   	push   %edi
  80181f:	54                   	push   %esp
  801820:	5d                   	pop    %ebp
  801821:	8d 35 29 18 80 00    	lea    0x801829,%esi
  801827:	0f 34                	sysenter 
  801829:	5f                   	pop    %edi
  80182a:	5e                   	pop    %esi
  80182b:	5d                   	pop    %ebp
  80182c:	5c                   	pop    %esp
  80182d:	5b                   	pop    %ebx
  80182e:	5a                   	pop    %edx
  80182f:	59                   	pop    %ecx

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  801830:	8b 1c 24             	mov    (%esp),%ebx
  801833:	8b 7c 24 04          	mov    0x4(%esp),%edi
  801837:	89 ec                	mov    %ebp,%esp
  801839:	5d                   	pop    %ebp
  80183a:	c3                   	ret    

0080183b <sys_get_mac>:
sys_receive_packet(uint32_t addr,int* len){
         return syscall(SYS_receive_packet,0,(uint32_t)addr,(uint32_t)len,0,0,0);
}

int 
sys_get_mac(uint8_t* macaddr){
  80183b:	55                   	push   %ebp
  80183c:	89 e5                	mov    %esp,%ebp
  80183e:	83 ec 08             	sub    $0x8,%esp
  801841:	89 1c 24             	mov    %ebx,(%esp)
  801844:	89 7c 24 04          	mov    %edi,0x4(%esp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801848:	b9 00 00 00 00       	mov    $0x0,%ecx
  80184d:	b8 13 00 00 00       	mov    $0x13,%eax
  801852:	8b 55 08             	mov    0x8(%ebp),%edx
  801855:	89 cb                	mov    %ecx,%ebx
  801857:	89 cf                	mov    %ecx,%edi
  801859:	51                   	push   %ecx
  80185a:	52                   	push   %edx
  80185b:	53                   	push   %ebx
  80185c:	54                   	push   %esp
  80185d:	55                   	push   %ebp
  80185e:	56                   	push   %esi
  80185f:	57                   	push   %edi
  801860:	54                   	push   %esp
  801861:	5d                   	pop    %ebp
  801862:	8d 35 6a 18 80 00    	lea    0x80186a,%esi
  801868:	0f 34                	sysenter 
  80186a:	5f                   	pop    %edi
  80186b:	5e                   	pop    %esi
  80186c:	5d                   	pop    %ebp
  80186d:	5c                   	pop    %esp
  80186e:	5b                   	pop    %ebx
  80186f:	5a                   	pop    %edx
  801870:	59                   	pop    %ecx
}

int 
sys_get_mac(uint8_t* macaddr){
         return syscall(SYS_get_mac,0,(uint32_t)macaddr,0,0,0,0);
}
  801871:	8b 1c 24             	mov    (%esp),%ebx
  801874:	8b 7c 24 04          	mov    0x4(%esp),%edi
  801878:	89 ec                	mov    %ebp,%esp
  80187a:	5d                   	pop    %ebp
  80187b:	c3                   	ret    

0080187c <sys_receive_packet>:
sys_transmit_packet(uint32_t addr,int len){
         return syscall(SYS_transmit_packet,0,(uint32_t)addr,(uint32_t)len,0,0,0);
}

int 
sys_receive_packet(uint32_t addr,int* len){
  80187c:	55                   	push   %ebp
  80187d:	89 e5                	mov    %esp,%ebp
  80187f:	83 ec 08             	sub    $0x8,%esp
  801882:	89 1c 24             	mov    %ebx,(%esp)
  801885:	89 7c 24 04          	mov    %edi,0x4(%esp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801889:	bb 00 00 00 00       	mov    $0x0,%ebx
  80188e:	b8 12 00 00 00       	mov    $0x12,%eax
  801893:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801896:	8b 55 08             	mov    0x8(%ebp),%edx
  801899:	89 df                	mov    %ebx,%edi
  80189b:	51                   	push   %ecx
  80189c:	52                   	push   %edx
  80189d:	53                   	push   %ebx
  80189e:	54                   	push   %esp
  80189f:	55                   	push   %ebp
  8018a0:	56                   	push   %esi
  8018a1:	57                   	push   %edi
  8018a2:	54                   	push   %esp
  8018a3:	5d                   	pop    %ebp
  8018a4:	8d 35 ac 18 80 00    	lea    0x8018ac,%esi
  8018aa:	0f 34                	sysenter 
  8018ac:	5f                   	pop    %edi
  8018ad:	5e                   	pop    %esi
  8018ae:	5d                   	pop    %ebp
  8018af:	5c                   	pop    %esp
  8018b0:	5b                   	pop    %ebx
  8018b1:	5a                   	pop    %edx
  8018b2:	59                   	pop    %ecx
}

int 
sys_receive_packet(uint32_t addr,int* len){
         return syscall(SYS_receive_packet,0,(uint32_t)addr,(uint32_t)len,0,0,0);
}
  8018b3:	8b 1c 24             	mov    (%esp),%ebx
  8018b6:	8b 7c 24 04          	mov    0x4(%esp),%edi
  8018ba:	89 ec                	mov    %ebp,%esp
  8018bc:	5d                   	pop    %ebp
  8018bd:	c3                   	ret    

008018be <sys_transmit_packet>:
sys_exec(void* vph, uint32_t phnum, uint32_t esp, uint32_t eip){
         return syscall(SYS_exec, 0, (uint32_t)vph, phnum, esp, eip, 0);
}

int 
sys_transmit_packet(uint32_t addr,int len){
  8018be:	55                   	push   %ebp
  8018bf:	89 e5                	mov    %esp,%ebp
  8018c1:	83 ec 08             	sub    $0x8,%esp
  8018c4:	89 1c 24             	mov    %ebx,(%esp)
  8018c7:	89 7c 24 04          	mov    %edi,0x4(%esp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  8018cb:	bb 00 00 00 00       	mov    $0x0,%ebx
  8018d0:	b8 11 00 00 00       	mov    $0x11,%eax
  8018d5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8018d8:	8b 55 08             	mov    0x8(%ebp),%edx
  8018db:	89 df                	mov    %ebx,%edi
  8018dd:	51                   	push   %ecx
  8018de:	52                   	push   %edx
  8018df:	53                   	push   %ebx
  8018e0:	54                   	push   %esp
  8018e1:	55                   	push   %ebp
  8018e2:	56                   	push   %esi
  8018e3:	57                   	push   %edi
  8018e4:	54                   	push   %esp
  8018e5:	5d                   	pop    %ebp
  8018e6:	8d 35 ee 18 80 00    	lea    0x8018ee,%esi
  8018ec:	0f 34                	sysenter 
  8018ee:	5f                   	pop    %edi
  8018ef:	5e                   	pop    %esi
  8018f0:	5d                   	pop    %ebp
  8018f1:	5c                   	pop    %esp
  8018f2:	5b                   	pop    %ebx
  8018f3:	5a                   	pop    %edx
  8018f4:	59                   	pop    %ecx
}

int 
sys_transmit_packet(uint32_t addr,int len){
         return syscall(SYS_transmit_packet,0,(uint32_t)addr,(uint32_t)len,0,0,0);
}
  8018f5:	8b 1c 24             	mov    (%esp),%ebx
  8018f8:	8b 7c 24 04          	mov    0x4(%esp),%edi
  8018fc:	89 ec                	mov    %ebp,%esp
  8018fe:	5d                   	pop    %ebp
  8018ff:	c3                   	ret    

00801900 <sys_exec>:
sys_env_set_prior(envid_t envid, uint32_t prior){
         return syscall(SYS_env_set_prior,1,envid, prior, 0, 0, 0);
}

int 
sys_exec(void* vph, uint32_t phnum, uint32_t esp, uint32_t eip){
  801900:	55                   	push   %ebp
  801901:	89 e5                	mov    %esp,%ebp
  801903:	83 ec 08             	sub    $0x8,%esp
  801906:	89 1c 24             	mov    %ebx,(%esp)
  801909:	89 7c 24 04          	mov    %edi,0x4(%esp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  80190d:	b8 10 00 00 00       	mov    $0x10,%eax
  801912:	8b 7d 14             	mov    0x14(%ebp),%edi
  801915:	8b 5d 10             	mov    0x10(%ebp),%ebx
  801918:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80191b:	8b 55 08             	mov    0x8(%ebp),%edx
  80191e:	51                   	push   %ecx
  80191f:	52                   	push   %edx
  801920:	53                   	push   %ebx
  801921:	54                   	push   %esp
  801922:	55                   	push   %ebp
  801923:	56                   	push   %esi
  801924:	57                   	push   %edi
  801925:	54                   	push   %esp
  801926:	5d                   	pop    %ebp
  801927:	8d 35 2f 19 80 00    	lea    0x80192f,%esi
  80192d:	0f 34                	sysenter 
  80192f:	5f                   	pop    %edi
  801930:	5e                   	pop    %esi
  801931:	5d                   	pop    %ebp
  801932:	5c                   	pop    %esp
  801933:	5b                   	pop    %ebx
  801934:	5a                   	pop    %edx
  801935:	59                   	pop    %ecx
}

int 
sys_exec(void* vph, uint32_t phnum, uint32_t esp, uint32_t eip){
         return syscall(SYS_exec, 0, (uint32_t)vph, phnum, esp, eip, 0);
}
  801936:	8b 1c 24             	mov    (%esp),%ebx
  801939:	8b 7c 24 04          	mov    0x4(%esp),%edi
  80193d:	89 ec                	mov    %ebp,%esp
  80193f:	5d                   	pop    %ebp
  801940:	c3                   	ret    

00801941 <sys_env_set_prior>:
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}


int 
sys_env_set_prior(envid_t envid, uint32_t prior){
  801941:	55                   	push   %ebp
  801942:	89 e5                	mov    %esp,%ebp
  801944:	83 ec 28             	sub    $0x28,%esp
  801947:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80194a:	89 7d fc             	mov    %edi,-0x4(%ebp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  80194d:	bb 00 00 00 00       	mov    $0x0,%ebx
  801952:	b8 0f 00 00 00       	mov    $0xf,%eax
  801957:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80195a:	8b 55 08             	mov    0x8(%ebp),%edx
  80195d:	89 df                	mov    %ebx,%edi
  80195f:	51                   	push   %ecx
  801960:	52                   	push   %edx
  801961:	53                   	push   %ebx
  801962:	54                   	push   %esp
  801963:	55                   	push   %ebp
  801964:	56                   	push   %esi
  801965:	57                   	push   %edi
  801966:	54                   	push   %esp
  801967:	5d                   	pop    %ebp
  801968:	8d 35 70 19 80 00    	lea    0x801970,%esi
  80196e:	0f 34                	sysenter 
  801970:	5f                   	pop    %edi
  801971:	5e                   	pop    %esi
  801972:	5d                   	pop    %ebp
  801973:	5c                   	pop    %esp
  801974:	5b                   	pop    %ebx
  801975:	5a                   	pop    %edx
  801976:	59                   	pop    %ecx
                   "d" (a1),
                   "c" (a2),
                   "b" (a3),
                   "D" (a4)
                 : "cc", "memory");
	if(check && ret > 0)
  801977:	85 c0                	test   %eax,%eax
  801979:	7e 28                	jle    8019a3 <sys_env_set_prior+0x62>
		panic("syscall %d returned %d (> 0)", num, ret);
  80197b:	89 44 24 10          	mov    %eax,0x10(%esp)
  80197f:	c7 44 24 0c 0f 00 00 	movl   $0xf,0xc(%esp)
  801986:	00 
  801987:	c7 44 24 08 80 2a 81 	movl   $0x812a80,0x8(%esp)
  80198e:	00 
  80198f:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  801996:	00 
  801997:	c7 04 24 9d 2a 81 00 	movl   $0x812a9d,(%esp)
  80199e:	e8 45 f0 ff ff       	call   8009e8 <_panic>


int 
sys_env_set_prior(envid_t envid, uint32_t prior){
         return syscall(SYS_env_set_prior,1,envid, prior, 0, 0, 0);
}
  8019a3:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8019a6:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8019a9:	89 ec                	mov    %ebp,%esp
  8019ab:	5d                   	pop    %ebp
  8019ac:	c3                   	ret    

008019ad <sys_time_msec>:
}


unsigned int
sys_time_msec(void)
{
  8019ad:	55                   	push   %ebp
  8019ae:	89 e5                	mov    %esp,%ebp
  8019b0:	83 ec 08             	sub    $0x8,%esp
  8019b3:	89 1c 24             	mov    %ebx,(%esp)
  8019b6:	89 7c 24 04          	mov    %edi,0x4(%esp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  8019ba:	ba 00 00 00 00       	mov    $0x0,%edx
  8019bf:	b8 15 00 00 00       	mov    $0x15,%eax
  8019c4:	89 d1                	mov    %edx,%ecx
  8019c6:	89 d3                	mov    %edx,%ebx
  8019c8:	89 d7                	mov    %edx,%edi
  8019ca:	51                   	push   %ecx
  8019cb:	52                   	push   %edx
  8019cc:	53                   	push   %ebx
  8019cd:	54                   	push   %esp
  8019ce:	55                   	push   %ebp
  8019cf:	56                   	push   %esi
  8019d0:	57                   	push   %edi
  8019d1:	54                   	push   %esp
  8019d2:	5d                   	pop    %ebp
  8019d3:	8d 35 db 19 80 00    	lea    0x8019db,%esi
  8019d9:	0f 34                	sysenter 
  8019db:	5f                   	pop    %edi
  8019dc:	5e                   	pop    %esi
  8019dd:	5d                   	pop    %ebp
  8019de:	5c                   	pop    %esp
  8019df:	5b                   	pop    %ebx
  8019e0:	5a                   	pop    %edx
  8019e1:	59                   	pop    %ecx

unsigned int
sys_time_msec(void)
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  8019e2:	8b 1c 24             	mov    (%esp),%ebx
  8019e5:	8b 7c 24 04          	mov    0x4(%esp),%edi
  8019e9:	89 ec                	mov    %ebp,%esp
  8019eb:	5d                   	pop    %ebp
  8019ec:	c3                   	ret    

008019ed <sys_sbrk>:
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}

int
sys_sbrk(uint32_t inc)
{
  8019ed:	55                   	push   %ebp
  8019ee:	89 e5                	mov    %esp,%ebp
  8019f0:	83 ec 08             	sub    $0x8,%esp
  8019f3:	89 1c 24             	mov    %ebx,(%esp)
  8019f6:	89 7c 24 04          	mov    %edi,0x4(%esp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  8019fa:	b9 00 00 00 00       	mov    $0x0,%ecx
  8019ff:	b8 14 00 00 00       	mov    $0x14,%eax
  801a04:	8b 55 08             	mov    0x8(%ebp),%edx
  801a07:	89 cb                	mov    %ecx,%ebx
  801a09:	89 cf                	mov    %ecx,%edi
  801a0b:	51                   	push   %ecx
  801a0c:	52                   	push   %edx
  801a0d:	53                   	push   %ebx
  801a0e:	54                   	push   %esp
  801a0f:	55                   	push   %ebp
  801a10:	56                   	push   %esi
  801a11:	57                   	push   %edi
  801a12:	54                   	push   %esp
  801a13:	5d                   	pop    %ebp
  801a14:	8d 35 1c 1a 80 00    	lea    0x801a1c,%esi
  801a1a:	0f 34                	sysenter 
  801a1c:	5f                   	pop    %edi
  801a1d:	5e                   	pop    %esi
  801a1e:	5d                   	pop    %ebp
  801a1f:	5c                   	pop    %esp
  801a20:	5b                   	pop    %ebx
  801a21:	5a                   	pop    %edx
  801a22:	59                   	pop    %ecx

int
sys_sbrk(uint32_t inc)
{
	 return syscall(SYS_sbrk, 0, (uint32_t)inc, (uint32_t)0, 0, 0, 0);
}
  801a23:	8b 1c 24             	mov    (%esp),%ebx
  801a26:	8b 7c 24 04          	mov    0x4(%esp),%edi
  801a2a:	89 ec                	mov    %ebp,%esp
  801a2c:	5d                   	pop    %ebp
  801a2d:	c3                   	ret    

00801a2e <sys_ipc_recv>:
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}

int
sys_ipc_recv(void *dstva)
{
  801a2e:	55                   	push   %ebp
  801a2f:	89 e5                	mov    %esp,%ebp
  801a31:	83 ec 28             	sub    $0x28,%esp
  801a34:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  801a37:	89 7d fc             	mov    %edi,-0x4(%ebp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801a3a:	b9 00 00 00 00       	mov    $0x0,%ecx
  801a3f:	b8 0e 00 00 00       	mov    $0xe,%eax
  801a44:	8b 55 08             	mov    0x8(%ebp),%edx
  801a47:	89 cb                	mov    %ecx,%ebx
  801a49:	89 cf                	mov    %ecx,%edi
  801a4b:	51                   	push   %ecx
  801a4c:	52                   	push   %edx
  801a4d:	53                   	push   %ebx
  801a4e:	54                   	push   %esp
  801a4f:	55                   	push   %ebp
  801a50:	56                   	push   %esi
  801a51:	57                   	push   %edi
  801a52:	54                   	push   %esp
  801a53:	5d                   	pop    %ebp
  801a54:	8d 35 5c 1a 80 00    	lea    0x801a5c,%esi
  801a5a:	0f 34                	sysenter 
  801a5c:	5f                   	pop    %edi
  801a5d:	5e                   	pop    %esi
  801a5e:	5d                   	pop    %ebp
  801a5f:	5c                   	pop    %esp
  801a60:	5b                   	pop    %ebx
  801a61:	5a                   	pop    %edx
  801a62:	59                   	pop    %ecx
                   "d" (a1),
                   "c" (a2),
                   "b" (a3),
                   "D" (a4)
                 : "cc", "memory");
	if(check && ret > 0)
  801a63:	85 c0                	test   %eax,%eax
  801a65:	7e 28                	jle    801a8f <sys_ipc_recv+0x61>
		panic("syscall %d returned %d (> 0)", num, ret);
  801a67:	89 44 24 10          	mov    %eax,0x10(%esp)
  801a6b:	c7 44 24 0c 0e 00 00 	movl   $0xe,0xc(%esp)
  801a72:	00 
  801a73:	c7 44 24 08 80 2a 81 	movl   $0x812a80,0x8(%esp)
  801a7a:	00 
  801a7b:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  801a82:	00 
  801a83:	c7 04 24 9d 2a 81 00 	movl   $0x812a9d,(%esp)
  801a8a:	e8 59 ef ff ff       	call   8009e8 <_panic>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  801a8f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  801a92:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801a95:	89 ec                	mov    %ebp,%esp
  801a97:	5d                   	pop    %ebp
  801a98:	c3                   	ret    

00801a99 <sys_ipc_try_send>:
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  801a99:	55                   	push   %ebp
  801a9a:	89 e5                	mov    %esp,%ebp
  801a9c:	83 ec 08             	sub    $0x8,%esp
  801a9f:	89 1c 24             	mov    %ebx,(%esp)
  801aa2:	89 7c 24 04          	mov    %edi,0x4(%esp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801aa6:	b8 0d 00 00 00       	mov    $0xd,%eax
  801aab:	8b 7d 14             	mov    0x14(%ebp),%edi
  801aae:	8b 5d 10             	mov    0x10(%ebp),%ebx
  801ab1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801ab4:	8b 55 08             	mov    0x8(%ebp),%edx
  801ab7:	51                   	push   %ecx
  801ab8:	52                   	push   %edx
  801ab9:	53                   	push   %ebx
  801aba:	54                   	push   %esp
  801abb:	55                   	push   %ebp
  801abc:	56                   	push   %esi
  801abd:	57                   	push   %edi
  801abe:	54                   	push   %esp
  801abf:	5d                   	pop    %ebp
  801ac0:	8d 35 c8 1a 80 00    	lea    0x801ac8,%esi
  801ac6:	0f 34                	sysenter 
  801ac8:	5f                   	pop    %edi
  801ac9:	5e                   	pop    %esi
  801aca:	5d                   	pop    %ebp
  801acb:	5c                   	pop    %esp
  801acc:	5b                   	pop    %ebx
  801acd:	5a                   	pop    %edx
  801ace:	59                   	pop    %ecx

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  801acf:	8b 1c 24             	mov    (%esp),%ebx
  801ad2:	8b 7c 24 04          	mov    0x4(%esp),%edi
  801ad6:	89 ec                	mov    %ebp,%esp
  801ad8:	5d                   	pop    %ebp
  801ad9:	c3                   	ret    

00801ada <sys_env_set_pgfault_upcall>:
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  801ada:	55                   	push   %ebp
  801adb:	89 e5                	mov    %esp,%ebp
  801add:	83 ec 28             	sub    $0x28,%esp
  801ae0:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  801ae3:	89 7d fc             	mov    %edi,-0x4(%ebp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801ae6:	bb 00 00 00 00       	mov    $0x0,%ebx
  801aeb:	b8 0b 00 00 00       	mov    $0xb,%eax
  801af0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801af3:	8b 55 08             	mov    0x8(%ebp),%edx
  801af6:	89 df                	mov    %ebx,%edi
  801af8:	51                   	push   %ecx
  801af9:	52                   	push   %edx
  801afa:	53                   	push   %ebx
  801afb:	54                   	push   %esp
  801afc:	55                   	push   %ebp
  801afd:	56                   	push   %esi
  801afe:	57                   	push   %edi
  801aff:	54                   	push   %esp
  801b00:	5d                   	pop    %ebp
  801b01:	8d 35 09 1b 80 00    	lea    0x801b09,%esi
  801b07:	0f 34                	sysenter 
  801b09:	5f                   	pop    %edi
  801b0a:	5e                   	pop    %esi
  801b0b:	5d                   	pop    %ebp
  801b0c:	5c                   	pop    %esp
  801b0d:	5b                   	pop    %ebx
  801b0e:	5a                   	pop    %edx
  801b0f:	59                   	pop    %ecx
                   "d" (a1),
                   "c" (a2),
                   "b" (a3),
                   "D" (a4)
                 : "cc", "memory");
	if(check && ret > 0)
  801b10:	85 c0                	test   %eax,%eax
  801b12:	7e 28                	jle    801b3c <sys_env_set_pgfault_upcall+0x62>
		panic("syscall %d returned %d (> 0)", num, ret);
  801b14:	89 44 24 10          	mov    %eax,0x10(%esp)
  801b18:	c7 44 24 0c 0b 00 00 	movl   $0xb,0xc(%esp)
  801b1f:	00 
  801b20:	c7 44 24 08 80 2a 81 	movl   $0x812a80,0x8(%esp)
  801b27:	00 
  801b28:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  801b2f:	00 
  801b30:	c7 04 24 9d 2a 81 00 	movl   $0x812a9d,(%esp)
  801b37:	e8 ac ee ff ff       	call   8009e8 <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  801b3c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  801b3f:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801b42:	89 ec                	mov    %ebp,%esp
  801b44:	5d                   	pop    %ebp
  801b45:	c3                   	ret    

00801b46 <sys_env_set_trapframe>:
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  801b46:	55                   	push   %ebp
  801b47:	89 e5                	mov    %esp,%ebp
  801b49:	83 ec 28             	sub    $0x28,%esp
  801b4c:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  801b4f:	89 7d fc             	mov    %edi,-0x4(%ebp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801b52:	bb 00 00 00 00       	mov    $0x0,%ebx
  801b57:	b8 0a 00 00 00       	mov    $0xa,%eax
  801b5c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801b5f:	8b 55 08             	mov    0x8(%ebp),%edx
  801b62:	89 df                	mov    %ebx,%edi
  801b64:	51                   	push   %ecx
  801b65:	52                   	push   %edx
  801b66:	53                   	push   %ebx
  801b67:	54                   	push   %esp
  801b68:	55                   	push   %ebp
  801b69:	56                   	push   %esi
  801b6a:	57                   	push   %edi
  801b6b:	54                   	push   %esp
  801b6c:	5d                   	pop    %ebp
  801b6d:	8d 35 75 1b 80 00    	lea    0x801b75,%esi
  801b73:	0f 34                	sysenter 
  801b75:	5f                   	pop    %edi
  801b76:	5e                   	pop    %esi
  801b77:	5d                   	pop    %ebp
  801b78:	5c                   	pop    %esp
  801b79:	5b                   	pop    %ebx
  801b7a:	5a                   	pop    %edx
  801b7b:	59                   	pop    %ecx
                   "d" (a1),
                   "c" (a2),
                   "b" (a3),
                   "D" (a4)
                 : "cc", "memory");
	if(check && ret > 0)
  801b7c:	85 c0                	test   %eax,%eax
  801b7e:	7e 28                	jle    801ba8 <sys_env_set_trapframe+0x62>
		panic("syscall %d returned %d (> 0)", num, ret);
  801b80:	89 44 24 10          	mov    %eax,0x10(%esp)
  801b84:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
  801b8b:	00 
  801b8c:	c7 44 24 08 80 2a 81 	movl   $0x812a80,0x8(%esp)
  801b93:	00 
  801b94:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  801b9b:	00 
  801b9c:	c7 04 24 9d 2a 81 00 	movl   $0x812a9d,(%esp)
  801ba3:	e8 40 ee ff ff       	call   8009e8 <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  801ba8:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  801bab:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801bae:	89 ec                	mov    %ebp,%esp
  801bb0:	5d                   	pop    %ebp
  801bb1:	c3                   	ret    

00801bb2 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  801bb2:	55                   	push   %ebp
  801bb3:	89 e5                	mov    %esp,%ebp
  801bb5:	83 ec 28             	sub    $0x28,%esp
  801bb8:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  801bbb:	89 7d fc             	mov    %edi,-0x4(%ebp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801bbe:	bb 00 00 00 00       	mov    $0x0,%ebx
  801bc3:	b8 09 00 00 00       	mov    $0x9,%eax
  801bc8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801bcb:	8b 55 08             	mov    0x8(%ebp),%edx
  801bce:	89 df                	mov    %ebx,%edi
  801bd0:	51                   	push   %ecx
  801bd1:	52                   	push   %edx
  801bd2:	53                   	push   %ebx
  801bd3:	54                   	push   %esp
  801bd4:	55                   	push   %ebp
  801bd5:	56                   	push   %esi
  801bd6:	57                   	push   %edi
  801bd7:	54                   	push   %esp
  801bd8:	5d                   	pop    %ebp
  801bd9:	8d 35 e1 1b 80 00    	lea    0x801be1,%esi
  801bdf:	0f 34                	sysenter 
  801be1:	5f                   	pop    %edi
  801be2:	5e                   	pop    %esi
  801be3:	5d                   	pop    %ebp
  801be4:	5c                   	pop    %esp
  801be5:	5b                   	pop    %ebx
  801be6:	5a                   	pop    %edx
  801be7:	59                   	pop    %ecx
                   "d" (a1),
                   "c" (a2),
                   "b" (a3),
                   "D" (a4)
                 : "cc", "memory");
	if(check && ret > 0)
  801be8:	85 c0                	test   %eax,%eax
  801bea:	7e 28                	jle    801c14 <sys_env_set_status+0x62>
		panic("syscall %d returned %d (> 0)", num, ret);
  801bec:	89 44 24 10          	mov    %eax,0x10(%esp)
  801bf0:	c7 44 24 0c 09 00 00 	movl   $0x9,0xc(%esp)
  801bf7:	00 
  801bf8:	c7 44 24 08 80 2a 81 	movl   $0x812a80,0x8(%esp)
  801bff:	00 
  801c00:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  801c07:	00 
  801c08:	c7 04 24 9d 2a 81 00 	movl   $0x812a9d,(%esp)
  801c0f:	e8 d4 ed ff ff       	call   8009e8 <_panic>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  801c14:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  801c17:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801c1a:	89 ec                	mov    %ebp,%esp
  801c1c:	5d                   	pop    %ebp
  801c1d:	c3                   	ret    

00801c1e <sys_page_unmap>:
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, ((uint32_t) dstva)|perm, perm);
}

int
sys_page_unmap(envid_t envid, void *va)
{
  801c1e:	55                   	push   %ebp
  801c1f:	89 e5                	mov    %esp,%ebp
  801c21:	83 ec 28             	sub    $0x28,%esp
  801c24:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  801c27:	89 7d fc             	mov    %edi,-0x4(%ebp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801c2a:	bb 00 00 00 00       	mov    $0x0,%ebx
  801c2f:	b8 07 00 00 00       	mov    $0x7,%eax
  801c34:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801c37:	8b 55 08             	mov    0x8(%ebp),%edx
  801c3a:	89 df                	mov    %ebx,%edi
  801c3c:	51                   	push   %ecx
  801c3d:	52                   	push   %edx
  801c3e:	53                   	push   %ebx
  801c3f:	54                   	push   %esp
  801c40:	55                   	push   %ebp
  801c41:	56                   	push   %esi
  801c42:	57                   	push   %edi
  801c43:	54                   	push   %esp
  801c44:	5d                   	pop    %ebp
  801c45:	8d 35 4d 1c 80 00    	lea    0x801c4d,%esi
  801c4b:	0f 34                	sysenter 
  801c4d:	5f                   	pop    %edi
  801c4e:	5e                   	pop    %esi
  801c4f:	5d                   	pop    %ebp
  801c50:	5c                   	pop    %esp
  801c51:	5b                   	pop    %ebx
  801c52:	5a                   	pop    %edx
  801c53:	59                   	pop    %ecx
                   "d" (a1),
                   "c" (a2),
                   "b" (a3),
                   "D" (a4)
                 : "cc", "memory");
	if(check && ret > 0)
  801c54:	85 c0                	test   %eax,%eax
  801c56:	7e 28                	jle    801c80 <sys_page_unmap+0x62>
		panic("syscall %d returned %d (> 0)", num, ret);
  801c58:	89 44 24 10          	mov    %eax,0x10(%esp)
  801c5c:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  801c63:	00 
  801c64:	c7 44 24 08 80 2a 81 	movl   $0x812a80,0x8(%esp)
  801c6b:	00 
  801c6c:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  801c73:	00 
  801c74:	c7 04 24 9d 2a 81 00 	movl   $0x812a9d,(%esp)
  801c7b:	e8 68 ed ff ff       	call   8009e8 <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  801c80:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  801c83:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801c86:	89 ec                	mov    %ebp,%esp
  801c88:	5d                   	pop    %ebp
  801c89:	c3                   	ret    

00801c8a <sys_page_map>:
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  801c8a:	55                   	push   %ebp
  801c8b:	89 e5                	mov    %esp,%ebp
  801c8d:	83 ec 28             	sub    $0x28,%esp
  801c90:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  801c93:	89 7d fc             	mov    %edi,-0x4(%ebp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801c96:	8b 7d 18             	mov    0x18(%ebp),%edi
  801c99:	0b 7d 14             	or     0x14(%ebp),%edi
  801c9c:	b8 06 00 00 00       	mov    $0x6,%eax
  801ca1:	8b 5d 10             	mov    0x10(%ebp),%ebx
  801ca4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801ca7:	8b 55 08             	mov    0x8(%ebp),%edx
  801caa:	51                   	push   %ecx
  801cab:	52                   	push   %edx
  801cac:	53                   	push   %ebx
  801cad:	54                   	push   %esp
  801cae:	55                   	push   %ebp
  801caf:	56                   	push   %esi
  801cb0:	57                   	push   %edi
  801cb1:	54                   	push   %esp
  801cb2:	5d                   	pop    %ebp
  801cb3:	8d 35 bb 1c 80 00    	lea    0x801cbb,%esi
  801cb9:	0f 34                	sysenter 
  801cbb:	5f                   	pop    %edi
  801cbc:	5e                   	pop    %esi
  801cbd:	5d                   	pop    %ebp
  801cbe:	5c                   	pop    %esp
  801cbf:	5b                   	pop    %ebx
  801cc0:	5a                   	pop    %edx
  801cc1:	59                   	pop    %ecx
                   "d" (a1),
                   "c" (a2),
                   "b" (a3),
                   "D" (a4)
                 : "cc", "memory");
	if(check && ret > 0)
  801cc2:	85 c0                	test   %eax,%eax
  801cc4:	7e 28                	jle    801cee <sys_page_map+0x64>
		panic("syscall %d returned %d (> 0)", num, ret);
  801cc6:	89 44 24 10          	mov    %eax,0x10(%esp)
  801cca:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  801cd1:	00 
  801cd2:	c7 44 24 08 80 2a 81 	movl   $0x812a80,0x8(%esp)
  801cd9:	00 
  801cda:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  801ce1:	00 
  801ce2:	c7 04 24 9d 2a 81 00 	movl   $0x812a9d,(%esp)
  801ce9:	e8 fa ec ff ff       	call   8009e8 <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, ((uint32_t) dstva)|perm, perm);
}
  801cee:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  801cf1:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801cf4:	89 ec                	mov    %ebp,%esp
  801cf6:	5d                   	pop    %ebp
  801cf7:	c3                   	ret    

00801cf8 <sys_page_alloc>:
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  801cf8:	55                   	push   %ebp
  801cf9:	89 e5                	mov    %esp,%ebp
  801cfb:	83 ec 28             	sub    $0x28,%esp
  801cfe:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  801d01:	89 7d fc             	mov    %edi,-0x4(%ebp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801d04:	bf 00 00 00 00       	mov    $0x0,%edi
  801d09:	b8 05 00 00 00       	mov    $0x5,%eax
  801d0e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  801d11:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801d14:	8b 55 08             	mov    0x8(%ebp),%edx
  801d17:	51                   	push   %ecx
  801d18:	52                   	push   %edx
  801d19:	53                   	push   %ebx
  801d1a:	54                   	push   %esp
  801d1b:	55                   	push   %ebp
  801d1c:	56                   	push   %esi
  801d1d:	57                   	push   %edi
  801d1e:	54                   	push   %esp
  801d1f:	5d                   	pop    %ebp
  801d20:	8d 35 28 1d 80 00    	lea    0x801d28,%esi
  801d26:	0f 34                	sysenter 
  801d28:	5f                   	pop    %edi
  801d29:	5e                   	pop    %esi
  801d2a:	5d                   	pop    %ebp
  801d2b:	5c                   	pop    %esp
  801d2c:	5b                   	pop    %ebx
  801d2d:	5a                   	pop    %edx
  801d2e:	59                   	pop    %ecx
                   "d" (a1),
                   "c" (a2),
                   "b" (a3),
                   "D" (a4)
                 : "cc", "memory");
	if(check && ret > 0)
  801d2f:	85 c0                	test   %eax,%eax
  801d31:	7e 28                	jle    801d5b <sys_page_alloc+0x63>
		panic("syscall %d returned %d (> 0)", num, ret);
  801d33:	89 44 24 10          	mov    %eax,0x10(%esp)
  801d37:	c7 44 24 0c 05 00 00 	movl   $0x5,0xc(%esp)
  801d3e:	00 
  801d3f:	c7 44 24 08 80 2a 81 	movl   $0x812a80,0x8(%esp)
  801d46:	00 
  801d47:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  801d4e:	00 
  801d4f:	c7 04 24 9d 2a 81 00 	movl   $0x812a9d,(%esp)
  801d56:	e8 8d ec ff ff       	call   8009e8 <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  801d5b:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  801d5e:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801d61:	89 ec                	mov    %ebp,%esp
  801d63:	5d                   	pop    %ebp
  801d64:	c3                   	ret    

00801d65 <sys_yield>:
	 return syscall(SYS_map_kernel_page, 0, (uint32_t)kpage, (uint32_t)va, 0, 0, 0);
}

void
sys_yield(void)
{
  801d65:	55                   	push   %ebp
  801d66:	89 e5                	mov    %esp,%ebp
  801d68:	83 ec 08             	sub    $0x8,%esp
  801d6b:	89 1c 24             	mov    %ebx,(%esp)
  801d6e:	89 7c 24 04          	mov    %edi,0x4(%esp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801d72:	ba 00 00 00 00       	mov    $0x0,%edx
  801d77:	b8 0c 00 00 00       	mov    $0xc,%eax
  801d7c:	89 d1                	mov    %edx,%ecx
  801d7e:	89 d3                	mov    %edx,%ebx
  801d80:	89 d7                	mov    %edx,%edi
  801d82:	51                   	push   %ecx
  801d83:	52                   	push   %edx
  801d84:	53                   	push   %ebx
  801d85:	54                   	push   %esp
  801d86:	55                   	push   %ebp
  801d87:	56                   	push   %esi
  801d88:	57                   	push   %edi
  801d89:	54                   	push   %esp
  801d8a:	5d                   	pop    %ebp
  801d8b:	8d 35 93 1d 80 00    	lea    0x801d93,%esi
  801d91:	0f 34                	sysenter 
  801d93:	5f                   	pop    %edi
  801d94:	5e                   	pop    %esi
  801d95:	5d                   	pop    %ebp
  801d96:	5c                   	pop    %esp
  801d97:	5b                   	pop    %ebx
  801d98:	5a                   	pop    %edx
  801d99:	59                   	pop    %ecx

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  801d9a:	8b 1c 24             	mov    (%esp),%ebx
  801d9d:	8b 7c 24 04          	mov    0x4(%esp),%edi
  801da1:	89 ec                	mov    %ebp,%esp
  801da3:	5d                   	pop    %ebp
  801da4:	c3                   	ret    

00801da5 <sys_map_kernel_page>:
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}

int
sys_map_kernel_page(void* kpage, void* va)
{
  801da5:	55                   	push   %ebp
  801da6:	89 e5                	mov    %esp,%ebp
  801da8:	83 ec 08             	sub    $0x8,%esp
  801dab:	89 1c 24             	mov    %ebx,(%esp)
  801dae:	89 7c 24 04          	mov    %edi,0x4(%esp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801db2:	bb 00 00 00 00       	mov    $0x0,%ebx
  801db7:	b8 04 00 00 00       	mov    $0x4,%eax
  801dbc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801dbf:	8b 55 08             	mov    0x8(%ebp),%edx
  801dc2:	89 df                	mov    %ebx,%edi
  801dc4:	51                   	push   %ecx
  801dc5:	52                   	push   %edx
  801dc6:	53                   	push   %ebx
  801dc7:	54                   	push   %esp
  801dc8:	55                   	push   %ebp
  801dc9:	56                   	push   %esi
  801dca:	57                   	push   %edi
  801dcb:	54                   	push   %esp
  801dcc:	5d                   	pop    %ebp
  801dcd:	8d 35 d5 1d 80 00    	lea    0x801dd5,%esi
  801dd3:	0f 34                	sysenter 
  801dd5:	5f                   	pop    %edi
  801dd6:	5e                   	pop    %esi
  801dd7:	5d                   	pop    %ebp
  801dd8:	5c                   	pop    %esp
  801dd9:	5b                   	pop    %ebx
  801dda:	5a                   	pop    %edx
  801ddb:	59                   	pop    %ecx

int
sys_map_kernel_page(void* kpage, void* va)
{
	 return syscall(SYS_map_kernel_page, 0, (uint32_t)kpage, (uint32_t)va, 0, 0, 0);
}
  801ddc:	8b 1c 24             	mov    (%esp),%ebx
  801ddf:	8b 7c 24 04          	mov    0x4(%esp),%edi
  801de3:	89 ec                	mov    %ebp,%esp
  801de5:	5d                   	pop    %ebp
  801de6:	c3                   	ret    

00801de7 <sys_getenvid>:
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}

envid_t
sys_getenvid(void)
{
  801de7:	55                   	push   %ebp
  801de8:	89 e5                	mov    %esp,%ebp
  801dea:	83 ec 08             	sub    $0x8,%esp
  801ded:	89 1c 24             	mov    %ebx,(%esp)
  801df0:	89 7c 24 04          	mov    %edi,0x4(%esp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801df4:	ba 00 00 00 00       	mov    $0x0,%edx
  801df9:	b8 02 00 00 00       	mov    $0x2,%eax
  801dfe:	89 d1                	mov    %edx,%ecx
  801e00:	89 d3                	mov    %edx,%ebx
  801e02:	89 d7                	mov    %edx,%edi
  801e04:	51                   	push   %ecx
  801e05:	52                   	push   %edx
  801e06:	53                   	push   %ebx
  801e07:	54                   	push   %esp
  801e08:	55                   	push   %ebp
  801e09:	56                   	push   %esi
  801e0a:	57                   	push   %edi
  801e0b:	54                   	push   %esp
  801e0c:	5d                   	pop    %ebp
  801e0d:	8d 35 15 1e 80 00    	lea    0x801e15,%esi
  801e13:	0f 34                	sysenter 
  801e15:	5f                   	pop    %edi
  801e16:	5e                   	pop    %esi
  801e17:	5d                   	pop    %ebp
  801e18:	5c                   	pop    %esp
  801e19:	5b                   	pop    %ebx
  801e1a:	5a                   	pop    %edx
  801e1b:	59                   	pop    %ecx

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  801e1c:	8b 1c 24             	mov    (%esp),%ebx
  801e1f:	8b 7c 24 04          	mov    0x4(%esp),%edi
  801e23:	89 ec                	mov    %ebp,%esp
  801e25:	5d                   	pop    %ebp
  801e26:	c3                   	ret    

00801e27 <sys_env_destroy>:
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}

int
sys_env_destroy(envid_t envid)
{
  801e27:	55                   	push   %ebp
  801e28:	89 e5                	mov    %esp,%ebp
  801e2a:	83 ec 28             	sub    $0x28,%esp
  801e2d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  801e30:	89 7d fc             	mov    %edi,-0x4(%ebp)

static inline int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801e33:	b9 00 00 00 00       	mov    $0x0,%ecx
  801e38:	b8 03 00 00 00       	mov    $0x3,%eax
  801e3d:	8b 55 08             	mov    0x8(%ebp),%edx
  801e40:	89 cb                	mov    %ecx,%ebx
  801e42:	89 cf                	mov    %ecx,%edi
  801e44:	51                   	push   %ecx
  801e45:	52                   	push   %edx
  801e46:	53                   	push   %ebx
  801e47:	54                   	push   %esp
  801e48:	55                   	push   %ebp
  801e49:	56                   	push   %esi
  801e4a:	57                   	push   %edi
  801e4b:	54                   	push   %esp
  801e4c:	5d                   	pop    %ebp
  801e4d:	8d 35 55 1e 80 00    	lea    0x801e55,%esi
  801e53:	0f 34                	sysenter 
  801e55:	5f                   	pop    %edi
  801e56:	5e                   	pop    %esi
  801e57:	5d                   	pop    %ebp
  801e58:	5c                   	pop    %esp
  801e59:	5b                   	pop    %ebx
  801e5a:	5a                   	pop    %edx
  801e5b:	59                   	pop    %ecx
                   "d" (a1),
                   "c" (a2),
                   "b" (a3),
                   "D" (a4)
                 : "cc", "memory");
	if(check && ret > 0)
  801e5c:	85 c0                	test   %eax,%eax
  801e5e:	7e 28                	jle    801e88 <sys_env_destroy+0x61>
		panic("syscall %d returned %d (> 0)", num, ret);
  801e60:	89 44 24 10          	mov    %eax,0x10(%esp)
  801e64:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
  801e6b:	00 
  801e6c:	c7 44 24 08 80 2a 81 	movl   $0x812a80,0x8(%esp)
  801e73:	00 
  801e74:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  801e7b:	00 
  801e7c:	c7 04 24 9d 2a 81 00 	movl   $0x812a9d,(%esp)
  801e83:	e8 60 eb ff ff       	call   8009e8 <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  801e88:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  801e8b:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801e8e:	89 ec                	mov    %ebp,%esp
  801e90:	5d                   	pop    %ebp
  801e91:	c3                   	ret    
	...

00801e94 <sfork>:
}

// Challenge!
int
sfork(void)
{
  801e94:	55                   	push   %ebp
  801e95:	89 e5                	mov    %esp,%ebp
  801e97:	83 ec 18             	sub    $0x18,%esp
	panic("sfork not implemented");
  801e9a:	c7 44 24 08 ab 2a 81 	movl   $0x812aab,0x8(%esp)
  801ea1:	00 
  801ea2:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  801ea9:	00 
  801eaa:	c7 04 24 c1 2a 81 00 	movl   $0x812ac1,(%esp)
  801eb1:	e8 32 eb ff ff       	call   8009e8 <_panic>

00801eb6 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  801eb6:	55                   	push   %ebp
  801eb7:	89 e5                	mov    %esp,%ebp
  801eb9:	57                   	push   %edi
  801eba:	56                   	push   %esi
  801ebb:	53                   	push   %ebx
  801ebc:	83 ec 3c             	sub    $0x3c,%esp
	// LAB 4: Your code here.
        set_pgfault_handler(pgfault);
  801ebf:	c7 04 24 0b 21 80 00 	movl   $0x80210b,(%esp)
  801ec6:	e8 41 15 00 00       	call   80340c <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  801ecb:	ba 08 00 00 00       	mov    $0x8,%edx
  801ed0:	89 d0                	mov    %edx,%eax
  801ed2:	cd 30                	int    $0x30
  801ed4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        envid_t envid = sys_exofork();
        uint32_t addr;
        extern void _pgfault_upcall();
        int r = 0;
        if (envid < 0)
  801ed7:	85 c0                	test   %eax,%eax
  801ed9:	79 20                	jns    801efb <fork+0x45>
		panic("sys_exofork: %e", envid);
  801edb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801edf:	c7 44 24 08 cc 2a 81 	movl   $0x812acc,0x8(%esp)
  801ee6:	00 
  801ee7:	c7 44 24 04 74 00 00 	movl   $0x74,0x4(%esp)
  801eee:	00 
  801eef:	c7 04 24 c1 2a 81 00 	movl   $0x812ac1,(%esp)
  801ef6:	e8 ed ea ff ff       	call   8009e8 <_panic>
	if (envid == 0) {
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
  801efb:	bb 00 00 00 00       	mov    $0x0,%ebx
	}
        for(addr = 0; addr < USTACKTOP; addr += PGSIZE){
           if((vpd[PDX(addr)] & PTE_P) && (vpt[PGNUM(addr)] & PTE_P) && (vpt[PGNUM(addr)] & PTE_U))
  801f00:	be 00 d0 7b ef       	mov    $0xef7bd000,%esi
  801f05:	bf 00 00 40 ef       	mov    $0xef400000,%edi
        uint32_t addr;
        extern void _pgfault_upcall();
        int r = 0;
        if (envid < 0)
		panic("sys_exofork: %e", envid);
	if (envid == 0) {
  801f0a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  801f0e:	75 20                	jne    801f30 <fork+0x7a>
		thisenv = &envs[ENVX(sys_getenvid())];
  801f10:	e8 d2 fe ff ff       	call   801de7 <sys_getenvid>
  801f15:	25 ff 03 00 00       	and    $0x3ff,%eax
  801f1a:	89 c2                	mov    %eax,%edx
  801f1c:	c1 e2 07             	shl    $0x7,%edx
  801f1f:	8d 84 82 00 00 c0 ee 	lea    -0x11400000(%edx,%eax,4),%eax
  801f26:	a3 78 c2 b3 00       	mov    %eax,0xb3c278
		return 0;
  801f2b:	e9 d0 01 00 00       	jmp    802100 <fork+0x24a>
	}
        for(addr = 0; addr < USTACKTOP; addr += PGSIZE){
           if((vpd[PDX(addr)] & PTE_P) && (vpt[PGNUM(addr)] & PTE_P) && (vpt[PGNUM(addr)] & PTE_U))
  801f30:	89 d8                	mov    %ebx,%eax
  801f32:	c1 e8 16             	shr    $0x16,%eax
  801f35:	8b 04 86             	mov    (%esi,%eax,4),%eax
  801f38:	a8 01                	test   $0x1,%al
  801f3a:	0f 84 0d 01 00 00    	je     80204d <fork+0x197>
  801f40:	89 d8                	mov    %ebx,%eax
  801f42:	c1 e8 0c             	shr    $0xc,%eax
  801f45:	8b 14 87             	mov    (%edi,%eax,4),%edx
  801f48:	f6 c2 01             	test   $0x1,%dl
  801f4b:	0f 84 fc 00 00 00    	je     80204d <fork+0x197>
  801f51:	8b 14 87             	mov    (%edi,%eax,4),%edx
  801f54:	f6 c2 04             	test   $0x4,%dl
  801f57:	0f 84 f0 00 00 00    	je     80204d <fork+0x197>
duppage(envid_t envid, unsigned pn)
{
	int r;
        
	// LAB 4: Your code here.
        uint32_t addr = pn*PGSIZE;
  801f5d:	c1 e0 0c             	shl    $0xc,%eax
        pte_t pte = vpt[PGNUM(addr)];
  801f60:	89 c2                	mov    %eax,%edx
  801f62:	c1 ea 0c             	shr    $0xc,%edx
  801f65:	8b 14 97             	mov    (%edi,%edx,4),%edx
        if(pte & PTE_P){
  801f68:	f6 c2 01             	test   $0x1,%dl
  801f6b:	0f 84 dc 00 00 00    	je     80204d <fork+0x197>
          if((pte & PTE_W)|| (pte & PTE_COW)){
  801f71:	f7 c2 02 08 00 00    	test   $0x802,%edx
  801f77:	0f 84 8d 00 00 00    	je     80200a <fork+0x154>
               r = sys_page_map(0,(void*)addr,envid,(void*)addr,PTE_P|PTE_U|PTE_COW);
  801f7d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801f80:	c7 44 24 10 05 08 00 	movl   $0x805,0x10(%esp)
  801f87:	00 
  801f88:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801f8c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  801f8f:	89 54 24 08          	mov    %edx,0x8(%esp)
  801f93:	89 44 24 04          	mov    %eax,0x4(%esp)
  801f97:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801f9e:	e8 e7 fc ff ff       	call   801c8a <sys_page_map>
               if(r<0)
  801fa3:	85 c0                	test   %eax,%eax
  801fa5:	79 1c                	jns    801fc3 <fork+0x10d>
                 panic("map failed");
  801fa7:	c7 44 24 08 dc 2a 81 	movl   $0x812adc,0x8(%esp)
  801fae:	00 
  801faf:	c7 44 24 04 49 00 00 	movl   $0x49,0x4(%esp)
  801fb6:	00 
  801fb7:	c7 04 24 c1 2a 81 00 	movl   $0x812ac1,(%esp)
  801fbe:	e8 25 ea ff ff       	call   8009e8 <_panic>
               r = sys_page_map(0,(void*)addr,0,(void*)addr,PTE_P|PTE_U|PTE_COW);    //mark itself COW as well
  801fc3:	c7 44 24 10 05 08 00 	movl   $0x805,0x10(%esp)
  801fca:	00 
  801fcb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801fce:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801fd2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801fd9:	00 
  801fda:	89 44 24 04          	mov    %eax,0x4(%esp)
  801fde:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801fe5:	e8 a0 fc ff ff       	call   801c8a <sys_page_map>
               if(r<0)
  801fea:	85 c0                	test   %eax,%eax
  801fec:	79 5f                	jns    80204d <fork+0x197>
                 panic("map failed");
  801fee:	c7 44 24 08 dc 2a 81 	movl   $0x812adc,0x8(%esp)
  801ff5:	00 
  801ff6:	c7 44 24 04 4c 00 00 	movl   $0x4c,0x4(%esp)
  801ffd:	00 
  801ffe:	c7 04 24 c1 2a 81 00 	movl   $0x812ac1,(%esp)
  802005:	e8 de e9 ff ff       	call   8009e8 <_panic>
          }
          else{
               r = sys_page_map(0,(void*)addr,envid,(void*)addr,PTE_P|PTE_U);
  80200a:	c7 44 24 10 05 00 00 	movl   $0x5,0x10(%esp)
  802011:	00 
  802012:	89 44 24 0c          	mov    %eax,0xc(%esp)
  802016:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  802019:	89 54 24 08          	mov    %edx,0x8(%esp)
  80201d:	89 44 24 04          	mov    %eax,0x4(%esp)
  802021:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802028:	e8 5d fc ff ff       	call   801c8a <sys_page_map>
               if(r<0)
  80202d:	85 c0                	test   %eax,%eax
  80202f:	79 1c                	jns    80204d <fork+0x197>
                 panic("map failed");
  802031:	c7 44 24 08 dc 2a 81 	movl   $0x812adc,0x8(%esp)
  802038:	00 
  802039:	c7 44 24 04 51 00 00 	movl   $0x51,0x4(%esp)
  802040:	00 
  802041:	c7 04 24 c1 2a 81 00 	movl   $0x812ac1,(%esp)
  802048:	e8 9b e9 ff ff       	call   8009e8 <_panic>
		panic("sys_exofork: %e", envid);
	if (envid == 0) {
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
        for(addr = 0; addr < USTACKTOP; addr += PGSIZE){
  80204d:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  802053:	81 fb 00 e0 bf ee    	cmp    $0xeebfe000,%ebx
  802059:	0f 85 d1 fe ff ff    	jne    801f30 <fork+0x7a>
           if((vpd[PDX(addr)] & PTE_P) && (vpt[PGNUM(addr)] & PTE_P) && (vpt[PGNUM(addr)] & PTE_U))
              duppage(envid,PGNUM(addr));
        }
        r = sys_page_alloc(envid, (void*)(UXSTACKTOP-PGSIZE),PTE_P|PTE_U|PTE_W);
  80205f:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  802066:	00 
  802067:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  80206e:	ee 
  80206f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802072:	89 04 24             	mov    %eax,(%esp)
  802075:	e8 7e fc ff ff       	call   801cf8 <sys_page_alloc>
        if(r < 0)
  80207a:	85 c0                	test   %eax,%eax
  80207c:	79 1c                	jns    80209a <fork+0x1e4>
            panic("alloc failed");
  80207e:	c7 44 24 08 e7 2a 81 	movl   $0x812ae7,0x8(%esp)
  802085:	00 
  802086:	c7 44 24 04 7f 00 00 	movl   $0x7f,0x4(%esp)
  80208d:	00 
  80208e:	c7 04 24 c1 2a 81 00 	movl   $0x812ac1,(%esp)
  802095:	e8 4e e9 ff ff       	call   8009e8 <_panic>
        r = sys_env_set_pgfault_upcall(envid, _pgfault_upcall);
  80209a:	c7 44 24 04 58 34 80 	movl   $0x803458,0x4(%esp)
  8020a1:	00 
  8020a2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8020a5:	89 14 24             	mov    %edx,(%esp)
  8020a8:	e8 2d fa ff ff       	call   801ada <sys_env_set_pgfault_upcall>
        if(r < 0)
  8020ad:	85 c0                	test   %eax,%eax
  8020af:	79 1c                	jns    8020cd <fork+0x217>
            panic("set pgfault upcall failed");
  8020b1:	c7 44 24 08 f4 2a 81 	movl   $0x812af4,0x8(%esp)
  8020b8:	00 
  8020b9:	c7 44 24 04 82 00 00 	movl   $0x82,0x4(%esp)
  8020c0:	00 
  8020c1:	c7 04 24 c1 2a 81 00 	movl   $0x812ac1,(%esp)
  8020c8:	e8 1b e9 ff ff       	call   8009e8 <_panic>
        r = sys_env_set_status(envid, ENV_RUNNABLE);
  8020cd:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  8020d4:	00 
  8020d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8020d8:	89 04 24             	mov    %eax,(%esp)
  8020db:	e8 d2 fa ff ff       	call   801bb2 <sys_env_set_status>
        if(r < 0)
  8020e0:	85 c0                	test   %eax,%eax
  8020e2:	79 1c                	jns    802100 <fork+0x24a>
            panic("set status failed");
  8020e4:	c7 44 24 08 0e 2b 81 	movl   $0x812b0e,0x8(%esp)
  8020eb:	00 
  8020ec:	c7 44 24 04 85 00 00 	movl   $0x85,0x4(%esp)
  8020f3:	00 
  8020f4:	c7 04 24 c1 2a 81 00 	movl   $0x812ac1,(%esp)
  8020fb:	e8 e8 e8 ff ff       	call   8009e8 <_panic>
        return envid;
	//panic("fork not implemented");
}
  802100:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802103:	83 c4 3c             	add    $0x3c,%esp
  802106:	5b                   	pop    %ebx
  802107:	5e                   	pop    %esi
  802108:	5f                   	pop    %edi
  802109:	5d                   	pop    %ebp
  80210a:	c3                   	ret    

0080210b <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80210b:	55                   	push   %ebp
  80210c:	89 e5                	mov    %esp,%ebp
  80210e:	53                   	push   %ebx
  80210f:	83 ec 24             	sub    $0x24,%esp
  802112:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  802115:	8b 18                	mov    (%eax),%ebx
	// Hint:
	//   Use the read-only page table mappings at vpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
        pte_t pte = vpt[PGNUM(addr)];
  802117:	89 da                	mov    %ebx,%edx
  802119:	c1 ea 0c             	shr    $0xc,%edx
  80211c:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
//
static void
pgfault(struct UTrapframe *utf)
{
	void *addr = (void *) utf->utf_fault_va;
	uint32_t err = utf->utf_err;
  802123:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  802127:	74 08                	je     802131 <pgfault+0x26>
	//   Use the read-only page table mappings at vpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
        pte_t pte = vpt[PGNUM(addr)];
        if((!(err & FEC_WR)) ||(!(pte & (PTE_P | PTE_U |PTE_COW))))
  802129:	f7 c2 05 08 00 00    	test   $0x805,%edx
  80212f:	75 1c                	jne    80214d <pgfault+0x42>
           panic("pgfault error");
  802131:	c7 44 24 08 20 2b 81 	movl   $0x812b20,0x8(%esp)
  802138:	00 
  802139:	c7 44 24 04 1e 00 00 	movl   $0x1e,0x4(%esp)
  802140:	00 
  802141:	c7 04 24 c1 2a 81 00 	movl   $0x812ac1,(%esp)
  802148:	e8 9b e8 ff ff       	call   8009e8 <_panic>
	// Hint:
	//   You should make three system calls.
	//   No need to explicitly delete the old page's mapping.

	// LAB 4: Your code here.
        if ((r = sys_page_alloc(0, (void*)PFTEMP, PTE_P|PTE_U|PTE_W)) < 0)
  80214d:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  802154:	00 
  802155:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  80215c:	00 
  80215d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802164:	e8 8f fb ff ff       	call   801cf8 <sys_page_alloc>
  802169:	85 c0                	test   %eax,%eax
  80216b:	79 20                	jns    80218d <pgfault+0x82>
		panic("sys_page_alloc: %e", r);
  80216d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  802171:	c7 44 24 08 2e 2b 81 	movl   $0x812b2e,0x8(%esp)
  802178:	00 
  802179:	c7 44 24 04 29 00 00 	movl   $0x29,0x4(%esp)
  802180:	00 
  802181:	c7 04 24 c1 2a 81 00 	movl   $0x812ac1,(%esp)
  802188:	e8 5b e8 ff ff       	call   8009e8 <_panic>
        memmove(PFTEMP, (void*)((PGNUM(addr))<< PTXSHIFT), PGSIZE);
  80218d:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  802193:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  80219a:	00 
  80219b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80219f:	c7 04 24 00 f0 7f 00 	movl   $0x7ff000,(%esp)
  8021a6:	e8 0a f4 ff ff       	call   8015b5 <memmove>
	if ((r = sys_page_map(0, (void*)PFTEMP, 0, (void*)((PGNUM(addr))<< PTXSHIFT), PTE_P|PTE_U|PTE_W)) < 0)
  8021ab:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  8021b2:	00 
  8021b3:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  8021b7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8021be:	00 
  8021bf:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  8021c6:	00 
  8021c7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8021ce:	e8 b7 fa ff ff       	call   801c8a <sys_page_map>
  8021d3:	85 c0                	test   %eax,%eax
  8021d5:	79 20                	jns    8021f7 <pgfault+0xec>
		panic("sys_page_map: %e", r);	
  8021d7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8021db:	c7 44 24 08 41 2b 81 	movl   $0x812b41,0x8(%esp)
  8021e2:	00 
  8021e3:	c7 44 24 04 2c 00 00 	movl   $0x2c,0x4(%esp)
  8021ea:	00 
  8021eb:	c7 04 24 c1 2a 81 00 	movl   $0x812ac1,(%esp)
  8021f2:	e8 f1 e7 ff ff       	call   8009e8 <_panic>
        if ((r = sys_page_unmap(0, PFTEMP)) < 0)
  8021f7:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  8021fe:	00 
  8021ff:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802206:	e8 13 fa ff ff       	call   801c1e <sys_page_unmap>
  80220b:	85 c0                	test   %eax,%eax
  80220d:	79 20                	jns    80222f <pgfault+0x124>
		panic("sys_page_unmap: %e", r);
  80220f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  802213:	c7 44 24 08 52 2b 81 	movl   $0x812b52,0x8(%esp)
  80221a:	00 
  80221b:	c7 44 24 04 2e 00 00 	movl   $0x2e,0x4(%esp)
  802222:	00 
  802223:	c7 04 24 c1 2a 81 00 	movl   $0x812ac1,(%esp)
  80222a:	e8 b9 e7 ff ff       	call   8009e8 <_panic>
	//panic("pgfault not implemented");
}
  80222f:	83 c4 24             	add    $0x24,%esp
  802232:	5b                   	pop    %ebx
  802233:	5d                   	pop    %ebp
  802234:	c3                   	ret    
	...

00802240 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  802240:	55                   	push   %ebp
  802241:	89 e5                	mov    %esp,%ebp
  802243:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
		if (envs[i].env_type == type)
  802246:	8b 15 50 00 c0 ee    	mov    0xeec00050,%edx
  80224c:	b8 01 00 00 00       	mov    $0x1,%eax
  802251:	39 ca                	cmp    %ecx,%edx
  802253:	75 04                	jne    802259 <ipc_find_env+0x19>
  802255:	b0 00                	mov    $0x0,%al
  802257:	eb 12                	jmp    80226b <ipc_find_env+0x2b>
  802259:	89 c2                	mov    %eax,%edx
  80225b:	c1 e2 07             	shl    $0x7,%edx
  80225e:	8d 94 82 50 00 c0 ee 	lea    -0x113fffb0(%edx,%eax,4),%edx
  802265:	8b 12                	mov    (%edx),%edx
  802267:	39 ca                	cmp    %ecx,%edx
  802269:	75 10                	jne    80227b <ipc_find_env+0x3b>
			return envs[i].env_id;
  80226b:	89 c2                	mov    %eax,%edx
  80226d:	c1 e2 07             	shl    $0x7,%edx
  802270:	8d 84 82 48 00 c0 ee 	lea    -0x113fffb8(%edx,%eax,4),%eax
  802277:	8b 00                	mov    (%eax),%eax
  802279:	eb 0e                	jmp    802289 <ipc_find_env+0x49>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  80227b:	83 c0 01             	add    $0x1,%eax
  80227e:	3d 00 04 00 00       	cmp    $0x400,%eax
  802283:	75 d4                	jne    802259 <ipc_find_env+0x19>
  802285:	66 b8 00 00          	mov    $0x0,%ax
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
}
  802289:	5d                   	pop    %ebp
  80228a:	c3                   	ret    

0080228b <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  80228b:	55                   	push   %ebp
  80228c:	89 e5                	mov    %esp,%ebp
  80228e:	57                   	push   %edi
  80228f:	56                   	push   %esi
  802290:	53                   	push   %ebx
  802291:	83 ec 1c             	sub    $0x1c,%esp
  802294:	8b 75 08             	mov    0x8(%ebp),%esi
  802297:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80229a:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
        int ret;
        while(1){
           if(pg)
  80229d:	85 db                	test   %ebx,%ebx
  80229f:	74 19                	je     8022ba <ipc_send+0x2f>
              ret = sys_ipc_try_send(to_env,val,pg,perm);
  8022a1:	8b 45 14             	mov    0x14(%ebp),%eax
  8022a4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8022a8:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8022ac:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8022b0:	89 34 24             	mov    %esi,(%esp)
  8022b3:	e8 e1 f7 ff ff       	call   801a99 <sys_ipc_try_send>
  8022b8:	eb 1b                	jmp    8022d5 <ipc_send+0x4a>
           else
              ret = sys_ipc_try_send(to_env,val,(void*)UTOP,perm);
  8022ba:	8b 45 14             	mov    0x14(%ebp),%eax
  8022bd:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8022c1:	c7 44 24 08 00 00 c0 	movl   $0xeec00000,0x8(%esp)
  8022c8:	ee 
  8022c9:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8022cd:	89 34 24             	mov    %esi,(%esp)
  8022d0:	e8 c4 f7 ff ff       	call   801a99 <sys_ipc_try_send>
           if(ret == 0)
  8022d5:	85 c0                	test   %eax,%eax
  8022d7:	74 28                	je     802301 <ipc_send+0x76>
              return;
           if(ret != -E_IPC_NOT_RECV)
  8022d9:	83 f8 f9             	cmp    $0xfffffff9,%eax
  8022dc:	74 1c                	je     8022fa <ipc_send+0x6f>
              panic("ipc send error");
  8022de:	c7 44 24 08 65 2b 81 	movl   $0x812b65,0x8(%esp)
  8022e5:	00 
  8022e6:	c7 44 24 04 46 00 00 	movl   $0x46,0x4(%esp)
  8022ed:	00 
  8022ee:	c7 04 24 74 2b 81 00 	movl   $0x812b74,(%esp)
  8022f5:	e8 ee e6 ff ff       	call   8009e8 <_panic>
           sys_yield();
  8022fa:	e8 66 fa ff ff       	call   801d65 <sys_yield>
        }
  8022ff:	eb 9c                	jmp    80229d <ipc_send+0x12>
	//panic("ipc_send not implemented");
}
  802301:	83 c4 1c             	add    $0x1c,%esp
  802304:	5b                   	pop    %ebx
  802305:	5e                   	pop    %esi
  802306:	5f                   	pop    %edi
  802307:	5d                   	pop    %ebp
  802308:	c3                   	ret    

00802309 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  802309:	55                   	push   %ebp
  80230a:	89 e5                	mov    %esp,%ebp
  80230c:	56                   	push   %esi
  80230d:	53                   	push   %ebx
  80230e:	83 ec 10             	sub    $0x10,%esp
  802311:	8b 75 08             	mov    0x8(%ebp),%esi
  802314:	8b 45 0c             	mov    0xc(%ebp),%eax
  802317:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
        int ret;
        if(!pg)
  80231a:	85 c0                	test   %eax,%eax
  80231c:	75 0e                	jne    80232c <ipc_recv+0x23>
           ret = sys_ipc_recv((void*)UTOP);
  80231e:	c7 04 24 00 00 c0 ee 	movl   $0xeec00000,(%esp)
  802325:	e8 04 f7 ff ff       	call   801a2e <sys_ipc_recv>
  80232a:	eb 08                	jmp    802334 <ipc_recv+0x2b>
        else
           ret = sys_ipc_recv(pg);
  80232c:	89 04 24             	mov    %eax,(%esp)
  80232f:	e8 fa f6 ff ff       	call   801a2e <sys_ipc_recv>
        if(ret == 0){
  802334:	85 c0                	test   %eax,%eax
  802336:	75 26                	jne    80235e <ipc_recv+0x55>
           if(from_env_store)
  802338:	85 f6                	test   %esi,%esi
  80233a:	74 0a                	je     802346 <ipc_recv+0x3d>
              *from_env_store = thisenv->env_ipc_from;
  80233c:	a1 78 c2 b3 00       	mov    0xb3c278,%eax
  802341:	8b 40 78             	mov    0x78(%eax),%eax
  802344:	89 06                	mov    %eax,(%esi)
           if(perm_store)
  802346:	85 db                	test   %ebx,%ebx
  802348:	74 0a                	je     802354 <ipc_recv+0x4b>
              *perm_store = thisenv->env_ipc_perm;
  80234a:	a1 78 c2 b3 00       	mov    0xb3c278,%eax
  80234f:	8b 40 7c             	mov    0x7c(%eax),%eax
  802352:	89 03                	mov    %eax,(%ebx)
           return thisenv->env_ipc_value;
  802354:	a1 78 c2 b3 00       	mov    0xb3c278,%eax
  802359:	8b 40 74             	mov    0x74(%eax),%eax
  80235c:	eb 14                	jmp    802372 <ipc_recv+0x69>
        }
        else{
           if(from_env_store)
  80235e:	85 f6                	test   %esi,%esi
  802360:	74 06                	je     802368 <ipc_recv+0x5f>
              *from_env_store = 0;
  802362:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
           if(perm_store)
  802368:	85 db                	test   %ebx,%ebx
  80236a:	74 06                	je     802372 <ipc_recv+0x69>
              *perm_store = 0;
  80236c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
           return ret;
        }
	//panic("ipc_recv not implemented");
	return 0;
}
  802372:	83 c4 10             	add    $0x10,%esp
  802375:	5b                   	pop    %ebx
  802376:	5e                   	pop    %esi
  802377:	5d                   	pop    %ebp
  802378:	c3                   	ret    
  802379:	00 00                	add    %al,(%eax)
  80237b:	00 00                	add    %al,(%eax)
  80237d:	00 00                	add    %al,(%eax)
	...

00802380 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  802380:	55                   	push   %ebp
  802381:	89 e5                	mov    %esp,%ebp
  802383:	8b 45 08             	mov    0x8(%ebp),%eax
  802386:	05 00 00 00 30       	add    $0x30000000,%eax
  80238b:	c1 e8 0c             	shr    $0xc,%eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
}
  80238e:	5d                   	pop    %ebp
  80238f:	c3                   	ret    

00802390 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  802390:	55                   	push   %ebp
  802391:	89 e5                	mov    %esp,%ebp
  802393:	83 ec 04             	sub    $0x4,%esp
	return INDEX2DATA(fd2num(fd));
  802396:	8b 45 08             	mov    0x8(%ebp),%eax
  802399:	89 04 24             	mov    %eax,(%esp)
  80239c:	e8 df ff ff ff       	call   802380 <fd2num>
  8023a1:	05 20 00 0d 00       	add    $0xd0020,%eax
  8023a6:	c1 e0 0c             	shl    $0xc,%eax
}
  8023a9:	c9                   	leave  
  8023aa:	c3                   	ret    

008023ab <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  8023ab:	55                   	push   %ebp
  8023ac:	89 e5                	mov    %esp,%ebp
  8023ae:	57                   	push   %edi
  8023af:	56                   	push   %esi
  8023b0:	53                   	push   %ebx
  8023b1:	8b 7d 08             	mov    0x8(%ebp),%edi
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((vpd[PDX(fd)] & PTE_P) == 0 || (vpt[PGNUM(fd)] & PTE_P) == 0) {
  8023b4:	a1 00 dd 7b ef       	mov    0xef7bdd00,%eax
  8023b9:	a8 01                	test   $0x1,%al
  8023bb:	74 36                	je     8023f3 <fd_alloc+0x48>
  8023bd:	a1 00 00 74 ef       	mov    0xef740000,%eax
  8023c2:	a8 01                	test   $0x1,%al
  8023c4:	74 2d                	je     8023f3 <fd_alloc+0x48>
  8023c6:	b8 00 10 00 d0       	mov    $0xd0001000,%eax
  8023cb:	b9 00 d0 7b ef       	mov    $0xef7bd000,%ecx
  8023d0:	be 00 00 40 ef       	mov    $0xef400000,%esi
  8023d5:	89 c3                	mov    %eax,%ebx
  8023d7:	89 c2                	mov    %eax,%edx
  8023d9:	c1 ea 16             	shr    $0x16,%edx
  8023dc:	8b 14 91             	mov    (%ecx,%edx,4),%edx
  8023df:	f6 c2 01             	test   $0x1,%dl
  8023e2:	74 14                	je     8023f8 <fd_alloc+0x4d>
  8023e4:	89 c2                	mov    %eax,%edx
  8023e6:	c1 ea 0c             	shr    $0xc,%edx
  8023e9:	8b 14 96             	mov    (%esi,%edx,4),%edx
  8023ec:	f6 c2 01             	test   $0x1,%dl
  8023ef:	75 10                	jne    802401 <fd_alloc+0x56>
  8023f1:	eb 05                	jmp    8023f8 <fd_alloc+0x4d>
  8023f3:	bb 00 00 00 d0       	mov    $0xd0000000,%ebx
			*fd_store = fd;
  8023f8:	89 1f                	mov    %ebx,(%edi)
  8023fa:	b8 00 00 00 00       	mov    $0x0,%eax
			return 0;
  8023ff:	eb 17                	jmp    802418 <fd_alloc+0x6d>
  802401:	05 00 10 00 00       	add    $0x1000,%eax
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  802406:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80240b:	75 c8                	jne    8023d5 <fd_alloc+0x2a>
		if ((vpd[PDX(fd)] & PTE_P) == 0 || (vpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80240d:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
  802413:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
	return -E_MAX_OPEN;
}
  802418:	5b                   	pop    %ebx
  802419:	5e                   	pop    %esi
  80241a:	5f                   	pop    %edi
  80241b:	5d                   	pop    %ebp
  80241c:	c3                   	ret    

0080241d <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80241d:	55                   	push   %ebp
  80241e:	89 e5                	mov    %esp,%ebp
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  802420:	8b 45 08             	mov    0x8(%ebp),%eax
  802423:	83 f8 1f             	cmp    $0x1f,%eax
  802426:	77 36                	ja     80245e <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fd);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  802428:	05 00 00 0d 00       	add    $0xd0000,%eax
  80242d:	c1 e0 0c             	shl    $0xc,%eax
	if (!(vpd[PDX(fd)] & PTE_P) || !(vpt[PGNUM(fd)] & PTE_P)) {
  802430:	89 c2                	mov    %eax,%edx
  802432:	c1 ea 16             	shr    $0x16,%edx
  802435:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80243c:	f6 c2 01             	test   $0x1,%dl
  80243f:	74 1d                	je     80245e <fd_lookup+0x41>
  802441:	89 c2                	mov    %eax,%edx
  802443:	c1 ea 0c             	shr    $0xc,%edx
  802446:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80244d:	f6 c2 01             	test   $0x1,%dl
  802450:	74 0c                	je     80245e <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fd);
		return -E_INVAL;
	}
	*fd_store = fd;
  802452:	8b 55 0c             	mov    0xc(%ebp),%edx
  802455:	89 02                	mov    %eax,(%edx)
  802457:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
  80245c:	eb 05                	jmp    802463 <fd_lookup+0x46>
  80245e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  802463:	5d                   	pop    %ebp
  802464:	c3                   	ret    

00802465 <seek>:
	return (*dev->dev_write)(fd, buf, n);
}

int
seek(int fdnum, off_t offset)
{
  802465:	55                   	push   %ebp
  802466:	89 e5                	mov    %esp,%ebp
  802468:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80246b:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80246e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802472:	8b 45 08             	mov    0x8(%ebp),%eax
  802475:	89 04 24             	mov    %eax,(%esp)
  802478:	e8 a0 ff ff ff       	call   80241d <fd_lookup>
  80247d:	85 c0                	test   %eax,%eax
  80247f:	78 0e                	js     80248f <seek+0x2a>
		return r;
	fd->fd_offset = offset;
  802481:	8b 45 fc             	mov    -0x4(%ebp),%eax
  802484:	8b 55 0c             	mov    0xc(%ebp),%edx
  802487:	89 50 04             	mov    %edx,0x4(%eax)
  80248a:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
}
  80248f:	c9                   	leave  
  802490:	c3                   	ret    

00802491 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  802491:	55                   	push   %ebp
  802492:	89 e5                	mov    %esp,%ebp
  802494:	56                   	push   %esi
  802495:	53                   	push   %ebx
  802496:	83 ec 10             	sub    $0x10,%esp
  802499:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80249c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
// File functions
// --------------------------------------------------------------

static struct Dev *devtab[] =
{
	&devfile,
  80249f:	b8 04 50 81 00       	mov    $0x815004,%eax
{
	int i;
	for (i = 0; devtab[i]; i++)
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
  8024a4:	ba 00 00 00 00       	mov    $0x0,%edx

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  8024a9:	be fc 2b 81 00       	mov    $0x812bfc,%esi
		if (devtab[i]->dev_id == dev_id) {
  8024ae:	39 08                	cmp    %ecx,(%eax)
  8024b0:	75 10                	jne    8024c2 <dev_lookup+0x31>
  8024b2:	eb 04                	jmp    8024b8 <dev_lookup+0x27>
  8024b4:	39 08                	cmp    %ecx,(%eax)
  8024b6:	75 0a                	jne    8024c2 <dev_lookup+0x31>
			*dev = devtab[i];
  8024b8:	89 03                	mov    %eax,(%ebx)
  8024ba:	b8 00 00 00 00       	mov    $0x0,%eax
			return 0;
  8024bf:	90                   	nop
  8024c0:	eb 31                	jmp    8024f3 <dev_lookup+0x62>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  8024c2:	83 c2 01             	add    $0x1,%edx
  8024c5:	8b 04 96             	mov    (%esi,%edx,4),%eax
  8024c8:	85 c0                	test   %eax,%eax
  8024ca:	75 e8                	jne    8024b4 <dev_lookup+0x23>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  8024cc:	a1 78 c2 b3 00       	mov    0xb3c278,%eax
  8024d1:	8b 40 48             	mov    0x48(%eax),%eax
  8024d4:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8024d8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8024dc:	c7 04 24 80 2b 81 00 	movl   $0x812b80,(%esp)
  8024e3:	e8 b9 e5 ff ff       	call   800aa1 <cprintf>
	*dev = 0;
  8024e8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  8024ee:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	return -E_INVAL;
}
  8024f3:	83 c4 10             	add    $0x10,%esp
  8024f6:	5b                   	pop    %ebx
  8024f7:	5e                   	pop    %esi
  8024f8:	5d                   	pop    %ebp
  8024f9:	c3                   	ret    

008024fa <fstat>:
	return (*dev->dev_trunc)(fd, newsize);
}

int
fstat(int fdnum, struct Stat *stat)
{
  8024fa:	55                   	push   %ebp
  8024fb:	89 e5                	mov    %esp,%ebp
  8024fd:	53                   	push   %ebx
  8024fe:	83 ec 24             	sub    $0x24,%esp
  802501:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802504:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802507:	89 44 24 04          	mov    %eax,0x4(%esp)
  80250b:	8b 45 08             	mov    0x8(%ebp),%eax
  80250e:	89 04 24             	mov    %eax,(%esp)
  802511:	e8 07 ff ff ff       	call   80241d <fd_lookup>
  802516:	85 c0                	test   %eax,%eax
  802518:	78 53                	js     80256d <fstat+0x73>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80251a:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80251d:	89 44 24 04          	mov    %eax,0x4(%esp)
  802521:	8b 45 f0             	mov    -0x10(%ebp),%eax
  802524:	8b 00                	mov    (%eax),%eax
  802526:	89 04 24             	mov    %eax,(%esp)
  802529:	e8 63 ff ff ff       	call   802491 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80252e:	85 c0                	test   %eax,%eax
  802530:	78 3b                	js     80256d <fstat+0x73>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if (!dev->dev_stat)
  802532:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  802537:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80253a:	83 7a 14 00          	cmpl   $0x0,0x14(%edx)
  80253e:	74 2d                	je     80256d <fstat+0x73>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  802540:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  802543:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80254a:	00 00 00 
	stat->st_isdir = 0;
  80254d:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  802554:	00 00 00 
	stat->st_dev = dev;
  802557:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80255a:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  802560:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802564:	8b 55 f0             	mov    -0x10(%ebp),%edx
  802567:	89 14 24             	mov    %edx,(%esp)
  80256a:	ff 50 14             	call   *0x14(%eax)
}
  80256d:	83 c4 24             	add    $0x24,%esp
  802570:	5b                   	pop    %ebx
  802571:	5d                   	pop    %ebp
  802572:	c3                   	ret    

00802573 <ftruncate>:
	return 0;
}

int
ftruncate(int fdnum, off_t newsize)
{
  802573:	55                   	push   %ebp
  802574:	89 e5                	mov    %esp,%ebp
  802576:	53                   	push   %ebx
  802577:	83 ec 24             	sub    $0x24,%esp
  80257a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  80257d:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802580:	89 44 24 04          	mov    %eax,0x4(%esp)
  802584:	89 1c 24             	mov    %ebx,(%esp)
  802587:	e8 91 fe ff ff       	call   80241d <fd_lookup>
  80258c:	85 c0                	test   %eax,%eax
  80258e:	78 5f                	js     8025ef <ftruncate+0x7c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  802590:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802593:	89 44 24 04          	mov    %eax,0x4(%esp)
  802597:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80259a:	8b 00                	mov    (%eax),%eax
  80259c:	89 04 24             	mov    %eax,(%esp)
  80259f:	e8 ed fe ff ff       	call   802491 <dev_lookup>
ftruncate(int fdnum, off_t newsize)
{
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  8025a4:	85 c0                	test   %eax,%eax
  8025a6:	78 47                	js     8025ef <ftruncate+0x7c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  8025a8:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8025ab:	f6 42 08 03          	testb  $0x3,0x8(%edx)
  8025af:	75 23                	jne    8025d4 <ftruncate+0x61>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  8025b1:	a1 78 c2 b3 00       	mov    0xb3c278,%eax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  8025b6:	8b 40 48             	mov    0x48(%eax),%eax
  8025b9:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8025bd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8025c1:	c7 04 24 a0 2b 81 00 	movl   $0x812ba0,(%esp)
  8025c8:	e8 d4 e4 ff ff       	call   800aa1 <cprintf>
  8025cd:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
			thisenv->env_id, fdnum);
		return -E_INVAL;
  8025d2:	eb 1b                	jmp    8025ef <ftruncate+0x7c>
	}
	if (!dev->dev_trunc)
  8025d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8025d7:	8b 48 18             	mov    0x18(%eax),%ecx
  8025da:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8025df:	85 c9                	test   %ecx,%ecx
  8025e1:	74 0c                	je     8025ef <ftruncate+0x7c>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  8025e3:	8b 45 0c             	mov    0xc(%ebp),%eax
  8025e6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8025ea:	89 14 24             	mov    %edx,(%esp)
  8025ed:	ff d1                	call   *%ecx
}
  8025ef:	83 c4 24             	add    $0x24,%esp
  8025f2:	5b                   	pop    %ebx
  8025f3:	5d                   	pop    %ebp
  8025f4:	c3                   	ret    

008025f5 <write>:
	return tot;
}

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  8025f5:	55                   	push   %ebp
  8025f6:	89 e5                	mov    %esp,%ebp
  8025f8:	53                   	push   %ebx
  8025f9:	83 ec 24             	sub    $0x24,%esp
  8025fc:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8025ff:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802602:	89 44 24 04          	mov    %eax,0x4(%esp)
  802606:	89 1c 24             	mov    %ebx,(%esp)
  802609:	e8 0f fe ff ff       	call   80241d <fd_lookup>
  80260e:	85 c0                	test   %eax,%eax
  802610:	78 66                	js     802678 <write+0x83>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  802612:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802615:	89 44 24 04          	mov    %eax,0x4(%esp)
  802619:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80261c:	8b 00                	mov    (%eax),%eax
  80261e:	89 04 24             	mov    %eax,(%esp)
  802621:	e8 6b fe ff ff       	call   802491 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802626:	85 c0                	test   %eax,%eax
  802628:	78 4e                	js     802678 <write+0x83>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80262a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80262d:	f6 42 08 03          	testb  $0x3,0x8(%edx)
  802631:	75 23                	jne    802656 <write+0x61>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  802633:	a1 78 c2 b3 00       	mov    0xb3c278,%eax
  802638:	8b 40 48             	mov    0x48(%eax),%eax
  80263b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80263f:	89 44 24 04          	mov    %eax,0x4(%esp)
  802643:	c7 04 24 c1 2b 81 00 	movl   $0x812bc1,(%esp)
  80264a:	e8 52 e4 ff ff       	call   800aa1 <cprintf>
  80264f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
		return -E_INVAL;
  802654:	eb 22                	jmp    802678 <write+0x83>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  802656:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802659:	8b 48 0c             	mov    0xc(%eax),%ecx
  80265c:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  802661:	85 c9                	test   %ecx,%ecx
  802663:	74 13                	je     802678 <write+0x83>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  802665:	8b 45 10             	mov    0x10(%ebp),%eax
  802668:	89 44 24 08          	mov    %eax,0x8(%esp)
  80266c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80266f:	89 44 24 04          	mov    %eax,0x4(%esp)
  802673:	89 14 24             	mov    %edx,(%esp)
  802676:	ff d1                	call   *%ecx
}
  802678:	83 c4 24             	add    $0x24,%esp
  80267b:	5b                   	pop    %ebx
  80267c:	5d                   	pop    %ebp
  80267d:	c3                   	ret    

0080267e <read>:
	return r;
}

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80267e:	55                   	push   %ebp
  80267f:	89 e5                	mov    %esp,%ebp
  802681:	53                   	push   %ebx
  802682:	83 ec 24             	sub    $0x24,%esp
  802685:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802688:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80268b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80268f:	89 1c 24             	mov    %ebx,(%esp)
  802692:	e8 86 fd ff ff       	call   80241d <fd_lookup>
  802697:	85 c0                	test   %eax,%eax
  802699:	78 6b                	js     802706 <read+0x88>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80269b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80269e:	89 44 24 04          	mov    %eax,0x4(%esp)
  8026a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8026a5:	8b 00                	mov    (%eax),%eax
  8026a7:	89 04 24             	mov    %eax,(%esp)
  8026aa:	e8 e2 fd ff ff       	call   802491 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8026af:	85 c0                	test   %eax,%eax
  8026b1:	78 53                	js     802706 <read+0x88>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  8026b3:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8026b6:	8b 42 08             	mov    0x8(%edx),%eax
  8026b9:	83 e0 03             	and    $0x3,%eax
  8026bc:	83 f8 01             	cmp    $0x1,%eax
  8026bf:	75 23                	jne    8026e4 <read+0x66>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  8026c1:	a1 78 c2 b3 00       	mov    0xb3c278,%eax
  8026c6:	8b 40 48             	mov    0x48(%eax),%eax
  8026c9:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8026cd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8026d1:	c7 04 24 de 2b 81 00 	movl   $0x812bde,(%esp)
  8026d8:	e8 c4 e3 ff ff       	call   800aa1 <cprintf>
  8026dd:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
		return -E_INVAL;
  8026e2:	eb 22                	jmp    802706 <read+0x88>
	}
	if (!dev->dev_read)
  8026e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8026e7:	8b 48 08             	mov    0x8(%eax),%ecx
  8026ea:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8026ef:	85 c9                	test   %ecx,%ecx
  8026f1:	74 13                	je     802706 <read+0x88>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  8026f3:	8b 45 10             	mov    0x10(%ebp),%eax
  8026f6:	89 44 24 08          	mov    %eax,0x8(%esp)
  8026fa:	8b 45 0c             	mov    0xc(%ebp),%eax
  8026fd:	89 44 24 04          	mov    %eax,0x4(%esp)
  802701:	89 14 24             	mov    %edx,(%esp)
  802704:	ff d1                	call   *%ecx
}
  802706:	83 c4 24             	add    $0x24,%esp
  802709:	5b                   	pop    %ebx
  80270a:	5d                   	pop    %ebp
  80270b:	c3                   	ret    

0080270c <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80270c:	55                   	push   %ebp
  80270d:	89 e5                	mov    %esp,%ebp
  80270f:	57                   	push   %edi
  802710:	56                   	push   %esi
  802711:	53                   	push   %ebx
  802712:	83 ec 1c             	sub    $0x1c,%esp
  802715:	8b 7d 08             	mov    0x8(%ebp),%edi
  802718:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80271b:	ba 00 00 00 00       	mov    $0x0,%edx
  802720:	bb 00 00 00 00       	mov    $0x0,%ebx
  802725:	b8 00 00 00 00       	mov    $0x0,%eax
  80272a:	85 f6                	test   %esi,%esi
  80272c:	74 29                	je     802757 <readn+0x4b>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80272e:	89 f0                	mov    %esi,%eax
  802730:	29 d0                	sub    %edx,%eax
  802732:	89 44 24 08          	mov    %eax,0x8(%esp)
  802736:	03 55 0c             	add    0xc(%ebp),%edx
  802739:	89 54 24 04          	mov    %edx,0x4(%esp)
  80273d:	89 3c 24             	mov    %edi,(%esp)
  802740:	e8 39 ff ff ff       	call   80267e <read>
		if (m < 0)
  802745:	85 c0                	test   %eax,%eax
  802747:	78 0e                	js     802757 <readn+0x4b>
			return m;
		if (m == 0)
  802749:	85 c0                	test   %eax,%eax
  80274b:	74 08                	je     802755 <readn+0x49>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80274d:	01 c3                	add    %eax,%ebx
  80274f:	89 da                	mov    %ebx,%edx
  802751:	39 f3                	cmp    %esi,%ebx
  802753:	72 d9                	jb     80272e <readn+0x22>
  802755:	89 d8                	mov    %ebx,%eax
			return m;
		if (m == 0)
			break;
	}
	return tot;
}
  802757:	83 c4 1c             	add    $0x1c,%esp
  80275a:	5b                   	pop    %ebx
  80275b:	5e                   	pop    %esi
  80275c:	5f                   	pop    %edi
  80275d:	5d                   	pop    %ebp
  80275e:	c3                   	ret    

0080275f <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  80275f:	55                   	push   %ebp
  802760:	89 e5                	mov    %esp,%ebp
  802762:	56                   	push   %esi
  802763:	53                   	push   %ebx
  802764:	83 ec 20             	sub    $0x20,%esp
  802767:	8b 75 08             	mov    0x8(%ebp),%esi
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80276a:	89 34 24             	mov    %esi,(%esp)
  80276d:	e8 0e fc ff ff       	call   802380 <fd2num>
  802772:	8d 55 f4             	lea    -0xc(%ebp),%edx
  802775:	89 54 24 04          	mov    %edx,0x4(%esp)
  802779:	89 04 24             	mov    %eax,(%esp)
  80277c:	e8 9c fc ff ff       	call   80241d <fd_lookup>
  802781:	89 c3                	mov    %eax,%ebx
  802783:	85 c0                	test   %eax,%eax
  802785:	78 05                	js     80278c <fd_close+0x2d>
  802787:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  80278a:	74 0c                	je     802798 <fd_close+0x39>
	    || fd != fd2)
		return (must_exist ? r : 0);
  80278c:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  802790:	19 c0                	sbb    %eax,%eax
  802792:	f7 d0                	not    %eax
  802794:	21 c3                	and    %eax,%ebx
  802796:	eb 3d                	jmp    8027d5 <fd_close+0x76>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  802798:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80279b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80279f:	8b 06                	mov    (%esi),%eax
  8027a1:	89 04 24             	mov    %eax,(%esp)
  8027a4:	e8 e8 fc ff ff       	call   802491 <dev_lookup>
  8027a9:	89 c3                	mov    %eax,%ebx
  8027ab:	85 c0                	test   %eax,%eax
  8027ad:	78 16                	js     8027c5 <fd_close+0x66>
		if (dev->dev_close)
  8027af:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8027b2:	8b 40 10             	mov    0x10(%eax),%eax
  8027b5:	bb 00 00 00 00       	mov    $0x0,%ebx
  8027ba:	85 c0                	test   %eax,%eax
  8027bc:	74 07                	je     8027c5 <fd_close+0x66>
			r = (*dev->dev_close)(fd);
  8027be:	89 34 24             	mov    %esi,(%esp)
  8027c1:	ff d0                	call   *%eax
  8027c3:	89 c3                	mov    %eax,%ebx
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  8027c5:	89 74 24 04          	mov    %esi,0x4(%esp)
  8027c9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8027d0:	e8 49 f4 ff ff       	call   801c1e <sys_page_unmap>
	return r;
}
  8027d5:	89 d8                	mov    %ebx,%eax
  8027d7:	83 c4 20             	add    $0x20,%esp
  8027da:	5b                   	pop    %ebx
  8027db:	5e                   	pop    %esi
  8027dc:	5d                   	pop    %ebp
  8027dd:	c3                   	ret    

008027de <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  8027de:	55                   	push   %ebp
  8027df:	89 e5                	mov    %esp,%ebp
  8027e1:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8027e4:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8027e7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8027eb:	8b 45 08             	mov    0x8(%ebp),%eax
  8027ee:	89 04 24             	mov    %eax,(%esp)
  8027f1:	e8 27 fc ff ff       	call   80241d <fd_lookup>
  8027f6:	85 c0                	test   %eax,%eax
  8027f8:	78 13                	js     80280d <close+0x2f>
		return r;
	else
		return fd_close(fd, 1);
  8027fa:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  802801:	00 
  802802:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802805:	89 04 24             	mov    %eax,(%esp)
  802808:	e8 52 ff ff ff       	call   80275f <fd_close>
}
  80280d:	c9                   	leave  
  80280e:	c3                   	ret    

0080280f <stat>:
	return (*dev->dev_stat)(fd, stat);
}

int
stat(const char *path, struct Stat *stat)
{
  80280f:	55                   	push   %ebp
  802810:	89 e5                	mov    %esp,%ebp
  802812:	83 ec 18             	sub    $0x18,%esp
  802815:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802818:	89 75 fc             	mov    %esi,-0x4(%ebp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  80281b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802822:	00 
  802823:	8b 45 08             	mov    0x8(%ebp),%eax
  802826:	89 04 24             	mov    %eax,(%esp)
  802829:	e8 79 03 00 00       	call   802ba7 <open>
  80282e:	89 c3                	mov    %eax,%ebx
  802830:	85 c0                	test   %eax,%eax
  802832:	78 1b                	js     80284f <stat+0x40>
		return fd;
	r = fstat(fd, stat);
  802834:	8b 45 0c             	mov    0xc(%ebp),%eax
  802837:	89 44 24 04          	mov    %eax,0x4(%esp)
  80283b:	89 1c 24             	mov    %ebx,(%esp)
  80283e:	e8 b7 fc ff ff       	call   8024fa <fstat>
  802843:	89 c6                	mov    %eax,%esi
	close(fd);
  802845:	89 1c 24             	mov    %ebx,(%esp)
  802848:	e8 91 ff ff ff       	call   8027de <close>
  80284d:	89 f3                	mov    %esi,%ebx
	return r;
}
  80284f:	89 d8                	mov    %ebx,%eax
  802851:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802854:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802857:	89 ec                	mov    %ebp,%esp
  802859:	5d                   	pop    %ebp
  80285a:	c3                   	ret    

0080285b <close_all>:
		return fd_close(fd, 1);
}

void
close_all(void)
{
  80285b:	55                   	push   %ebp
  80285c:	89 e5                	mov    %esp,%ebp
  80285e:	53                   	push   %ebx
  80285f:	83 ec 14             	sub    $0x14,%esp
  802862:	bb 00 00 00 00       	mov    $0x0,%ebx
	int i;
	for (i = 0; i < MAXFD; i++)
		close(i);
  802867:	89 1c 24             	mov    %ebx,(%esp)
  80286a:	e8 6f ff ff ff       	call   8027de <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  80286f:	83 c3 01             	add    $0x1,%ebx
  802872:	83 fb 20             	cmp    $0x20,%ebx
  802875:	75 f0                	jne    802867 <close_all+0xc>
		close(i);
}
  802877:	83 c4 14             	add    $0x14,%esp
  80287a:	5b                   	pop    %ebx
  80287b:	5d                   	pop    %ebp
  80287c:	c3                   	ret    

0080287d <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80287d:	55                   	push   %ebp
  80287e:	89 e5                	mov    %esp,%ebp
  802880:	83 ec 58             	sub    $0x58,%esp
  802883:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  802886:	89 75 f8             	mov    %esi,-0x8(%ebp)
  802889:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80288c:	8b 7d 0c             	mov    0xc(%ebp),%edi
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80288f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  802892:	89 44 24 04          	mov    %eax,0x4(%esp)
  802896:	8b 45 08             	mov    0x8(%ebp),%eax
  802899:	89 04 24             	mov    %eax,(%esp)
  80289c:	e8 7c fb ff ff       	call   80241d <fd_lookup>
  8028a1:	89 c3                	mov    %eax,%ebx
  8028a3:	85 c0                	test   %eax,%eax
  8028a5:	0f 88 e0 00 00 00    	js     80298b <dup+0x10e>
		return r;
	close(newfdnum);
  8028ab:	89 3c 24             	mov    %edi,(%esp)
  8028ae:	e8 2b ff ff ff       	call   8027de <close>

	newfd = INDEX2FD(newfdnum);
  8028b3:	8d b7 00 00 0d 00    	lea    0xd0000(%edi),%esi
  8028b9:	c1 e6 0c             	shl    $0xc,%esi
	ova = fd2data(oldfd);
  8028bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8028bf:	89 04 24             	mov    %eax,(%esp)
  8028c2:	e8 c9 fa ff ff       	call   802390 <fd2data>
  8028c7:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  8028c9:	89 34 24             	mov    %esi,(%esp)
  8028cc:	e8 bf fa ff ff       	call   802390 <fd2data>
  8028d1:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	if ((vpd[PDX(ova)] & PTE_P) && (vpt[PGNUM(ova)] & PTE_P))
  8028d4:	89 da                	mov    %ebx,%edx
  8028d6:	89 d8                	mov    %ebx,%eax
  8028d8:	c1 e8 16             	shr    $0x16,%eax
  8028db:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  8028e2:	a8 01                	test   $0x1,%al
  8028e4:	74 43                	je     802929 <dup+0xac>
  8028e6:	c1 ea 0c             	shr    $0xc,%edx
  8028e9:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  8028f0:	a8 01                	test   $0x1,%al
  8028f2:	74 35                	je     802929 <dup+0xac>
		if ((r = sys_page_map(0, ova, 0, nva, vpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  8028f4:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  8028fb:	25 07 0e 00 00       	and    $0xe07,%eax
  802900:	89 44 24 10          	mov    %eax,0x10(%esp)
  802904:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  802907:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80290b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802912:	00 
  802913:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802917:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80291e:	e8 67 f3 ff ff       	call   801c8a <sys_page_map>
  802923:	89 c3                	mov    %eax,%ebx
  802925:	85 c0                	test   %eax,%eax
  802927:	78 3f                	js     802968 <dup+0xeb>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, vpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  802929:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80292c:	89 c2                	mov    %eax,%edx
  80292e:	c1 ea 0c             	shr    $0xc,%edx
  802931:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  802938:	81 e2 07 0e 00 00    	and    $0xe07,%edx
  80293e:	89 54 24 10          	mov    %edx,0x10(%esp)
  802942:	89 74 24 0c          	mov    %esi,0xc(%esp)
  802946:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80294d:	00 
  80294e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802952:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802959:	e8 2c f3 ff ff       	call   801c8a <sys_page_map>
  80295e:	89 c3                	mov    %eax,%ebx
  802960:	85 c0                	test   %eax,%eax
  802962:	78 04                	js     802968 <dup+0xeb>
  802964:	89 fb                	mov    %edi,%ebx
  802966:	eb 23                	jmp    80298b <dup+0x10e>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  802968:	89 74 24 04          	mov    %esi,0x4(%esp)
  80296c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802973:	e8 a6 f2 ff ff       	call   801c1e <sys_page_unmap>
	sys_page_unmap(0, nva);
  802978:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80297b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80297f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802986:	e8 93 f2 ff ff       	call   801c1e <sys_page_unmap>
	return r;
}
  80298b:	89 d8                	mov    %ebx,%eax
  80298d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  802990:	8b 75 f8             	mov    -0x8(%ebp),%esi
  802993:	8b 7d fc             	mov    -0x4(%ebp),%edi
  802996:	89 ec                	mov    %ebp,%esp
  802998:	5d                   	pop    %ebp
  802999:	c3                   	ret    
	...

0080299c <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  80299c:	55                   	push   %ebp
  80299d:	89 e5                	mov    %esp,%ebp
  80299f:	83 ec 18             	sub    $0x18,%esp
  8029a2:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8029a5:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8029a8:	89 c3                	mov    %eax,%ebx
  8029aa:	89 d6                	mov    %edx,%esi
	static envid_t fsenv;
	if (fsenv == 0)
  8029ac:	83 3d 90 60 81 00 00 	cmpl   $0x0,0x816090
  8029b3:	75 11                	jne    8029c6 <fsipc+0x2a>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  8029b5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8029bc:	e8 7f f8 ff ff       	call   802240 <ipc_find_env>
  8029c1:	a3 90 60 81 00       	mov    %eax,0x816090
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  8029c6:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  8029cd:	00 
  8029ce:	c7 44 24 08 00 d0 b3 	movl   $0xb3d000,0x8(%esp)
  8029d5:	00 
  8029d6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8029da:	a1 90 60 81 00       	mov    0x816090,%eax
  8029df:	89 04 24             	mov    %eax,(%esp)
  8029e2:	e8 a4 f8 ff ff       	call   80228b <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  8029e7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8029ee:	00 
  8029ef:	89 74 24 04          	mov    %esi,0x4(%esp)
  8029f3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8029fa:	e8 0a f9 ff ff       	call   802309 <ipc_recv>
}
  8029ff:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802a02:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802a05:	89 ec                	mov    %ebp,%esp
  802a07:	5d                   	pop    %ebp
  802a08:	c3                   	ret    

00802a09 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  802a09:	55                   	push   %ebp
  802a0a:	89 e5                	mov    %esp,%ebp
  802a0c:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  802a0f:	8b 45 08             	mov    0x8(%ebp),%eax
  802a12:	8b 40 0c             	mov    0xc(%eax),%eax
  802a15:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.set_size.req_size = newsize;
  802a1a:	8b 45 0c             	mov    0xc(%ebp),%eax
  802a1d:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return fsipc(FSREQ_SET_SIZE, NULL);
  802a22:	ba 00 00 00 00       	mov    $0x0,%edx
  802a27:	b8 02 00 00 00       	mov    $0x2,%eax
  802a2c:	e8 6b ff ff ff       	call   80299c <fsipc>
}
  802a31:	c9                   	leave  
  802a32:	c3                   	ret    

00802a33 <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  802a33:	55                   	push   %ebp
  802a34:	89 e5                	mov    %esp,%ebp
  802a36:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  802a39:	8b 45 08             	mov    0x8(%ebp),%eax
  802a3c:	8b 40 0c             	mov    0xc(%eax),%eax
  802a3f:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return fsipc(FSREQ_FLUSH, NULL);
  802a44:	ba 00 00 00 00       	mov    $0x0,%edx
  802a49:	b8 06 00 00 00       	mov    $0x6,%eax
  802a4e:	e8 49 ff ff ff       	call   80299c <fsipc>
}
  802a53:	c9                   	leave  
  802a54:	c3                   	ret    

00802a55 <sync>:
}

// Synchronize disk with buffer cache
int
sync(void)
{
  802a55:	55                   	push   %ebp
  802a56:	89 e5                	mov    %esp,%ebp
  802a58:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  802a5b:	ba 00 00 00 00       	mov    $0x0,%edx
  802a60:	b8 08 00 00 00       	mov    $0x8,%eax
  802a65:	e8 32 ff ff ff       	call   80299c <fsipc>
}
  802a6a:	c9                   	leave  
  802a6b:	c3                   	ret    

00802a6c <devfile_stat>:
	//panic("devfile_write not implemented");
}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  802a6c:	55                   	push   %ebp
  802a6d:	89 e5                	mov    %esp,%ebp
  802a6f:	53                   	push   %ebx
  802a70:	83 ec 14             	sub    $0x14,%esp
  802a73:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  802a76:	8b 45 08             	mov    0x8(%ebp),%eax
  802a79:	8b 40 0c             	mov    0xc(%eax),%eax
  802a7c:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  802a81:	ba 00 00 00 00       	mov    $0x0,%edx
  802a86:	b8 05 00 00 00       	mov    $0x5,%eax
  802a8b:	e8 0c ff ff ff       	call   80299c <fsipc>
  802a90:	85 c0                	test   %eax,%eax
  802a92:	78 2b                	js     802abf <devfile_stat+0x53>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  802a94:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  802a9b:	00 
  802a9c:	89 1c 24             	mov    %ebx,(%esp)
  802a9f:	e8 26 e9 ff ff       	call   8013ca <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  802aa4:	a1 80 d0 b3 00       	mov    0xb3d080,%eax
  802aa9:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  802aaf:	a1 84 d0 b3 00       	mov    0xb3d084,%eax
  802ab4:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
  802aba:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
}
  802abf:	83 c4 14             	add    $0x14,%esp
  802ac2:	5b                   	pop    %ebx
  802ac3:	5d                   	pop    %ebp
  802ac4:	c3                   	ret    

00802ac5 <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  802ac5:	55                   	push   %ebp
  802ac6:	89 e5                	mov    %esp,%ebp
  802ac8:	83 ec 18             	sub    $0x18,%esp
  802acb:	8b 45 10             	mov    0x10(%ebp),%eax
  802ace:	3d f8 0f 00 00       	cmp    $0xff8,%eax
  802ad3:	76 05                	jbe    802ada <devfile_write+0x15>
  802ad5:	b8 f8 0f 00 00       	mov    $0xff8,%eax
	// bytes than requested.
	// LAB 5: Your code here
        int r;
        if(n > sizeof(fsipcbuf.write.req_buf))
            n = sizeof(fsipcbuf.write.req_buf);
        fsipcbuf.write.req_fileid = fd->fd_file.id;
  802ada:	8b 55 08             	mov    0x8(%ebp),%edx
  802add:	8b 52 0c             	mov    0xc(%edx),%edx
  802ae0:	89 15 00 d0 b3 00    	mov    %edx,0xb3d000
        fsipcbuf.write.req_n = n;
  802ae6:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
        memmove(fsipcbuf.write.req_buf,buf,n);  
  802aeb:	89 44 24 08          	mov    %eax,0x8(%esp)
  802aef:	8b 45 0c             	mov    0xc(%ebp),%eax
  802af2:	89 44 24 04          	mov    %eax,0x4(%esp)
  802af6:	c7 04 24 08 d0 b3 00 	movl   $0xb3d008,(%esp)
  802afd:	e8 b3 ea ff ff       	call   8015b5 <memmove>
        r = fsipc(FSREQ_WRITE,NULL);
  802b02:	ba 00 00 00 00       	mov    $0x0,%edx
  802b07:	b8 04 00 00 00       	mov    $0x4,%eax
  802b0c:	e8 8b fe ff ff       	call   80299c <fsipc>
        return r;
	//panic("devfile_write not implemented");
}
  802b11:	c9                   	leave  
  802b12:	c3                   	ret    

00802b13 <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  802b13:	55                   	push   %ebp
  802b14:	89 e5                	mov    %esp,%ebp
  802b16:	53                   	push   %ebx
  802b17:	83 ec 14             	sub    $0x14,%esp
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	// LAB 5: Your code here
        int r;
        fsipcbuf.read.req_fileid = fd->fd_file.id;
  802b1a:	8b 45 08             	mov    0x8(%ebp),%eax
  802b1d:	8b 40 0c             	mov    0xc(%eax),%eax
  802b20:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
        fsipcbuf.read.req_n = n;
  802b25:	8b 45 10             	mov    0x10(%ebp),%eax
  802b28:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
        r = fsipc(FSREQ_READ,NULL);
  802b2d:	ba 00 00 00 00       	mov    $0x0,%edx
  802b32:	b8 03 00 00 00       	mov    $0x3,%eax
  802b37:	e8 60 fe ff ff       	call   80299c <fsipc>
  802b3c:	89 c3                	mov    %eax,%ebx
        if(r < 0)
  802b3e:	85 c0                	test   %eax,%eax
  802b40:	78 17                	js     802b59 <devfile_read+0x46>
           return r;
        memmove(buf,fsipcbuf.readRet.ret_buf,r);
  802b42:	89 44 24 08          	mov    %eax,0x8(%esp)
  802b46:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  802b4d:	00 
  802b4e:	8b 45 0c             	mov    0xc(%ebp),%eax
  802b51:	89 04 24             	mov    %eax,(%esp)
  802b54:	e8 5c ea ff ff       	call   8015b5 <memmove>
        return r;
	//panic("devfile_read not implemented");
}
  802b59:	89 d8                	mov    %ebx,%eax
  802b5b:	83 c4 14             	add    $0x14,%esp
  802b5e:	5b                   	pop    %ebx
  802b5f:	5d                   	pop    %ebp
  802b60:	c3                   	ret    

00802b61 <remove>:
}

// Delete a file
int
remove(const char *path)
{
  802b61:	55                   	push   %ebp
  802b62:	89 e5                	mov    %esp,%ebp
  802b64:	53                   	push   %ebx
  802b65:	83 ec 14             	sub    $0x14,%esp
  802b68:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (strlen(path) >= MAXPATHLEN)
  802b6b:	89 1c 24             	mov    %ebx,(%esp)
  802b6e:	e8 0d e8 ff ff       	call   801380 <strlen>
  802b73:	89 c2                	mov    %eax,%edx
  802b75:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  802b7a:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
  802b80:	7f 1f                	jg     802ba1 <remove+0x40>
		return -E_BAD_PATH;
	strcpy(fsipcbuf.remove.req_path, path);
  802b82:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802b86:	c7 04 24 00 d0 b3 00 	movl   $0xb3d000,(%esp)
  802b8d:	e8 38 e8 ff ff       	call   8013ca <strcpy>
	return fsipc(FSREQ_REMOVE, NULL);
  802b92:	ba 00 00 00 00       	mov    $0x0,%edx
  802b97:	b8 07 00 00 00       	mov    $0x7,%eax
  802b9c:	e8 fb fd ff ff       	call   80299c <fsipc>
}
  802ba1:	83 c4 14             	add    $0x14,%esp
  802ba4:	5b                   	pop    %ebx
  802ba5:	5d                   	pop    %ebp
  802ba6:	c3                   	ret    

00802ba7 <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  802ba7:	55                   	push   %ebp
  802ba8:	89 e5                	mov    %esp,%ebp
  802baa:	83 ec 28             	sub    $0x28,%esp
  802bad:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802bb0:	89 75 fc             	mov    %esi,-0x4(%ebp)
  802bb3:	8b 75 08             	mov    0x8(%ebp),%esi
	// If any step after fd_alloc fails, use fd_close to free the
	// file descriptor.

	// LAB 5: Your code here.
        struct Fd* fd;
        if(strlen(path) > MAXPATHLEN)
  802bb6:	89 34 24             	mov    %esi,(%esp)
  802bb9:	e8 c2 e7 ff ff       	call   801380 <strlen>
  802bbe:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
  802bc3:	3d 00 04 00 00       	cmp    $0x400,%eax
  802bc8:	7f 6d                	jg     802c37 <open+0x90>
            return -E_BAD_PATH;
        int r;
        r = fd_alloc(&fd);
  802bca:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802bcd:	89 04 24             	mov    %eax,(%esp)
  802bd0:	e8 d6 f7 ff ff       	call   8023ab <fd_alloc>
  802bd5:	89 c3                	mov    %eax,%ebx
        if(r < 0)
  802bd7:	85 c0                	test   %eax,%eax
  802bd9:	78 5c                	js     802c37 <open+0x90>
           return r;
        fsipcbuf.open.req_omode = mode;
  802bdb:	8b 45 0c             	mov    0xc(%ebp),%eax
  802bde:	a3 00 d4 b3 00       	mov    %eax,0xb3d400
        memmove(fsipcbuf.open.req_path,path,strlen(path)+1);
  802be3:	89 34 24             	mov    %esi,(%esp)
  802be6:	e8 95 e7 ff ff       	call   801380 <strlen>
  802beb:	83 c0 01             	add    $0x1,%eax
  802bee:	89 44 24 08          	mov    %eax,0x8(%esp)
  802bf2:	89 74 24 04          	mov    %esi,0x4(%esp)
  802bf6:	c7 04 24 00 d0 b3 00 	movl   $0xb3d000,(%esp)
  802bfd:	e8 b3 e9 ff ff       	call   8015b5 <memmove>
        r = fsipc(FSREQ_OPEN,(void*)fd);
  802c02:	8b 55 f4             	mov    -0xc(%ebp),%edx
  802c05:	b8 01 00 00 00       	mov    $0x1,%eax
  802c0a:	e8 8d fd ff ff       	call   80299c <fsipc>
  802c0f:	89 c3                	mov    %eax,%ebx
        if(r < 0){
  802c11:	85 c0                	test   %eax,%eax
  802c13:	79 15                	jns    802c2a <open+0x83>
             fd_close(fd,0);
  802c15:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802c1c:	00 
  802c1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802c20:	89 04 24             	mov    %eax,(%esp)
  802c23:	e8 37 fb ff ff       	call   80275f <fd_close>
             return r;
  802c28:	eb 0d                	jmp    802c37 <open+0x90>
        }
        return fd2num(fd);
  802c2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802c2d:	89 04 24             	mov    %eax,(%esp)
  802c30:	e8 4b f7 ff ff       	call   802380 <fd2num>
  802c35:	89 c3                	mov    %eax,%ebx
	//panic("open not implemented");
}
  802c37:	89 d8                	mov    %ebx,%eax
  802c39:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802c3c:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802c3f:	89 ec                	mov    %ebp,%esp
  802c41:	5d                   	pop    %ebp
  802c42:	c3                   	ret    
	...

00802c50 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  802c50:	55                   	push   %ebp
  802c51:	89 e5                	mov    %esp,%ebp
  802c53:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<sock>");
  802c56:	c7 44 24 04 08 2c 81 	movl   $0x812c08,0x4(%esp)
  802c5d:	00 
  802c5e:	8b 45 0c             	mov    0xc(%ebp),%eax
  802c61:	89 04 24             	mov    %eax,(%esp)
  802c64:	e8 61 e7 ff ff       	call   8013ca <strcpy>
	return 0;
}
  802c69:	b8 00 00 00 00       	mov    $0x0,%eax
  802c6e:	c9                   	leave  
  802c6f:	c3                   	ret    

00802c70 <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  802c70:	55                   	push   %ebp
  802c71:	89 e5                	mov    %esp,%ebp
  802c73:	53                   	push   %ebx
  802c74:	83 ec 14             	sub    $0x14,%esp
  802c77:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  802c7a:	89 1c 24             	mov    %ebx,(%esp)
  802c7d:	e8 fe 07 00 00       	call   803480 <pageref>
  802c82:	89 c2                	mov    %eax,%edx
  802c84:	b8 00 00 00 00       	mov    $0x0,%eax
  802c89:	83 fa 01             	cmp    $0x1,%edx
  802c8c:	75 0b                	jne    802c99 <devsock_close+0x29>
		return nsipc_close(fd->fd_sock.sockid);
  802c8e:	8b 43 0c             	mov    0xc(%ebx),%eax
  802c91:	89 04 24             	mov    %eax,(%esp)
  802c94:	e8 b9 02 00 00       	call   802f52 <nsipc_close>
	else
		return 0;
}
  802c99:	83 c4 14             	add    $0x14,%esp
  802c9c:	5b                   	pop    %ebx
  802c9d:	5d                   	pop    %ebp
  802c9e:	c3                   	ret    

00802c9f <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  802c9f:	55                   	push   %ebp
  802ca0:	89 e5                	mov    %esp,%ebp
  802ca2:	83 ec 18             	sub    $0x18,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  802ca5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  802cac:	00 
  802cad:	8b 45 10             	mov    0x10(%ebp),%eax
  802cb0:	89 44 24 08          	mov    %eax,0x8(%esp)
  802cb4:	8b 45 0c             	mov    0xc(%ebp),%eax
  802cb7:	89 44 24 04          	mov    %eax,0x4(%esp)
  802cbb:	8b 45 08             	mov    0x8(%ebp),%eax
  802cbe:	8b 40 0c             	mov    0xc(%eax),%eax
  802cc1:	89 04 24             	mov    %eax,(%esp)
  802cc4:	e8 c5 02 00 00       	call   802f8e <nsipc_send>
}
  802cc9:	c9                   	leave  
  802cca:	c3                   	ret    

00802ccb <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  802ccb:	55                   	push   %ebp
  802ccc:	89 e5                	mov    %esp,%ebp
  802cce:	83 ec 18             	sub    $0x18,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  802cd1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  802cd8:	00 
  802cd9:	8b 45 10             	mov    0x10(%ebp),%eax
  802cdc:	89 44 24 08          	mov    %eax,0x8(%esp)
  802ce0:	8b 45 0c             	mov    0xc(%ebp),%eax
  802ce3:	89 44 24 04          	mov    %eax,0x4(%esp)
  802ce7:	8b 45 08             	mov    0x8(%ebp),%eax
  802cea:	8b 40 0c             	mov    0xc(%eax),%eax
  802ced:	89 04 24             	mov    %eax,(%esp)
  802cf0:	e8 0c 03 00 00       	call   803001 <nsipc_recv>
}
  802cf5:	c9                   	leave  
  802cf6:	c3                   	ret    

00802cf7 <alloc_sockfd>:
	return sfd->fd_sock.sockid;
}

static int
alloc_sockfd(int sockid)
{
  802cf7:	55                   	push   %ebp
  802cf8:	89 e5                	mov    %esp,%ebp
  802cfa:	56                   	push   %esi
  802cfb:	53                   	push   %ebx
  802cfc:	83 ec 20             	sub    $0x20,%esp
  802cff:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  802d01:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802d04:	89 04 24             	mov    %eax,(%esp)
  802d07:	e8 9f f6 ff ff       	call   8023ab <fd_alloc>
  802d0c:	89 c3                	mov    %eax,%ebx
  802d0e:	85 c0                	test   %eax,%eax
  802d10:	78 21                	js     802d33 <alloc_sockfd+0x3c>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  802d12:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  802d19:	00 
  802d1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802d1d:	89 44 24 04          	mov    %eax,0x4(%esp)
  802d21:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802d28:	e8 cb ef ff ff       	call   801cf8 <sys_page_alloc>
  802d2d:	89 c3                	mov    %eax,%ebx
alloc_sockfd(int sockid)
{
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  802d2f:	85 c0                	test   %eax,%eax
  802d31:	79 0a                	jns    802d3d <alloc_sockfd+0x46>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
		nsipc_close(sockid);
  802d33:	89 34 24             	mov    %esi,(%esp)
  802d36:	e8 17 02 00 00       	call   802f52 <nsipc_close>
		return r;
  802d3b:	eb 28                	jmp    802d65 <alloc_sockfd+0x6e>
	}

	sfd->fd_dev_id = devsock.dev_id;
  802d3d:	8b 15 20 50 81 00    	mov    0x815020,%edx
  802d43:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802d46:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  802d48:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802d4b:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  802d52:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802d55:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  802d58:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802d5b:	89 04 24             	mov    %eax,(%esp)
  802d5e:	e8 1d f6 ff ff       	call   802380 <fd2num>
  802d63:	89 c3                	mov    %eax,%ebx
}
  802d65:	89 d8                	mov    %ebx,%eax
  802d67:	83 c4 20             	add    $0x20,%esp
  802d6a:	5b                   	pop    %ebx
  802d6b:	5e                   	pop    %esi
  802d6c:	5d                   	pop    %ebp
  802d6d:	c3                   	ret    

00802d6e <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  802d6e:	55                   	push   %ebp
  802d6f:	89 e5                	mov    %esp,%ebp
  802d71:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  802d74:	8b 45 10             	mov    0x10(%ebp),%eax
  802d77:	89 44 24 08          	mov    %eax,0x8(%esp)
  802d7b:	8b 45 0c             	mov    0xc(%ebp),%eax
  802d7e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802d82:	8b 45 08             	mov    0x8(%ebp),%eax
  802d85:	89 04 24             	mov    %eax,(%esp)
  802d88:	e8 79 01 00 00       	call   802f06 <nsipc_socket>
  802d8d:	85 c0                	test   %eax,%eax
  802d8f:	78 05                	js     802d96 <socket+0x28>
		return r;
	return alloc_sockfd(r);
  802d91:	e8 61 ff ff ff       	call   802cf7 <alloc_sockfd>
}
  802d96:	c9                   	leave  
  802d97:	c3                   	ret    

00802d98 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  802d98:	55                   	push   %ebp
  802d99:	89 e5                	mov    %esp,%ebp
  802d9b:	83 ec 28             	sub    $0x28,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  802d9e:	8d 55 f4             	lea    -0xc(%ebp),%edx
  802da1:	89 54 24 04          	mov    %edx,0x4(%esp)
  802da5:	89 04 24             	mov    %eax,(%esp)
  802da8:	e8 70 f6 ff ff       	call   80241d <fd_lookup>
  802dad:	85 c0                	test   %eax,%eax
  802daf:	78 15                	js     802dc6 <fd2sockid+0x2e>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  802db1:	8b 55 f4             	mov    -0xc(%ebp),%edx
  802db4:	8b 0a                	mov    (%edx),%ecx
  802db6:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  802dbb:	3b 0d 20 50 81 00    	cmp    0x815020,%ecx
  802dc1:	75 03                	jne    802dc6 <fd2sockid+0x2e>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  802dc3:	8b 42 0c             	mov    0xc(%edx),%eax
}
  802dc6:	c9                   	leave  
  802dc7:	c3                   	ret    

00802dc8 <listen>:
	return nsipc_connect(r, name, namelen);
}

int
listen(int s, int backlog)
{
  802dc8:	55                   	push   %ebp
  802dc9:	89 e5                	mov    %esp,%ebp
  802dcb:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802dce:	8b 45 08             	mov    0x8(%ebp),%eax
  802dd1:	e8 c2 ff ff ff       	call   802d98 <fd2sockid>
  802dd6:	85 c0                	test   %eax,%eax
  802dd8:	78 0f                	js     802de9 <listen+0x21>
		return r;
	return nsipc_listen(r, backlog);
  802dda:	8b 55 0c             	mov    0xc(%ebp),%edx
  802ddd:	89 54 24 04          	mov    %edx,0x4(%esp)
  802de1:	89 04 24             	mov    %eax,(%esp)
  802de4:	e8 47 01 00 00       	call   802f30 <nsipc_listen>
}
  802de9:	c9                   	leave  
  802dea:	c3                   	ret    

00802deb <connect>:
		return 0;
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  802deb:	55                   	push   %ebp
  802dec:	89 e5                	mov    %esp,%ebp
  802dee:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802df1:	8b 45 08             	mov    0x8(%ebp),%eax
  802df4:	e8 9f ff ff ff       	call   802d98 <fd2sockid>
  802df9:	85 c0                	test   %eax,%eax
  802dfb:	78 16                	js     802e13 <connect+0x28>
		return r;
	return nsipc_connect(r, name, namelen);
  802dfd:	8b 55 10             	mov    0x10(%ebp),%edx
  802e00:	89 54 24 08          	mov    %edx,0x8(%esp)
  802e04:	8b 55 0c             	mov    0xc(%ebp),%edx
  802e07:	89 54 24 04          	mov    %edx,0x4(%esp)
  802e0b:	89 04 24             	mov    %eax,(%esp)
  802e0e:	e8 6e 02 00 00       	call   803081 <nsipc_connect>
}
  802e13:	c9                   	leave  
  802e14:	c3                   	ret    

00802e15 <shutdown>:
	return nsipc_bind(r, name, namelen);
}

int
shutdown(int s, int how)
{
  802e15:	55                   	push   %ebp
  802e16:	89 e5                	mov    %esp,%ebp
  802e18:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802e1b:	8b 45 08             	mov    0x8(%ebp),%eax
  802e1e:	e8 75 ff ff ff       	call   802d98 <fd2sockid>
  802e23:	85 c0                	test   %eax,%eax
  802e25:	78 0f                	js     802e36 <shutdown+0x21>
		return r;
	return nsipc_shutdown(r, how);
  802e27:	8b 55 0c             	mov    0xc(%ebp),%edx
  802e2a:	89 54 24 04          	mov    %edx,0x4(%esp)
  802e2e:	89 04 24             	mov    %eax,(%esp)
  802e31:	e8 36 01 00 00       	call   802f6c <nsipc_shutdown>
}
  802e36:	c9                   	leave  
  802e37:	c3                   	ret    

00802e38 <bind>:
	return alloc_sockfd(r);
}

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  802e38:	55                   	push   %ebp
  802e39:	89 e5                	mov    %esp,%ebp
  802e3b:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802e3e:	8b 45 08             	mov    0x8(%ebp),%eax
  802e41:	e8 52 ff ff ff       	call   802d98 <fd2sockid>
  802e46:	85 c0                	test   %eax,%eax
  802e48:	78 16                	js     802e60 <bind+0x28>
		return r;
	return nsipc_bind(r, name, namelen);
  802e4a:	8b 55 10             	mov    0x10(%ebp),%edx
  802e4d:	89 54 24 08          	mov    %edx,0x8(%esp)
  802e51:	8b 55 0c             	mov    0xc(%ebp),%edx
  802e54:	89 54 24 04          	mov    %edx,0x4(%esp)
  802e58:	89 04 24             	mov    %eax,(%esp)
  802e5b:	e8 60 02 00 00       	call   8030c0 <nsipc_bind>
}
  802e60:	c9                   	leave  
  802e61:	c3                   	ret    

00802e62 <accept>:
	return fd2num(sfd);
}

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  802e62:	55                   	push   %ebp
  802e63:	89 e5                	mov    %esp,%ebp
  802e65:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802e68:	8b 45 08             	mov    0x8(%ebp),%eax
  802e6b:	e8 28 ff ff ff       	call   802d98 <fd2sockid>
  802e70:	85 c0                	test   %eax,%eax
  802e72:	78 1f                	js     802e93 <accept+0x31>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  802e74:	8b 55 10             	mov    0x10(%ebp),%edx
  802e77:	89 54 24 08          	mov    %edx,0x8(%esp)
  802e7b:	8b 55 0c             	mov    0xc(%ebp),%edx
  802e7e:	89 54 24 04          	mov    %edx,0x4(%esp)
  802e82:	89 04 24             	mov    %eax,(%esp)
  802e85:	e8 75 02 00 00       	call   8030ff <nsipc_accept>
  802e8a:	85 c0                	test   %eax,%eax
  802e8c:	78 05                	js     802e93 <accept+0x31>
		return r;
	return alloc_sockfd(r);
  802e8e:	e8 64 fe ff ff       	call   802cf7 <alloc_sockfd>
}
  802e93:	c9                   	leave  
  802e94:	c3                   	ret    
	...

00802ea0 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  802ea0:	55                   	push   %ebp
  802ea1:	89 e5                	mov    %esp,%ebp
  802ea3:	53                   	push   %ebx
  802ea4:	83 ec 14             	sub    $0x14,%esp
  802ea7:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  802ea9:	83 3d 94 60 81 00 00 	cmpl   $0x0,0x816094
  802eb0:	75 11                	jne    802ec3 <nsipc+0x23>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  802eb2:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  802eb9:	e8 82 f3 ff ff       	call   802240 <ipc_find_env>
  802ebe:	a3 94 60 81 00       	mov    %eax,0x816094
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  802ec3:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  802eca:	00 
  802ecb:	c7 44 24 08 00 e0 b3 	movl   $0xb3e000,0x8(%esp)
  802ed2:	00 
  802ed3:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802ed7:	a1 94 60 81 00       	mov    0x816094,%eax
  802edc:	89 04 24             	mov    %eax,(%esp)
  802edf:	e8 a7 f3 ff ff       	call   80228b <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  802ee4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802eeb:	00 
  802eec:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802ef3:	00 
  802ef4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802efb:	e8 09 f4 ff ff       	call   802309 <ipc_recv>
}
  802f00:	83 c4 14             	add    $0x14,%esp
  802f03:	5b                   	pop    %ebx
  802f04:	5d                   	pop    %ebp
  802f05:	c3                   	ret    

00802f06 <nsipc_socket>:
	return nsipc(NSREQ_SEND);
}

int
nsipc_socket(int domain, int type, int protocol)
{
  802f06:	55                   	push   %ebp
  802f07:	89 e5                	mov    %esp,%ebp
  802f09:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  802f0c:	8b 45 08             	mov    0x8(%ebp),%eax
  802f0f:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.socket.req_type = type;
  802f14:	8b 45 0c             	mov    0xc(%ebp),%eax
  802f17:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	nsipcbuf.socket.req_protocol = protocol;
  802f1c:	8b 45 10             	mov    0x10(%ebp),%eax
  802f1f:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SOCKET);
  802f24:	b8 09 00 00 00       	mov    $0x9,%eax
  802f29:	e8 72 ff ff ff       	call   802ea0 <nsipc>
}
  802f2e:	c9                   	leave  
  802f2f:	c3                   	ret    

00802f30 <nsipc_listen>:
	return nsipc(NSREQ_CONNECT);
}

int
nsipc_listen(int s, int backlog)
{
  802f30:	55                   	push   %ebp
  802f31:	89 e5                	mov    %esp,%ebp
  802f33:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  802f36:	8b 45 08             	mov    0x8(%ebp),%eax
  802f39:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.listen.req_backlog = backlog;
  802f3e:	8b 45 0c             	mov    0xc(%ebp),%eax
  802f41:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_LISTEN);
  802f46:	b8 06 00 00 00       	mov    $0x6,%eax
  802f4b:	e8 50 ff ff ff       	call   802ea0 <nsipc>
}
  802f50:	c9                   	leave  
  802f51:	c3                   	ret    

00802f52 <nsipc_close>:
	return nsipc(NSREQ_SHUTDOWN);
}

int
nsipc_close(int s)
{
  802f52:	55                   	push   %ebp
  802f53:	89 e5                	mov    %esp,%ebp
  802f55:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  802f58:	8b 45 08             	mov    0x8(%ebp),%eax
  802f5b:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	return nsipc(NSREQ_CLOSE);
  802f60:	b8 04 00 00 00       	mov    $0x4,%eax
  802f65:	e8 36 ff ff ff       	call   802ea0 <nsipc>
}
  802f6a:	c9                   	leave  
  802f6b:	c3                   	ret    

00802f6c <nsipc_shutdown>:
	return nsipc(NSREQ_BIND);
}

int
nsipc_shutdown(int s, int how)
{
  802f6c:	55                   	push   %ebp
  802f6d:	89 e5                	mov    %esp,%ebp
  802f6f:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  802f72:	8b 45 08             	mov    0x8(%ebp),%eax
  802f75:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.shutdown.req_how = how;
  802f7a:	8b 45 0c             	mov    0xc(%ebp),%eax
  802f7d:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_SHUTDOWN);
  802f82:	b8 03 00 00 00       	mov    $0x3,%eax
  802f87:	e8 14 ff ff ff       	call   802ea0 <nsipc>
}
  802f8c:	c9                   	leave  
  802f8d:	c3                   	ret    

00802f8e <nsipc_send>:
	return r;
}

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  802f8e:	55                   	push   %ebp
  802f8f:	89 e5                	mov    %esp,%ebp
  802f91:	53                   	push   %ebx
  802f92:	83 ec 14             	sub    $0x14,%esp
  802f95:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  802f98:	8b 45 08             	mov    0x8(%ebp),%eax
  802f9b:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	assert(size < 1600);
  802fa0:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  802fa6:	7e 24                	jle    802fcc <nsipc_send+0x3e>
  802fa8:	c7 44 24 0c 14 2c 81 	movl   $0x812c14,0xc(%esp)
  802faf:	00 
  802fb0:	c7 44 24 08 20 2c 81 	movl   $0x812c20,0x8(%esp)
  802fb7:	00 
  802fb8:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
  802fbf:	00 
  802fc0:	c7 04 24 35 2c 81 00 	movl   $0x812c35,(%esp)
  802fc7:	e8 1c da ff ff       	call   8009e8 <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  802fcc:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802fd0:	8b 45 0c             	mov    0xc(%ebp),%eax
  802fd3:	89 44 24 04          	mov    %eax,0x4(%esp)
  802fd7:	c7 04 24 0c e0 b3 00 	movl   $0xb3e00c,(%esp)
  802fde:	e8 d2 e5 ff ff       	call   8015b5 <memmove>
	nsipcbuf.send.req_size = size;
  802fe3:	89 1d 04 e0 b3 00    	mov    %ebx,0xb3e004
	nsipcbuf.send.req_flags = flags;
  802fe9:	8b 45 14             	mov    0x14(%ebp),%eax
  802fec:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SEND);
  802ff1:	b8 08 00 00 00       	mov    $0x8,%eax
  802ff6:	e8 a5 fe ff ff       	call   802ea0 <nsipc>
}
  802ffb:	83 c4 14             	add    $0x14,%esp
  802ffe:	5b                   	pop    %ebx
  802fff:	5d                   	pop    %ebp
  803000:	c3                   	ret    

00803001 <nsipc_recv>:
	return nsipc(NSREQ_LISTEN);
}

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  803001:	55                   	push   %ebp
  803002:	89 e5                	mov    %esp,%ebp
  803004:	56                   	push   %esi
  803005:	53                   	push   %ebx
  803006:	83 ec 10             	sub    $0x10,%esp
  803009:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  80300c:	8b 45 08             	mov    0x8(%ebp),%eax
  80300f:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.recv.req_len = len;
  803014:	89 35 04 e0 b3 00    	mov    %esi,0xb3e004
	nsipcbuf.recv.req_flags = flags;
  80301a:	8b 45 14             	mov    0x14(%ebp),%eax
  80301d:	a3 08 e0 b3 00       	mov    %eax,0xb3e008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  803022:	b8 07 00 00 00       	mov    $0x7,%eax
  803027:	e8 74 fe ff ff       	call   802ea0 <nsipc>
  80302c:	89 c3                	mov    %eax,%ebx
  80302e:	85 c0                	test   %eax,%eax
  803030:	78 46                	js     803078 <nsipc_recv+0x77>
		assert(r < 1600 && r <= len);
  803032:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  803037:	7f 04                	jg     80303d <nsipc_recv+0x3c>
  803039:	39 c6                	cmp    %eax,%esi
  80303b:	7d 24                	jge    803061 <nsipc_recv+0x60>
  80303d:	c7 44 24 0c 41 2c 81 	movl   $0x812c41,0xc(%esp)
  803044:	00 
  803045:	c7 44 24 08 20 2c 81 	movl   $0x812c20,0x8(%esp)
  80304c:	00 
  80304d:	c7 44 24 04 61 00 00 	movl   $0x61,0x4(%esp)
  803054:	00 
  803055:	c7 04 24 35 2c 81 00 	movl   $0x812c35,(%esp)
  80305c:	e8 87 d9 ff ff       	call   8009e8 <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  803061:	89 44 24 08          	mov    %eax,0x8(%esp)
  803065:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  80306c:	00 
  80306d:	8b 45 0c             	mov    0xc(%ebp),%eax
  803070:	89 04 24             	mov    %eax,(%esp)
  803073:	e8 3d e5 ff ff       	call   8015b5 <memmove>
	}

	return r;
}
  803078:	89 d8                	mov    %ebx,%eax
  80307a:	83 c4 10             	add    $0x10,%esp
  80307d:	5b                   	pop    %ebx
  80307e:	5e                   	pop    %esi
  80307f:	5d                   	pop    %ebp
  803080:	c3                   	ret    

00803081 <nsipc_connect>:
	return nsipc(NSREQ_CLOSE);
}

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  803081:	55                   	push   %ebp
  803082:	89 e5                	mov    %esp,%ebp
  803084:	53                   	push   %ebx
  803085:	83 ec 14             	sub    $0x14,%esp
  803088:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  80308b:	8b 45 08             	mov    0x8(%ebp),%eax
  80308e:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  803093:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  803097:	8b 45 0c             	mov    0xc(%ebp),%eax
  80309a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80309e:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  8030a5:	e8 0b e5 ff ff       	call   8015b5 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  8030aa:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_CONNECT);
  8030b0:	b8 05 00 00 00       	mov    $0x5,%eax
  8030b5:	e8 e6 fd ff ff       	call   802ea0 <nsipc>
}
  8030ba:	83 c4 14             	add    $0x14,%esp
  8030bd:	5b                   	pop    %ebx
  8030be:	5d                   	pop    %ebp
  8030bf:	c3                   	ret    

008030c0 <nsipc_bind>:
	return r;
}

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  8030c0:	55                   	push   %ebp
  8030c1:	89 e5                	mov    %esp,%ebp
  8030c3:	53                   	push   %ebx
  8030c4:	83 ec 14             	sub    $0x14,%esp
  8030c7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  8030ca:	8b 45 08             	mov    0x8(%ebp),%eax
  8030cd:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  8030d2:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8030d6:	8b 45 0c             	mov    0xc(%ebp),%eax
  8030d9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8030dd:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  8030e4:	e8 cc e4 ff ff       	call   8015b5 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  8030e9:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_BIND);
  8030ef:	b8 02 00 00 00       	mov    $0x2,%eax
  8030f4:	e8 a7 fd ff ff       	call   802ea0 <nsipc>
}
  8030f9:	83 c4 14             	add    $0x14,%esp
  8030fc:	5b                   	pop    %ebx
  8030fd:	5d                   	pop    %ebp
  8030fe:	c3                   	ret    

008030ff <nsipc_accept>:
	return ipc_recv(NULL, NULL, NULL);
}

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  8030ff:	55                   	push   %ebp
  803100:	89 e5                	mov    %esp,%ebp
  803102:	83 ec 18             	sub    $0x18,%esp
  803105:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  803108:	89 75 fc             	mov    %esi,-0x4(%ebp)
	int r;

	nsipcbuf.accept.req_s = s;
  80310b:	8b 45 08             	mov    0x8(%ebp),%eax
  80310e:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  803113:	b8 01 00 00 00       	mov    $0x1,%eax
  803118:	e8 83 fd ff ff       	call   802ea0 <nsipc>
  80311d:	89 c3                	mov    %eax,%ebx
  80311f:	85 c0                	test   %eax,%eax
  803121:	78 25                	js     803148 <nsipc_accept+0x49>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  803123:	be 10 e0 b3 00       	mov    $0xb3e010,%esi
  803128:	8b 06                	mov    (%esi),%eax
  80312a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80312e:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  803135:	00 
  803136:	8b 45 0c             	mov    0xc(%ebp),%eax
  803139:	89 04 24             	mov    %eax,(%esp)
  80313c:	e8 74 e4 ff ff       	call   8015b5 <memmove>
		*addrlen = ret->ret_addrlen;
  803141:	8b 16                	mov    (%esi),%edx
  803143:	8b 45 10             	mov    0x10(%ebp),%eax
  803146:	89 10                	mov    %edx,(%eax)
	}
	return r;
}
  803148:	89 d8                	mov    %ebx,%eax
  80314a:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80314d:	8b 75 fc             	mov    -0x4(%ebp),%esi
  803150:	89 ec                	mov    %ebp,%esp
  803152:	5d                   	pop    %ebp
  803153:	c3                   	ret    
	...

00803160 <free>:
	return v;
}

void
free(void *v)
{
  803160:	55                   	push   %ebp
  803161:	89 e5                	mov    %esp,%ebp
  803163:	56                   	push   %esi
  803164:	53                   	push   %ebx
  803165:	83 ec 10             	sub    $0x10,%esp
  803168:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  80316b:	85 db                	test   %ebx,%ebx
  80316d:	0f 84 b9 00 00 00    	je     80322c <free+0xcc>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  803173:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  803179:	76 08                	jbe    803183 <free+0x23>
  80317b:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  803181:	76 24                	jbe    8031a7 <free+0x47>
  803183:	c7 44 24 0c 58 2c 81 	movl   $0x812c58,0xc(%esp)
  80318a:	00 
  80318b:	c7 44 24 08 20 2c 81 	movl   $0x812c20,0x8(%esp)
  803192:	00 
  803193:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  80319a:	00 
  80319b:	c7 04 24 86 2c 81 00 	movl   $0x812c86,(%esp)
  8031a2:	e8 41 d8 ff ff       	call   8009e8 <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  8031a7:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (vpt[PGNUM(c)] & PTE_CONTINUED) {
  8031ad:	be 00 00 40 ef       	mov    $0xef400000,%esi
  8031b2:	eb 4a                	jmp    8031fe <free+0x9e>
		sys_page_unmap(0, c);
  8031b4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8031b8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8031bf:	e8 5a ea ff ff       	call   801c1e <sys_page_unmap>
		c += PGSIZE;
  8031c4:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  8031ca:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  8031d0:	76 08                	jbe    8031da <free+0x7a>
  8031d2:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  8031d8:	76 24                	jbe    8031fe <free+0x9e>
  8031da:	c7 44 24 0c 93 2c 81 	movl   $0x812c93,0xc(%esp)
  8031e1:	00 
  8031e2:	c7 44 24 08 20 2c 81 	movl   $0x812c20,0x8(%esp)
  8031e9:	00 
  8031ea:	c7 44 24 04 81 00 00 	movl   $0x81,0x4(%esp)
  8031f1:	00 
  8031f2:	c7 04 24 86 2c 81 00 	movl   $0x812c86,(%esp)
  8031f9:	e8 ea d7 ff ff       	call   8009e8 <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (vpt[PGNUM(c)] & PTE_CONTINUED) {
  8031fe:	89 d8                	mov    %ebx,%eax
  803200:	c1 e8 0c             	shr    $0xc,%eax
  803203:	8b 04 86             	mov    (%esi,%eax,4),%eax
  803206:	f6 c4 04             	test   $0x4,%ah
  803209:	75 a9                	jne    8031b4 <free+0x54>

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
  80320b:	8d 93 fc 0f 00 00    	lea    0xffc(%ebx),%edx
	if (--(*ref) == 0)
  803211:	8b 02                	mov    (%edx),%eax
  803213:	83 e8 01             	sub    $0x1,%eax
  803216:	89 02                	mov    %eax,(%edx)
  803218:	85 c0                	test   %eax,%eax
  80321a:	75 10                	jne    80322c <free+0xcc>
		sys_page_unmap(0, c);
  80321c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  803220:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803227:	e8 f2 e9 ff ff       	call   801c1e <sys_page_unmap>
}
  80322c:	83 c4 10             	add    $0x10,%esp
  80322f:	5b                   	pop    %ebx
  803230:	5e                   	pop    %esi
  803231:	5d                   	pop    %ebp
  803232:	c3                   	ret    

00803233 <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  803233:	55                   	push   %ebp
  803234:	89 e5                	mov    %esp,%ebp
  803236:	57                   	push   %edi
  803237:	56                   	push   %esi
  803238:	53                   	push   %ebx
  803239:	83 ec 3c             	sub    $0x3c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  80323c:	83 3d 98 60 81 00 00 	cmpl   $0x0,0x816098
  803243:	75 0a                	jne    80324f <malloc+0x1c>
		mptr = mbegin;
  803245:	c7 05 98 60 81 00 00 	movl   $0x8000000,0x816098
  80324c:	00 00 08 

	n = ROUNDUP(n, 4);
  80324f:	8b 45 08             	mov    0x8(%ebp),%eax
  803252:	83 c0 03             	add    $0x3,%eax
  803255:	83 e0 fc             	and    $0xfffffffc,%eax
  803258:	89 45 d8             	mov    %eax,-0x28(%ebp)

	if (n >= MAXMALLOC)
  80325b:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  803260:	0f 87 97 01 00 00    	ja     8033fd <malloc+0x1ca>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  803266:	a1 98 60 81 00       	mov    0x816098,%eax
  80326b:	89 c2                	mov    %eax,%edx
  80326d:	a9 ff 0f 00 00       	test   $0xfff,%eax
  803272:	74 4d                	je     8032c1 <malloc+0x8e>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  803274:	89 c3                	mov    %eax,%ebx
  803276:	c1 eb 0c             	shr    $0xc,%ebx
  803279:	8b 75 d8             	mov    -0x28(%ebp),%esi
  80327c:	8d 4c 30 03          	lea    0x3(%eax,%esi,1),%ecx
  803280:	c1 e9 0c             	shr    $0xc,%ecx
  803283:	39 cb                	cmp    %ecx,%ebx
  803285:	75 1e                	jne    8032a5 <malloc+0x72>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  803287:	81 c2 ff 0f 00 00    	add    $0xfff,%edx
  80328d:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  803293:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  803297:	8d 14 30             	lea    (%eax,%esi,1),%edx
  80329a:	89 15 98 60 81 00    	mov    %edx,0x816098
			return v;
  8032a0:	e9 5d 01 00 00       	jmp    803402 <malloc+0x1cf>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  8032a5:	89 04 24             	mov    %eax,(%esp)
  8032a8:	e8 b3 fe ff ff       	call   803160 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  8032ad:	a1 98 60 81 00       	mov    0x816098,%eax
  8032b2:	05 00 10 00 00       	add    $0x1000,%eax
  8032b7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  8032bc:	a3 98 60 81 00       	mov    %eax,0x816098
  8032c1:	8b 3d 98 60 81 00    	mov    0x816098,%edi
  8032c7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			return 0;
	return 1;
}

void*
malloc(size_t n)
  8032ce:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8032d1:	83 c0 04             	add    $0x4,%eax
  8032d4:	89 45 dc             	mov    %eax,-0x24(%ebp)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[PGNUM(va)] & PTE_P)))
  8032d7:	bb 00 d0 7b ef       	mov    $0xef7bd000,%ebx
  8032dc:	be 00 00 40 ef       	mov    $0xef400000,%esi
			return 0;
	return 1;
}

void*
malloc(size_t n)
  8032e1:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  8032e4:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  8032e7:	8d 0c 0f             	lea    (%edi,%ecx,1),%ecx
  8032ea:	89 7d e4             	mov    %edi,-0x1c(%ebp)
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8032ed:	39 cf                	cmp    %ecx,%edi
  8032ef:	0f 83 d7 00 00 00    	jae    8033cc <malloc+0x199>
		if (va >= (uintptr_t) mend
  8032f5:	89 f8                	mov    %edi,%eax
  8032f7:	81 ff ff ff ff 0f    	cmp    $0xfffffff,%edi
  8032fd:	76 09                	jbe    803308 <malloc+0xd5>
  8032ff:	eb 38                	jmp    803339 <malloc+0x106>
  803301:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  803306:	77 31                	ja     803339 <malloc+0x106>
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[PGNUM(va)] & PTE_P)))
  803308:	89 c2                	mov    %eax,%edx
  80330a:	c1 ea 16             	shr    $0x16,%edx
  80330d:	8b 14 93             	mov    (%ebx,%edx,4),%edx
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  803310:	f6 c2 01             	test   $0x1,%dl
  803313:	74 0d                	je     803322 <malloc+0xef>
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[PGNUM(va)] & PTE_P)))
  803315:	89 c2                	mov    %eax,%edx
  803317:	c1 ea 0c             	shr    $0xc,%edx
  80331a:	8b 14 96             	mov    (%esi,%edx,4),%edx
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  80331d:	f6 c2 01             	test   $0x1,%dl
  803320:	75 17                	jne    803339 <malloc+0x106>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  803322:	05 00 10 00 00       	add    $0x1000,%eax
  803327:	39 c8                	cmp    %ecx,%eax
  803329:	72 d6                	jb     803301 <malloc+0xce>
  80332b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80332e:	89 35 98 60 81 00    	mov    %esi,0x816098
  803334:	e9 9b 00 00 00       	jmp    8033d4 <malloc+0x1a1>
  803339:	81 c7 00 10 00 00    	add    $0x1000,%edi
  80333f:	81 c1 00 10 00 00    	add    $0x1000,%ecx
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  803345:	81 ff 00 00 00 10    	cmp    $0x10000000,%edi
  80334b:	75 9d                	jne    8032ea <malloc+0xb7>
			mptr = mbegin;
			if (++nwrap == 2)
  80334d:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  803351:	83 7d e0 02          	cmpl   $0x2,-0x20(%ebp)
  803355:	74 07                	je     80335e <malloc+0x12b>
  803357:	bf 00 00 00 08       	mov    $0x8000000,%edi
  80335c:	eb 83                	jmp    8032e1 <malloc+0xae>
  80335e:	c7 05 98 60 81 00 00 	movl   $0x8000000,0x816098
  803365:	00 00 08 
  803368:	b8 00 00 00 00       	mov    $0x0,%eax
  80336d:	e9 90 00 00 00       	jmp    803402 <malloc+0x1cf>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  803372:	8d b3 00 10 00 00    	lea    0x1000(%ebx),%esi
  803378:	39 fe                	cmp    %edi,%esi
  80337a:	19 c0                	sbb    %eax,%eax
  80337c:	25 00 04 00 00       	and    $0x400,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  803381:	83 c8 07             	or     $0x7,%eax
  803384:	89 44 24 08          	mov    %eax,0x8(%esp)
  803388:	03 15 98 60 81 00    	add    0x816098,%edx
  80338e:	89 54 24 04          	mov    %edx,0x4(%esp)
  803392:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803399:	e8 5a e9 ff ff       	call   801cf8 <sys_page_alloc>
  80339e:	85 c0                	test   %eax,%eax
  8033a0:	78 04                	js     8033a6 <malloc+0x173>
  8033a2:	89 f3                	mov    %esi,%ebx
  8033a4:	eb 36                	jmp    8033dc <malloc+0x1a9>
			for (; i >= 0; i -= PGSIZE)
  8033a6:	85 db                	test   %ebx,%ebx
  8033a8:	78 53                	js     8033fd <malloc+0x1ca>
				sys_page_unmap(0, mptr + i);
  8033aa:	89 d8                	mov    %ebx,%eax
  8033ac:	03 05 98 60 81 00    	add    0x816098,%eax
  8033b2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8033b6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8033bd:	e8 5c e8 ff ff       	call   801c1e <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  8033c2:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  8033c8:	79 e0                	jns    8033aa <malloc+0x177>
  8033ca:	eb 31                	jmp    8033fd <malloc+0x1ca>
  8033cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8033cf:	a3 98 60 81 00       	mov    %eax,0x816098
  8033d4:	bb 00 00 00 00       	mov    $0x0,%ebx
  8033d9:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  8033dc:	89 da                	mov    %ebx,%edx
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  8033de:	39 fb                	cmp    %edi,%ebx
  8033e0:	72 90                	jb     803372 <malloc+0x13f>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  8033e2:	a1 98 60 81 00       	mov    0x816098,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  8033e7:	c7 44 18 fc 02 00 00 	movl   $0x2,-0x4(%eax,%ebx,1)
  8033ee:	00 
	v = mptr;
	mptr += n;
  8033ef:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  8033f2:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  8033f5:	89 15 98 60 81 00    	mov    %edx,0x816098
	return v;
  8033fb:	eb 05                	jmp    803402 <malloc+0x1cf>
  8033fd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803402:	83 c4 3c             	add    $0x3c,%esp
  803405:	5b                   	pop    %ebx
  803406:	5e                   	pop    %esi
  803407:	5f                   	pop    %edi
  803408:	5d                   	pop    %ebp
  803409:	c3                   	ret    
	...

0080340c <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  80340c:	55                   	push   %ebp
  80340d:	89 e5                	mov    %esp,%ebp
  80340f:	83 ec 18             	sub    $0x18,%esp
	int r;

	if (_pgfault_handler == 0) {
  803412:	83 3d 00 f0 b3 00 00 	cmpl   $0x0,0xb3f000
  803419:	75 30                	jne    80344b <set_pgfault_handler+0x3f>
		// First time through!
		// LAB 4: Your code here.
                uint32_t ret = sys_page_alloc(0,(void*)(UXSTACKTOP-PGSIZE),PTE_P|PTE_U|PTE_W);
  80341b:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  803422:	00 
  803423:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  80342a:	ee 
  80342b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803432:	e8 c1 e8 ff ff       	call   801cf8 <sys_page_alloc>
                if(ret < 0)
                  return;
                sys_env_set_pgfault_upcall(0,_pgfault_upcall);
  803437:	c7 44 24 04 58 34 80 	movl   $0x803458,0x4(%esp)
  80343e:	00 
  80343f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803446:	e8 8f e6 ff ff       	call   801ada <sys_env_set_pgfault_upcall>
		//panic("set_pgfault_handler not implemented");
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  80344b:	8b 45 08             	mov    0x8(%ebp),%eax
  80344e:	a3 00 f0 b3 00       	mov    %eax,0xb3f000
}
  803453:	c9                   	leave  
  803454:	c3                   	ret    
  803455:	00 00                	add    %al,(%eax)
	...

00803458 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  803458:	54                   	push   %esp
	movl _pgfault_handler, %eax
  803459:	a1 00 f0 b3 00       	mov    0xb3f000,%eax
	call *%eax
  80345e:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  803460:	83 c4 04             	add    $0x4,%esp
	// registers are available for intermediate calculations.  You
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
        movl 0x28(%esp),%eax
  803463:	8b 44 24 28          	mov    0x28(%esp),%eax
        movl 0x30(%esp),%ecx
  803467:	8b 4c 24 30          	mov    0x30(%esp),%ecx
        subl $0x4,%ecx
  80346b:	83 e9 04             	sub    $0x4,%ecx
        movl %eax,(%ecx)
  80346e:	89 01                	mov    %eax,(%ecx)
        movl %ecx,0x30(%esp)
  803470:	89 4c 24 30          	mov    %ecx,0x30(%esp)
	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
        addl $0x8,%esp
  803474:	83 c4 08             	add    $0x8,%esp
        popal
  803477:	61                   	popa   
        addl $0x4,%esp
  803478:	83 c4 04             	add    $0x4,%esp
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
        popfl
  80347b:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
        popl %esp
  80347c:	5c                   	pop    %esp
        //subl $0x4,%esp   //CAN'T SUB HERE BECAUSE OF EFLAGS
	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
        ret
  80347d:	c3                   	ret    
	...

00803480 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  803480:	55                   	push   %ebp
  803481:	89 e5                	mov    %esp,%ebp
	pte_t pte;

	if (!(vpd[PDX(v)] & PTE_P))
  803483:	8b 45 08             	mov    0x8(%ebp),%eax
  803486:	89 c2                	mov    %eax,%edx
  803488:	c1 ea 16             	shr    $0x16,%edx
  80348b:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  803492:	f6 c2 01             	test   $0x1,%dl
  803495:	74 20                	je     8034b7 <pageref+0x37>
		return 0;
	pte = vpt[PGNUM(v)];
  803497:	c1 e8 0c             	shr    $0xc,%eax
  80349a:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
	if (!(pte & PTE_P))
  8034a1:	a8 01                	test   $0x1,%al
  8034a3:	74 12                	je     8034b7 <pageref+0x37>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  8034a5:	c1 e8 0c             	shr    $0xc,%eax
  8034a8:	ba 00 00 00 ef       	mov    $0xef000000,%edx
  8034ad:	0f b7 44 c2 04       	movzwl 0x4(%edx,%eax,8),%eax
  8034b2:	0f b7 c0             	movzwl %ax,%eax
  8034b5:	eb 05                	jmp    8034bc <pageref+0x3c>
  8034b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8034bc:	5d                   	pop    %ebp
  8034bd:	c3                   	ret    
	...

008034c0 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  8034c0:	55                   	push   %ebp
  8034c1:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  8034c3:	83 f8 1f             	cmp    $0x1f,%eax
  8034c6:	76 11                	jbe    8034d9 <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  8034c8:	c7 05 20 c2 b3 00 09 	movl   $0x9,0xb3c220
  8034cf:	00 00 00 
  8034d2:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  8034d7:	eb 1e                	jmp    8034f7 <get_socket+0x37>
  }

  sock = &sockets[s];
  8034d9:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8034dc:	8d 04 85 a0 60 81 00 	lea    0x8160a0(,%eax,4),%eax

  if (!sock->conn) {
  8034e3:	83 38 00             	cmpl   $0x0,(%eax)
  8034e6:	75 0f                	jne    8034f7 <get_socket+0x37>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  8034e8:	c7 05 20 c2 b3 00 09 	movl   $0x9,0xb3c220
  8034ef:	00 00 00 
  8034f2:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  }

  return sock;
}
  8034f7:	5d                   	pop    %ebp
  8034f8:	c3                   	ret    

008034f9 <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  8034f9:	55                   	push   %ebp
  8034fa:	89 e5                	mov    %esp,%ebp
  8034fc:	56                   	push   %esi
  8034fd:	53                   	push   %ebx
  8034fe:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  803501:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  803504:	8b 45 08             	mov    0x8(%ebp),%eax
  803507:	e8 b4 ff ff ff       	call   8034c0 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  80350c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  803511:	85 c0                	test   %eax,%eax
  803513:	0f 84 a6 00 00 00    	je     8035bf <lwip_ioctl+0xc6>
    return -1;

  switch (cmd) {
  803519:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  80351f:	74 59                	je     80357a <lwip_ioctl+0x81>
  803521:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  803527:	0f 85 7c 00 00 00    	jne    8035a9 <lwip_ioctl+0xb0>
  case FIONREAD:
    if (!argp) {
  80352d:	85 f6                	test   %esi,%esi
  80352f:	90                   	nop
  803530:	75 13                	jne    803545 <lwip_ioctl+0x4c>
      sock_set_errno(sock, EINVAL);
  803532:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  803539:	c7 05 20 c2 b3 00 16 	movl   $0x16,0xb3c220
  803540:	00 00 00 
      return -1;
  803543:	eb 7a                	jmp    8035bf <lwip_ioctl+0xc6>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  803545:	8b 10                	mov    (%eax),%edx
  803547:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  80354b:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  80354e:	8b 48 04             	mov    0x4(%eax),%ecx
  803551:	85 c9                	test   %ecx,%ecx
  803553:	74 0d                	je     803562 <lwip_ioctl+0x69>
      buflen = netbuf_len(sock->lastdata);
  803555:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  803557:	66 03 51 08          	add    0x8(%ecx),%dx
  80355b:	66 2b 50 08          	sub    0x8(%eax),%dx
  80355f:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  803562:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  803569:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  803570:	00 00 00 
  803573:	ba 00 00 00 00       	mov    $0x0,%edx
    return 0;
  803578:	eb 45                	jmp    8035bf <lwip_ioctl+0xc6>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  80357a:	85 f6                	test   %esi,%esi
  80357c:	74 0d                	je     80358b <lwip_ioctl+0x92>
  80357e:	83 3e 00             	cmpl   $0x0,(%esi)
  803581:	74 08                	je     80358b <lwip_ioctl+0x92>
      sock->flags |= O_NONBLOCK;
  803583:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
    return 0;

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  803589:	eb 06                	jmp    803591 <lwip_ioctl+0x98>
      sock->flags |= O_NONBLOCK;
    else
      sock->flags &= ~O_NONBLOCK;
  80358b:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  803591:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  803598:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  80359f:	00 00 00 
  8035a2:	ba 00 00 00 00       	mov    $0x0,%edx
    return 0;
  8035a7:	eb 16                	jmp    8035bf <lwip_ioctl+0xc6>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  8035a9:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  8035b0:	c7 05 20 c2 b3 00 26 	movl   $0x26,0xb3c220
  8035b7:	00 00 00 
  8035ba:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    return -1;
  } /* switch (cmd) */
}
  8035bf:	89 d0                	mov    %edx,%eax
  8035c1:	5b                   	pop    %ebx
  8035c2:	5e                   	pop    %esi
  8035c3:	5d                   	pop    %ebp
  8035c4:	c3                   	ret    

008035c5 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  8035c5:	55                   	push   %ebp
  8035c6:	89 e5                	mov    %esp,%ebp
  8035c8:	83 ec 48             	sub    $0x48,%esp
  8035cb:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8035ce:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8035d1:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8035d4:	8b 75 0c             	mov    0xc(%ebp),%esi
  8035d7:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  8035da:	8b 45 08             	mov    0x8(%ebp),%eax
  8035dd:	e8 de fe ff ff       	call   8034c0 <get_socket>
  8035e2:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  8035e4:	85 c0                	test   %eax,%eax
  8035e6:	0f 84 5a 01 00 00    	je     803746 <lwip_setsockopt+0x181>
    return -1;

  if (NULL == optval) {
  8035ec:	85 ff                	test   %edi,%edi
  8035ee:	75 1b                	jne    80360b <lwip_setsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  8035f0:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  8035f7:	c7 05 20 c2 b3 00 0e 	movl   $0xe,0xb3c220
  8035fe:	00 00 00 
  803601:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  803606:	e9 47 01 00 00       	jmp    803752 <lwip_setsockopt+0x18d>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  80360b:	83 fe 06             	cmp    $0x6,%esi
  80360e:	0f 84 8e 00 00 00    	je     8036a2 <lwip_setsockopt+0xdd>
  803614:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  80361a:	74 11                	je     80362d <lwip_setsockopt+0x68>
  80361c:	85 f6                	test   %esi,%esi
  80361e:	66 90                	xchg   %ax,%ax
  803620:	74 66                	je     803688 <lwip_setsockopt+0xc3>
  803622:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  803628:	e9 a8 00 00 00       	jmp    8036d5 <lwip_setsockopt+0x110>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80362d:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  803631:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  803638:	74 1c                	je     803656 <lwip_setsockopt+0x91>
  80363a:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  803641:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  803648:	74 1b                	je     803665 <lwip_setsockopt+0xa0>
  80364a:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  80364e:	66 90                	xchg   %ax,%ax
  803650:	0f 85 7f 00 00 00    	jne    8036d5 <lwip_setsockopt+0x110>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  803656:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80365a:	0f 86 ff 00 00 00    	jbe    80375f <lwip_setsockopt+0x19a>
  803660:	e9 88 00 00 00       	jmp    8036ed <lwip_setsockopt+0x128>
        err = EINVAL;
      }
      break;
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  803665:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  803669:	19 c0                	sbb    %eax,%eax
  80366b:	83 e0 16             	and    $0x16,%eax
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  80366e:	8b 13                	mov    (%ebx),%edx
  803670:	83 3a 20             	cmpl   $0x20,(%edx)
  803673:	0f 85 f0 00 00 00    	jne    803769 <lwip_setsockopt+0x1a4>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  803679:	8b 52 08             	mov    0x8(%edx),%edx
  80367c:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  803680:	0f 85 e3 00 00 00    	jne    803769 <lwip_setsockopt+0x1a4>
  803686:	eb 52                	jmp    8036da <lwip_setsockopt+0x115>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  803688:	8b 45 10             	mov    0x10(%ebp),%eax
  80368b:	83 e8 01             	sub    $0x1,%eax
  80368e:	83 f8 01             	cmp    $0x1,%eax
  803691:	77 42                	ja     8036d5 <lwip_setsockopt+0x110>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  803693:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  803697:	0f 86 c2 00 00 00    	jbe    80375f <lwip_setsockopt+0x19a>
  80369d:	8d 76 00             	lea    0x0(%esi),%esi
  8036a0:	eb 4b                	jmp    8036ed <lwip_setsockopt+0x128>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  8036a2:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  8036a6:	66 90                	xchg   %ax,%ax
  8036a8:	0f 86 b1 00 00 00    	jbe    80375f <lwip_setsockopt+0x19a>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  8036ae:	8b 00                	mov    (%eax),%eax
  8036b0:	83 38 10             	cmpl   $0x10,(%eax)
  8036b3:	0f 85 94 00 00 00    	jne    80374d <lwip_setsockopt+0x188>
  8036b9:	8b 55 10             	mov    0x10(%ebp),%edx
  8036bc:	83 ea 01             	sub    $0x1,%edx
  8036bf:	b8 5c 00 00 00       	mov    $0x5c,%eax
  8036c4:	83 fa 01             	cmp    $0x1,%edx
  8036c7:	77 15                	ja     8036de <lwip_setsockopt+0x119>
  8036c9:	8b 55 10             	mov    0x10(%ebp),%edx
  8036cc:	8b 04 95 d8 2d 81 00 	mov    0x812dd8(,%edx,4),%eax
  8036d3:	eb 05                	jmp    8036da <lwip_setsockopt+0x115>
  8036d5:	b8 5c 00 00 00       	mov    $0x5c,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  8036da:	85 c0                	test   %eax,%eax
  8036dc:	74 0f                	je     8036ed <lwip_setsockopt+0x128>
    sock_set_errno(sock, err);
  8036de:	89 43 10             	mov    %eax,0x10(%ebx)
  8036e1:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  8036e6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  8036eb:	eb 65                	jmp    803752 <lwip_setsockopt+0x18d>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  8036ed:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  8036f0:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  8036f3:	8b 45 10             	mov    0x10(%ebp),%eax
  8036f6:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  8036f9:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  8036fc:	8d 45 18             	lea    0x18(%ebp),%eax
  8036ff:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  803702:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  803706:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80370d:	00 
  80370e:	8d 45 cc             	lea    -0x34(%ebp),%eax
  803711:	89 44 24 04          	mov    %eax,0x4(%esp)
  803715:	c7 04 24 62 39 80 00 	movl   $0x803962,(%esp)
  80371c:	e8 15 1b 00 00       	call   805236 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  803721:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803728:	00 
  803729:	8b 03                	mov    (%ebx),%eax
  80372b:	8b 40 10             	mov    0x10(%eax),%eax
  80372e:	89 04 24             	mov    %eax,(%esp)
  803731:	e8 30 a1 00 00       	call   80d866 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  803736:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  80373a:	89 43 10             	mov    %eax,0x10(%ebx)
  80373d:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  return err ? -1 : 0;
  803742:	85 c0                	test   %eax,%eax
  803744:	74 07                	je     80374d <lwip_setsockopt+0x188>
  803746:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80374b:	eb 05                	jmp    803752 <lwip_setsockopt+0x18d>
  80374d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803752:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  803755:	8b 75 f8             	mov    -0x8(%ebp),%esi
  803758:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80375b:	89 ec                	mov    %ebp,%esp
  80375d:	5d                   	pop    %ebp
  80375e:	c3                   	ret    
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
  80375f:	b8 16 00 00 00       	mov    $0x16,%eax
  803764:	e9 75 ff ff ff       	jmp    8036de <lwip_setsockopt+0x119>
  803769:	b8 61 00 00 00       	mov    $0x61,%eax
  80376e:	e9 6b ff ff ff       	jmp    8036de <lwip_setsockopt+0x119>

00803773 <lwip_getsockopt>:
  return lwip_getaddrname(s, name, namelen, 1);
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  803773:	55                   	push   %ebp
  803774:	89 e5                	mov    %esp,%ebp
  803776:	57                   	push   %edi
  803777:	56                   	push   %esi
  803778:	53                   	push   %ebx
  803779:	83 ec 3c             	sub    $0x3c,%esp
  80377c:	8b 75 0c             	mov    0xc(%ebp),%esi
  80377f:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  803782:	8b 45 08             	mov    0x8(%ebp),%eax
  803785:	e8 36 fd ff ff       	call   8034c0 <get_socket>
  80378a:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  80378c:	85 c0                	test   %eax,%eax
  80378e:	0f 84 a6 01 00 00    	je     80393a <lwip_getsockopt+0x1c7>
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  803794:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  803798:	74 04                	je     80379e <lwip_getsockopt+0x2b>
  80379a:	85 ff                	test   %edi,%edi
  80379c:	75 1b                	jne    8037b9 <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  80379e:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  8037a5:	c7 05 20 c2 b3 00 0e 	movl   $0xe,0xb3c220
  8037ac:	00 00 00 
  8037af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  8037b4:	e9 8d 01 00 00       	jmp    803946 <lwip_getsockopt+0x1d3>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  8037b9:	83 fe 06             	cmp    $0x6,%esi
  8037bc:	0f 84 c6 00 00 00    	je     803888 <lwip_getsockopt+0x115>
  8037c2:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  8037c8:	74 13                	je     8037dd <lwip_getsockopt+0x6a>
  8037ca:	85 f6                	test   %esi,%esi
  8037cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8037d0:	0f 84 99 00 00 00    	je     80386f <lwip_getsockopt+0xfc>
  8037d6:	66 90                	xchg   %ax,%ax
  8037d8:	e9 e5 00 00 00       	jmp    8038c2 <lwip_getsockopt+0x14f>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8037dd:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8037e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8037e8:	74 50                	je     80383a <lwip_getsockopt+0xc7>
  8037ea:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8037ee:	66 90                	xchg   %ax,%ax
  8037f0:	7f 18                	jg     80380a <lwip_getsockopt+0x97>
  8037f2:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  8037f6:	74 42                	je     80383a <lwip_getsockopt+0xc7>
  8037f8:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  8037fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803800:	0f 85 bc 00 00 00    	jne    8038c2 <lwip_getsockopt+0x14f>
  803806:	66 90                	xchg   %ax,%ax
  803808:	eb 30                	jmp    80383a <lwip_getsockopt+0xc7>
  80380a:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  803811:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  803818:	0f 8c a4 00 00 00    	jl     8038c2 <lwip_getsockopt+0x14f>
  80381e:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  803825:	8d 76 00             	lea    0x0(%esi),%esi
  803828:	7e 10                	jle    80383a <lwip_getsockopt+0xc7>
  80382a:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  803831:	0f 85 8b 00 00 00    	jne    8038c2 <lwip_getsockopt+0x14f>
  803837:	90                   	nop
  803838:	eb 13                	jmp    80384d <lwip_getsockopt+0xda>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  80383a:	83 3f 03             	cmpl   $0x3,(%edi)
  80383d:	8d 76 00             	lea    0x0(%esi),%esi
  803840:	0f 86 08 01 00 00    	jbe    80394e <lwip_getsockopt+0x1db>
  803846:	66 90                	xchg   %ax,%ax
  803848:	e9 90 00 00 00       	jmp    8038dd <lwip_getsockopt+0x16a>
        err = EINVAL;
      }
      break;

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  80384d:	83 3f 04             	cmpl   $0x4,(%edi)
  803850:	19 c0                	sbb    %eax,%eax
  803852:	83 e0 16             	and    $0x16,%eax
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  803855:	8b 13                	mov    (%ebx),%edx
  803857:	83 3a 20             	cmpl   $0x20,(%edx)
  80385a:	0f 85 f8 00 00 00    	jne    803958 <lwip_getsockopt+0x1e5>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  803860:	8b 52 08             	mov    0x8(%edx),%edx
  803863:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  803867:	0f 85 eb 00 00 00    	jne    803958 <lwip_getsockopt+0x1e5>
  80386d:	eb 58                	jmp    8038c7 <lwip_getsockopt+0x154>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  80386f:	8b 45 10             	mov    0x10(%ebp),%eax
  803872:	83 e8 01             	sub    $0x1,%eax
  803875:	83 f8 01             	cmp    $0x1,%eax
  803878:	77 48                	ja     8038c2 <lwip_getsockopt+0x14f>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  80387a:	83 3f 03             	cmpl   $0x3,(%edi)
  80387d:	8d 76 00             	lea    0x0(%esi),%esi
  803880:	0f 86 c8 00 00 00    	jbe    80394e <lwip_getsockopt+0x1db>
  803886:	eb 55                	jmp    8038dd <lwip_getsockopt+0x16a>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  803888:	83 3f 03             	cmpl   $0x3,(%edi)
  80388b:	90                   	nop
  80388c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803890:	0f 86 b8 00 00 00    	jbe    80394e <lwip_getsockopt+0x1db>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  803896:	8b 00                	mov    (%eax),%eax
  803898:	83 38 10             	cmpl   $0x10,(%eax)
  80389b:	90                   	nop
  80389c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8038a0:	0f 85 9b 00 00 00    	jne    803941 <lwip_getsockopt+0x1ce>
  8038a6:	8b 55 10             	mov    0x10(%ebp),%edx
  8038a9:	83 ea 01             	sub    $0x1,%edx
  8038ac:	b8 5c 00 00 00       	mov    $0x5c,%eax
  8038b1:	83 fa 01             	cmp    $0x1,%edx
  8038b4:	77 15                	ja     8038cb <lwip_getsockopt+0x158>
  8038b6:	8b 55 10             	mov    0x10(%ebp),%edx
  8038b9:	0f b6 82 e3 2d 81 00 	movzbl 0x812de3(%edx),%eax
  8038c0:	eb 05                	jmp    8038c7 <lwip_getsockopt+0x154>
  8038c2:	b8 5c 00 00 00       	mov    $0x5c,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  8038c7:	84 c0                	test   %al,%al
  8038c9:	74 12                	je     8038dd <lwip_getsockopt+0x16a>
    sock_set_errno(sock, err);
  8038cb:	0f be c0             	movsbl %al,%eax
  8038ce:	89 43 10             	mov    %eax,0x10(%ebx)
  8038d1:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  8038d6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  8038db:	eb 69                	jmp    803946 <lwip_getsockopt+0x1d3>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  8038dd:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  8038e0:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  8038e3:	8b 45 10             	mov    0x10(%ebp),%eax
  8038e6:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  8038e9:	8b 55 14             	mov    0x14(%ebp),%edx
  8038ec:	89 55 dc             	mov    %edx,-0x24(%ebp)
  data.optlen = optlen;
  8038ef:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  8038f2:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  8038f6:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  8038fd:	00 
  8038fe:	8d 45 cc             	lea    -0x34(%ebp),%eax
  803901:	89 44 24 04          	mov    %eax,0x4(%esp)
  803905:	c7 04 24 78 3a 80 00 	movl   $0x803a78,(%esp)
  80390c:	e8 25 19 00 00       	call   805236 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  803911:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803918:	00 
  803919:	8b 03                	mov    (%ebx),%eax
  80391b:	8b 40 10             	mov    0x10(%eax),%eax
  80391e:	89 04 24             	mov    %eax,(%esp)
  803921:	e8 40 9f 00 00       	call   80d866 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  803926:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  80392a:	0f be d0             	movsbl %al,%edx
  80392d:	89 53 10             	mov    %edx,0x10(%ebx)
  803930:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  return err ? -1 : 0;
  803936:	84 c0                	test   %al,%al
  803938:	74 07                	je     803941 <lwip_getsockopt+0x1ce>
  80393a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80393f:	eb 05                	jmp    803946 <lwip_getsockopt+0x1d3>
  803941:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803946:	83 c4 3c             	add    $0x3c,%esp
  803949:	5b                   	pop    %ebx
  80394a:	5e                   	pop    %esi
  80394b:	5f                   	pop    %edi
  80394c:	5d                   	pop    %ebp
  80394d:	c3                   	ret    
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
  80394e:	b8 16 00 00 00       	mov    $0x16,%eax
  803953:	e9 73 ff ff ff       	jmp    8038cb <lwip_getsockopt+0x158>
  803958:	b8 61 00 00 00       	mov    $0x61,%eax
  80395d:	e9 69 ff ff ff       	jmp    8038cb <lwip_getsockopt+0x158>

00803962 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  803962:	55                   	push   %ebp
  803963:	89 e5                	mov    %esp,%ebp
  803965:	53                   	push   %ebx
  803966:	83 ec 14             	sub    $0x14,%esp
  803969:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  80396c:	85 c0                	test   %eax,%eax
  80396e:	75 1c                	jne    80398c <lwip_setsockopt_internal+0x2a>
  803970:	c7 44 24 08 ab 2c 81 	movl   $0x812cab,0x8(%esp)
  803977:	00 
  803978:	c7 44 24 04 ae 06 00 	movl   $0x6ae,0x4(%esp)
  80397f:	00 
  803980:	c7 04 24 b7 2c 81 00 	movl   $0x812cb7,(%esp)
  803987:	e8 5c d0 ff ff       	call   8009e8 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  80398c:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  80398e:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  803991:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  803994:	8b 40 08             	mov    0x8(%eax),%eax
  803997:	83 f8 06             	cmp    $0x6,%eax
  80399a:	0f 84 8a 00 00 00    	je     803a2a <lwip_setsockopt_internal+0xc8>
  8039a0:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  8039a5:	74 0e                	je     8039b5 <lwip_setsockopt_internal+0x53>
  8039a7:	85 c0                	test   %eax,%eax
  8039a9:	74 5d                	je     803a08 <lwip_setsockopt_internal+0xa6>
  8039ab:	90                   	nop
  8039ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8039b0:	e9 b0 00 00 00       	jmp    803a65 <lwip_setsockopt_internal+0x103>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8039b5:	83 f9 20             	cmp    $0x20,%ecx
  8039b8:	74 11                	je     8039cb <lwip_setsockopt_internal+0x69>
  8039ba:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  8039c0:	74 2b                	je     8039ed <lwip_setsockopt_internal+0x8b>
  8039c2:	83 f9 08             	cmp    $0x8,%ecx
  8039c5:	0f 85 9a 00 00 00    	jne    803a65 <lwip_setsockopt_internal+0x103>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  8039cb:	83 3b 00             	cmpl   $0x0,(%ebx)
  8039ce:	66 90                	xchg   %ax,%ax
  8039d0:	74 0e                	je     8039e0 <lwip_setsockopt_internal+0x7e>
        sock->conn->pcb.ip->so_options |= optname;
  8039d2:	8b 02                	mov    (%edx),%eax
  8039d4:	8b 40 08             	mov    0x8(%eax),%eax
  8039d7:	66 09 48 08          	or     %cx,0x8(%eax)
  8039db:	e9 85 00 00 00       	jmp    803a65 <lwip_setsockopt_internal+0x103>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  8039e0:	8b 02                	mov    (%edx),%eax
  8039e2:	8b 40 08             	mov    0x8(%eax),%eax
  8039e5:	f7 d1                	not    %ecx
  8039e7:	66 21 48 08          	and    %cx,0x8(%eax)
  8039eb:	eb 78                	jmp    803a65 <lwip_setsockopt_internal+0x103>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  8039ed:	83 3b 00             	cmpl   $0x0,(%ebx)
  8039f0:	74 0b                	je     8039fd <lwip_setsockopt_internal+0x9b>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  8039f2:	8b 02                	mov    (%edx),%eax
  8039f4:	8b 40 08             	mov    0x8(%eax),%eax
  8039f7:	80 48 10 01          	orb    $0x1,0x10(%eax)
  8039fb:	eb 68                	jmp    803a65 <lwip_setsockopt_internal+0x103>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  8039fd:	8b 02                	mov    (%edx),%eax
  8039ff:	8b 40 08             	mov    0x8(%eax),%eax
  803a02:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  803a06:	eb 5d                	jmp    803a65 <lwip_setsockopt_internal+0x103>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  803a08:	83 f9 01             	cmp    $0x1,%ecx
  803a0b:	74 11                	je     803a1e <lwip_setsockopt_internal+0xbc>
  803a0d:	83 f9 02             	cmp    $0x2,%ecx
  803a10:	75 53                	jne    803a65 <lwip_setsockopt_internal+0x103>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  803a12:	8b 02                	mov    (%edx),%eax
  803a14:	8b 40 08             	mov    0x8(%eax),%eax
  803a17:	8b 0b                	mov    (%ebx),%ecx
  803a19:	88 48 0b             	mov    %cl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  803a1c:	eb 47                	jmp    803a65 <lwip_setsockopt_internal+0x103>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  803a1e:	8b 02                	mov    (%edx),%eax
  803a20:	8b 40 08             	mov    0x8(%eax),%eax
  803a23:	8b 0b                	mov    (%ebx),%ecx
  803a25:	88 48 0a             	mov    %cl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
  803a28:	eb 3b                	jmp    803a65 <lwip_setsockopt_internal+0x103>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  803a2a:	83 f9 01             	cmp    $0x1,%ecx
  803a2d:	74 0b                	je     803a3a <lwip_setsockopt_internal+0xd8>
  803a2f:	83 f9 02             	cmp    $0x2,%ecx
  803a32:	75 31                	jne    803a65 <lwip_setsockopt_internal+0x103>
  803a34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803a38:	eb 1e                	jmp    803a58 <lwip_setsockopt_internal+0xf6>
    case TCP_NODELAY:
      if (*(int*)optval) {
  803a3a:	83 3b 00             	cmpl   $0x0,(%ebx)
  803a3d:	8d 76 00             	lea    0x0(%esi),%esi
  803a40:	74 0b                	je     803a4d <lwip_setsockopt_internal+0xeb>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  803a42:	8b 02                	mov    (%edx),%eax
  803a44:	8b 40 08             	mov    0x8(%eax),%eax
  803a47:	80 48 20 40          	orb    $0x40,0x20(%eax)
  803a4b:	eb 18                	jmp    803a65 <lwip_setsockopt_internal+0x103>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  803a4d:	8b 02                	mov    (%edx),%eax
  803a4f:	8b 40 08             	mov    0x8(%eax),%eax
  803a52:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  803a56:	eb 0d                	jmp    803a65 <lwip_setsockopt_internal+0x103>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  803a58:	8b 02                	mov    (%edx),%eax
  803a5a:	8b 40 08             	mov    0x8(%eax),%eax
  803a5d:	8b 0b                	mov    (%ebx),%ecx
  803a5f:	89 88 9c 00 00 00    	mov    %ecx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  803a65:	8b 02                	mov    (%edx),%eax
  803a67:	8b 40 10             	mov    0x10(%eax),%eax
  803a6a:	89 04 24             	mov    %eax,(%esp)
  803a6d:	e8 e5 a0 00 00       	call   80db57 <sys_sem_signal>
}
  803a72:	83 c4 14             	add    $0x14,%esp
  803a75:	5b                   	pop    %ebx
  803a76:	5d                   	pop    %ebp
  803a77:	c3                   	ret    

00803a78 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  803a78:	55                   	push   %ebp
  803a79:	89 e5                	mov    %esp,%ebp
  803a7b:	53                   	push   %ebx
  803a7c:	83 ec 14             	sub    $0x14,%esp
  803a7f:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  803a82:	85 c0                	test   %eax,%eax
  803a84:	75 1c                	jne    803aa2 <lwip_getsockopt_internal+0x2a>
  803a86:	c7 44 24 08 ab 2c 81 	movl   $0x812cab,0x8(%esp)
  803a8d:	00 
  803a8e:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  803a95:	00 
  803a96:	c7 04 24 b7 2c 81 00 	movl   $0x812cb7,(%esp)
  803a9d:	e8 46 cf ff ff       	call   8009e8 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  803aa2:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  803aa4:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  803aa7:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  803aaa:	8b 40 08             	mov    0x8(%eax),%eax
  803aad:	83 f8 06             	cmp    $0x6,%eax
  803ab0:	0f 84 2f 01 00 00    	je     803be5 <lwip_getsockopt_internal+0x16d>
  803ab6:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  803abb:	74 10                	je     803acd <lwip_getsockopt_internal+0x55>
  803abd:	85 c0                	test   %eax,%eax
  803abf:	0f 84 fc 00 00 00    	je     803bc1 <lwip_getsockopt_internal+0x149>
  803ac5:	8d 76 00             	lea    0x0(%esi),%esi
  803ac8:	e9 42 01 00 00       	jmp    803c0f <lwip_getsockopt_internal+0x197>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  803acd:	83 f9 20             	cmp    $0x20,%ecx
  803ad0:	74 48                	je     803b1a <lwip_getsockopt_internal+0xa2>
  803ad2:	83 f9 20             	cmp    $0x20,%ecx
  803ad5:	8d 76 00             	lea    0x0(%esi),%esi
  803ad8:	7f 18                	jg     803af2 <lwip_getsockopt_internal+0x7a>
  803ada:	83 f9 02             	cmp    $0x2,%ecx
  803add:	8d 76 00             	lea    0x0(%esi),%esi
  803ae0:	74 38                	je     803b1a <lwip_getsockopt_internal+0xa2>
  803ae2:	83 f9 08             	cmp    $0x8,%ecx
  803ae5:	0f 85 24 01 00 00    	jne    803c0f <lwip_getsockopt_internal+0x197>
  803aeb:	90                   	nop
  803aec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803af0:	eb 28                	jmp    803b1a <lwip_getsockopt_internal+0xa2>
  803af2:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  803af8:	74 32                	je     803b2c <lwip_getsockopt_internal+0xb4>
  803afa:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  803b00:	0f 84 ab 00 00 00    	je     803bb1 <lwip_getsockopt_internal+0x139>
  803b06:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  803b0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803b10:	0f 85 f9 00 00 00    	jne    803c0f <lwip_getsockopt_internal+0x197>
  803b16:	66 90                	xchg   %ax,%ax
  803b18:	eb 62                	jmp    803b7c <lwip_getsockopt_internal+0x104>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  803b1a:	8b 02                	mov    (%edx),%eax
  803b1c:	8b 40 08             	mov    0x8(%eax),%eax
  803b1f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  803b23:	21 c1                	and    %eax,%ecx
  803b25:	89 0b                	mov    %ecx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  803b27:	e9 e3 00 00 00       	jmp    803c0f <lwip_getsockopt_internal+0x197>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  803b2c:	8b 02                	mov    (%edx),%eax
  803b2e:	8b 08                	mov    (%eax),%ecx
  803b30:	89 c8                	mov    %ecx,%eax
  803b32:	25 f0 00 00 00       	and    $0xf0,%eax
  803b37:	83 f8 20             	cmp    $0x20,%eax
  803b3a:	74 29                	je     803b65 <lwip_getsockopt_internal+0xed>
  803b3c:	83 f8 40             	cmp    $0x40,%eax
  803b3f:	74 09                	je     803b4a <lwip_getsockopt_internal+0xd2>
  803b41:	83 f8 10             	cmp    $0x10,%eax
  803b44:	75 2f                	jne    803b75 <lwip_getsockopt_internal+0xfd>
  803b46:	66 90                	xchg   %ax,%ax
  803b48:	eb 0b                	jmp    803b55 <lwip_getsockopt_internal+0xdd>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  803b4a:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  803b50:	e9 ba 00 00 00       	jmp    803c0f <lwip_getsockopt_internal+0x197>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  803b55:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
        break;
  803b5b:	90                   	nop
  803b5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803b60:	e9 aa 00 00 00       	jmp    803c0f <lwip_getsockopt_internal+0x197>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  803b65:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  803b6b:	90                   	nop
  803b6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803b70:	e9 9a 00 00 00       	jmp    803c0f <lwip_getsockopt_internal+0x197>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  803b75:	89 0b                	mov    %ecx,(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG,
  803b77:	e9 93 00 00 00       	jmp    803c0f <lwip_getsockopt_internal+0x197>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  803b7c:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  803b80:	75 21                	jne    803ba3 <lwip_getsockopt_internal+0x12b>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  803b82:	8b 02                	mov    (%edx),%eax
  803b84:	0f be 48 0c          	movsbl 0xc(%eax),%ecx
  803b88:	f7 d9                	neg    %ecx
  803b8a:	b8 05 00 00 00       	mov    $0x5,%eax
  803b8f:	83 f9 0e             	cmp    $0xe,%ecx
  803b92:	77 07                	ja     803b9b <lwip_getsockopt_internal+0x123>
  803b94:	8b 04 8d a0 2d 81 00 	mov    0x812da0(,%ecx,4),%eax
  803b9b:	89 42 10             	mov    %eax,0x10(%edx)
  803b9e:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
      } 
      *(int *)optval = sock->err;
  803ba3:	8b 42 10             	mov    0x10(%edx),%eax
  803ba6:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  803ba8:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  803baf:	eb 5e                	jmp    803c0f <lwip_getsockopt_internal+0x197>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  803bb1:	8b 02                	mov    (%edx),%eax
  803bb3:	8b 40 08             	mov    0x8(%eax),%eax
  803bb6:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  803bba:	83 e0 01             	and    $0x1,%eax
  803bbd:	89 03                	mov    %eax,(%ebx)
  803bbf:	eb 4e                	jmp    803c0f <lwip_getsockopt_internal+0x197>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  803bc1:	83 f9 01             	cmp    $0x1,%ecx
  803bc4:	74 12                	je     803bd8 <lwip_getsockopt_internal+0x160>
  803bc6:	83 f9 02             	cmp    $0x2,%ecx
  803bc9:	75 44                	jne    803c0f <lwip_getsockopt_internal+0x197>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  803bcb:	8b 02                	mov    (%edx),%eax
  803bcd:	8b 40 08             	mov    0x8(%eax),%eax
  803bd0:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  803bd4:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  803bd6:	eb 37                	jmp    803c0f <lwip_getsockopt_internal+0x197>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  803bd8:	8b 02                	mov    (%edx),%eax
  803bda:	8b 40 08             	mov    0x8(%eax),%eax
  803bdd:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  803be1:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
  803be3:	eb 2a                	jmp    803c0f <lwip_getsockopt_internal+0x197>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  803be5:	83 f9 01             	cmp    $0x1,%ecx
  803be8:	74 08                	je     803bf2 <lwip_getsockopt_internal+0x17a>
  803bea:	83 f9 02             	cmp    $0x2,%ecx
  803bed:	75 20                	jne    803c0f <lwip_getsockopt_internal+0x197>
  803bef:	90                   	nop
  803bf0:	eb 10                	jmp    803c02 <lwip_getsockopt_internal+0x18a>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  803bf2:	8b 02                	mov    (%edx),%eax
  803bf4:	8b 40 08             	mov    0x8(%eax),%eax
  803bf7:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  803bfb:	83 e0 40             	and    $0x40,%eax
  803bfe:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  803c00:	eb 0d                	jmp    803c0f <lwip_getsockopt_internal+0x197>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  803c02:	8b 02                	mov    (%edx),%eax
  803c04:	8b 40 08             	mov    0x8(%eax),%eax
  803c07:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  803c0d:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  803c0f:	8b 02                	mov    (%edx),%eax
  803c11:	8b 40 10             	mov    0x10(%eax),%eax
  803c14:	89 04 24             	mov    %eax,(%esp)
  803c17:	e8 3b 9f 00 00       	call   80db57 <sys_sem_signal>
}
  803c1c:	83 c4 14             	add    $0x14,%esp
  803c1f:	5b                   	pop    %ebx
  803c20:	5d                   	pop    %ebp
  803c21:	c3                   	ret    

00803c22 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  803c22:	55                   	push   %ebp
  803c23:	89 e5                	mov    %esp,%ebp
  803c25:	57                   	push   %edi
  803c26:	56                   	push   %esi
  803c27:	53                   	push   %ebx
  803c28:	83 ec 3c             	sub    $0x3c,%esp
  803c2b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  803c2e:	89 55 d0             	mov    %edx,-0x30(%ebp)
  803c31:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  803c34:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803c3b:	00 
  803c3c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803c43:	00 
  803c44:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803c47:	89 04 24             	mov    %eax,(%esp)
  803c4a:	e8 07 d9 ff ff       	call   801556 <memset>
  FD_ZERO(&lwriteset);
  803c4f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803c56:	00 
  803c57:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803c5e:	00 
  803c5f:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803c62:	89 04 24             	mov    %eax,(%esp)
  803c65:	e8 ec d8 ff ff       	call   801556 <memset>
  FD_ZERO(&lexceptset);
  803c6a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803c71:	00 
  803c72:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803c79:	00 
  803c7a:	8d 45 dc             	lea    -0x24(%ebp),%eax
  803c7d:	89 04 24             	mov    %eax,(%esp)
  803c80:	e8 d1 d8 ff ff       	call   801556 <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  803c85:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  803c8c:	bb 00 00 00 00       	mov    $0x0,%ebx
  803c91:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  803c95:	0f 8e 84 00 00 00    	jle    803d1f <lwip_selscan+0xfd>
    if (FD_ISSET(i, readset)) {
  803c9b:	89 de                	mov    %ebx,%esi
  803c9d:	c1 fe 1f             	sar    $0x1f,%esi
  803ca0:	c1 ee 1d             	shr    $0x1d,%esi
  803ca3:	01 de                	add    %ebx,%esi
  803ca5:	c1 fe 03             	sar    $0x3,%esi
  803ca8:	89 df                	mov    %ebx,%edi
  803caa:	83 e7 07             	and    $0x7,%edi
  803cad:	8b 55 d0             	mov    -0x30(%ebp),%edx
  803cb0:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  803cb4:	0f a3 f8             	bt     %edi,%eax
  803cb7:	73 2a                	jae    803ce3 <lwip_selscan+0xc1>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  803cb9:	89 d8                	mov    %ebx,%eax
  803cbb:	e8 00 f8 ff ff       	call   8034c0 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  803cc0:	85 c0                	test   %eax,%eax
  803cc2:	74 1f                	je     803ce3 <lwip_selscan+0xc1>
  803cc4:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  803cc8:	75 08                	jne    803cd2 <lwip_selscan+0xb0>
  803cca:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  803ccf:	90                   	nop
  803cd0:	74 11                	je     803ce3 <lwip_selscan+0xc1>
        FD_SET(i, &lreadset);
  803cd2:	b8 01 00 00 00       	mov    $0x1,%eax
  803cd7:	89 f9                	mov    %edi,%ecx
  803cd9:	d3 e0                	shl    %cl,%eax
  803cdb:	08 44 35 e4          	or     %al,-0x1c(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  803cdf:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  803ce3:	8b 55 cc             	mov    -0x34(%ebp),%edx
  803ce6:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  803cea:	0f a3 f8             	bt     %edi,%eax
  803ced:	73 24                	jae    803d13 <lwip_selscan+0xf1>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  803cef:	89 d8                	mov    %ebx,%eax
  803cf1:	e8 ca f7 ff ff       	call   8034c0 <get_socket>
      if (p_sock && p_sock->sendevent) {
  803cf6:	85 c0                	test   %eax,%eax
  803cf8:	74 19                	je     803d13 <lwip_selscan+0xf1>
  803cfa:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  803cff:	90                   	nop
  803d00:	74 11                	je     803d13 <lwip_selscan+0xf1>
        FD_SET(i, &lwriteset);
  803d02:	b8 01 00 00 00       	mov    $0x1,%eax
  803d07:	89 f9                	mov    %edi,%ecx
  803d09:	d3 e0                	shl    %cl,%eax
  803d0b:	08 44 35 e0          	or     %al,-0x20(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  803d0f:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  803d13:	83 c3 01             	add    $0x1,%ebx
  803d16:	39 5d d4             	cmp    %ebx,-0x2c(%ebp)
  803d19:	0f 8f 7c ff ff ff    	jg     803c9b <lwip_selscan+0x79>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  803d1f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803d22:	8b 55 d0             	mov    -0x30(%ebp),%edx
  803d25:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  803d27:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803d2a:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  803d2d:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  803d2f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803d36:	00 
  803d37:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803d3e:	00 
  803d3f:	8b 45 08             	mov    0x8(%ebp),%eax
  803d42:	89 04 24             	mov    %eax,(%esp)
  803d45:	e8 0c d8 ff ff       	call   801556 <memset>
  
  return nready;
}
  803d4a:	8b 45 c8             	mov    -0x38(%ebp),%eax
  803d4d:	83 c4 3c             	add    $0x3c,%esp
  803d50:	5b                   	pop    %ebx
  803d51:	5e                   	pop    %esi
  803d52:	5f                   	pop    %edi
  803d53:	5d                   	pop    %ebp
  803d54:	c3                   	ret    

00803d55 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  803d55:	55                   	push   %ebp
  803d56:	89 e5                	mov    %esp,%ebp
  803d58:	83 ec 58             	sub    $0x58,%esp
  803d5b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  803d5e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  803d61:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803d64:	89 d7                	mov    %edx,%edi
  803d66:	89 ce                	mov    %ecx,%esi
  803d68:	0f b6 55 08          	movzbl 0x8(%ebp),%edx
  803d6c:	88 55 c7             	mov    %dl,-0x39(%ebp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  803d6f:	e8 4c f7 ff ff       	call   8034c0 <get_socket>
  803d74:	89 c3                	mov    %eax,%ebx
  if (!sock)
  803d76:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803d7b:	85 db                	test   %ebx,%ebx
  803d7d:	0f 84 8f 00 00 00    	je     803e12 <lwip_getaddrname+0xbd>
    return -1;

  memset(&sin, 0, sizeof(sin));
  803d83:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  803d8a:	00 
  803d8b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803d92:	00 
  803d93:	8d 45 d8             	lea    -0x28(%ebp),%eax
  803d96:	89 04 24             	mov    %eax,(%esp)
  803d99:	e8 b8 d7 ff ff       	call   801556 <memset>
  sin.sin_len = sizeof(sin);
  803d9e:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  803da2:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  803da6:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
  803daa:	89 44 24 0c          	mov    %eax,0xc(%esp)
  803dae:	8d 45 da             	lea    -0x26(%ebp),%eax
  803db1:	89 44 24 08          	mov    %eax,0x8(%esp)
  803db5:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  803db8:	89 44 24 04          	mov    %eax,0x4(%esp)
  803dbc:	8b 03                	mov    (%ebx),%eax
  803dbe:	89 04 24             	mov    %eax,(%esp)
  803dc1:	e8 2d aa 00 00       	call   80e7f3 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  803dc6:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  803dca:	89 04 24             	mov    %eax,(%esp)
  803dcd:	e8 a2 6e 00 00       	call   80ac74 <htons>
  803dd2:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  803dd6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  803dd9:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  803ddc:	83 3e 10             	cmpl   $0x10,(%esi)
  803ddf:	76 06                	jbe    803de7 <lwip_getaddrname+0x92>
    *namelen = sizeof(sin);
  803de1:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  803de7:	8b 06                	mov    (%esi),%eax
  803de9:	89 44 24 08          	mov    %eax,0x8(%esp)
  803ded:	8d 45 d8             	lea    -0x28(%ebp),%eax
  803df0:	89 44 24 04          	mov    %eax,0x4(%esp)
  803df4:	89 3c 24             	mov    %edi,(%esp)
  803df7:	e8 35 d8 ff ff       	call   801631 <memcpy>
  sock_set_errno(sock, 0);
  803dfc:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  803e03:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  803e0a:	00 00 00 
  803e0d:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  803e12:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  803e15:	8b 75 f8             	mov    -0x8(%ebp),%esi
  803e18:	8b 7d fc             	mov    -0x4(%ebp),%edi
  803e1b:	89 ec                	mov    %ebp,%esp
  803e1d:	5d                   	pop    %ebp
  803e1e:	c3                   	ret    

00803e1f <lwip_getsockname>:
  return lwip_getaddrname(s, name, namelen, 0);
}

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  803e1f:	55                   	push   %ebp
  803e20:	89 e5                	mov    %esp,%ebp
  803e22:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  803e25:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803e2c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  803e2f:	8b 55 0c             	mov    0xc(%ebp),%edx
  803e32:	8b 45 08             	mov    0x8(%ebp),%eax
  803e35:	e8 1b ff ff ff       	call   803d55 <lwip_getaddrname>
}
  803e3a:	c9                   	leave  
  803e3b:	c3                   	ret    

00803e3c <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  803e3c:	55                   	push   %ebp
  803e3d:	89 e5                	mov    %esp,%ebp
  803e3f:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  803e42:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803e49:	8b 4d 10             	mov    0x10(%ebp),%ecx
  803e4c:	8b 55 0c             	mov    0xc(%ebp),%edx
  803e4f:	8b 45 08             	mov    0x8(%ebp),%eax
  803e52:	e8 fe fe ff ff       	call   803d55 <lwip_getaddrname>
}
  803e57:	c9                   	leave  
  803e58:	c3                   	ret    

00803e59 <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  803e59:	55                   	push   %ebp
  803e5a:	89 e5                	mov    %esp,%ebp
  803e5c:	56                   	push   %esi
  803e5d:	53                   	push   %ebx
  803e5e:	83 ec 10             	sub    $0x10,%esp
  803e61:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  803e63:	a1 24 63 81 00       	mov    0x816324,%eax
  803e68:	89 04 24             	mov    %eax,(%esp)
  803e6b:	e8 ea 46 00 00       	call   80855a <sys_sem_wait>

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
    if (!sockets[i].conn) {
  803e70:	b8 b4 60 81 00       	mov    $0x8160b4,%eax
  803e75:	bb 01 00 00 00       	mov    $0x1,%ebx
  803e7a:	83 3d a0 60 81 00 00 	cmpl   $0x0,0x8160a0
  803e81:	75 04                	jne    803e87 <alloc_socket+0x2e>
  803e83:	b3 00                	mov    $0x0,%bl
  803e85:	eb 05                	jmp    803e8c <alloc_socket+0x33>
  803e87:	83 38 00             	cmpl   $0x0,(%eax)
  803e8a:	75 50                	jne    803edc <alloc_socket+0x83>
      sockets[i].conn       = newconn;
  803e8c:	ba a0 60 81 00       	mov    $0x8160a0,%edx
  803e91:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
  803e98:	8d 0c 18             	lea    (%eax,%ebx,1),%ecx
  803e9b:	89 34 8a             	mov    %esi,(%edx,%ecx,4)
      sockets[i].lastdata   = NULL;
  803e9e:	c7 44 8a 04 00 00 00 	movl   $0x0,0x4(%edx,%ecx,4)
  803ea5:	00 
      sockets[i].lastoffset = 0;
  803ea6:	66 c7 44 8a 08 00 00 	movw   $0x0,0x8(%edx,%ecx,4)
      sockets[i].rcvevent   = 0;
  803ead:	66 c7 44 8a 0a 00 00 	movw   $0x0,0xa(%edx,%ecx,4)
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  803eb4:	66 c7 44 8a 0c 01 00 	movw   $0x1,0xc(%edx,%ecx,4)
      sockets[i].flags      = 0;
  803ebb:	66 c7 44 8a 0e 00 00 	movw   $0x0,0xe(%edx,%ecx,4)
      sockets[i].err        = 0;
  803ec2:	c7 04 8d b0 60 81 00 	movl   $0x0,0x8160b0(,%ecx,4)
  803ec9:	00 00 00 00 
      sys_sem_signal(socksem);
  803ecd:	a1 24 63 81 00       	mov    0x816324,%eax
  803ed2:	89 04 24             	mov    %eax,(%esp)
  803ed5:	e8 7d 9c 00 00       	call   80db57 <sys_sem_signal>
      return i;
  803eda:	eb 1d                	jmp    803ef9 <alloc_socket+0xa0>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  803edc:	83 c3 01             	add    $0x1,%ebx
  803edf:	83 c0 14             	add    $0x14,%eax
  803ee2:	83 fb 20             	cmp    $0x20,%ebx
  803ee5:	75 a0                	jne    803e87 <alloc_socket+0x2e>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  803ee7:	a1 24 63 81 00       	mov    0x816324,%eax
  803eec:	89 04 24             	mov    %eax,(%esp)
  803eef:	e8 63 9c 00 00       	call   80db57 <sys_sem_signal>
  803ef4:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return -1;
}
  803ef9:	89 d8                	mov    %ebx,%eax
  803efb:	83 c4 10             	add    $0x10,%esp
  803efe:	5b                   	pop    %ebx
  803eff:	5e                   	pop    %esi
  803f00:	5d                   	pop    %ebp
  803f01:	c3                   	ret    

00803f02 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  803f02:	55                   	push   %ebp
  803f03:	89 e5                	mov    %esp,%ebp
  803f05:	57                   	push   %edi
  803f06:	56                   	push   %esi
  803f07:	53                   	push   %ebx
  803f08:	83 ec 2c             	sub    $0x2c,%esp
  803f0b:	8b 75 08             	mov    0x8(%ebp),%esi
  803f0e:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  803f11:	85 f6                	test   %esi,%esi
  803f13:	0f 84 7b 01 00 00    	je     804094 <event_callback+0x192>
    s = conn->socket;
  803f19:	8b 5e 1c             	mov    0x1c(%esi),%ebx
    if (s < 0) {
  803f1c:	85 db                	test   %ebx,%ebx
  803f1e:	79 3d                	jns    803f5d <event_callback+0x5b>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  803f20:	a1 24 63 81 00       	mov    0x816324,%eax
  803f25:	89 04 24             	mov    %eax,(%esp)
  803f28:	e8 2d 46 00 00       	call   80855a <sys_sem_wait>
      if (conn->socket < 0) {
  803f2d:	8b 46 1c             	mov    0x1c(%esi),%eax
  803f30:	85 c0                	test   %eax,%eax
  803f32:	79 1c                	jns    803f50 <event_callback+0x4e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  803f34:	85 ff                	test   %edi,%edi
  803f36:	75 06                	jne    803f3e <event_callback+0x3c>
          conn->socket--;
  803f38:	83 e8 01             	sub    $0x1,%eax
  803f3b:	89 46 1c             	mov    %eax,0x1c(%esi)
        }
        sys_sem_signal(socksem);
  803f3e:	a1 24 63 81 00       	mov    0x816324,%eax
  803f43:	89 04 24             	mov    %eax,(%esp)
  803f46:	e8 0c 9c 00 00       	call   80db57 <sys_sem_signal>
        return;
  803f4b:	e9 44 01 00 00       	jmp    804094 <event_callback+0x192>
      }
      sys_sem_signal(socksem);
  803f50:	a1 24 63 81 00       	mov    0x816324,%eax
  803f55:	89 04 24             	mov    %eax,(%esp)
  803f58:	e8 fa 9b 00 00       	call   80db57 <sys_sem_signal>
    }

    sock = get_socket(s);
  803f5d:	89 d8                	mov    %ebx,%eax
  803f5f:	e8 5c f5 ff ff       	call   8034c0 <get_socket>
  803f64:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  803f67:	85 c0                	test   %eax,%eax
  803f69:	0f 84 25 01 00 00    	je     804094 <event_callback+0x192>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  803f6f:	a1 28 63 81 00       	mov    0x816328,%eax
  803f74:	89 04 24             	mov    %eax,(%esp)
  803f77:	e8 de 45 00 00       	call   80855a <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  803f7c:	83 ff 01             	cmp    $0x1,%edi
  803f7f:	74 23                	je     803fa4 <event_callback+0xa2>
  803f81:	83 ff 01             	cmp    $0x1,%edi
  803f84:	72 14                	jb     803f9a <event_callback+0x98>
  803f86:	83 ff 02             	cmp    $0x2,%edi
  803f89:	74 23                	je     803fae <event_callback+0xac>
  803f8b:	83 ff 03             	cmp    $0x3,%edi
  803f8e:	66 90                	xchg   %ax,%ax
  803f90:	75 32                	jne    803fc4 <event_callback+0xc2>
  803f92:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  803f98:	eb 1f                	jmp    803fb9 <event_callback+0xb7>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  803f9a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803f9d:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  803fa2:	eb 3c                	jmp    803fe0 <event_callback+0xde>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  803fa4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803fa7:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  803fac:	eb 32                	jmp    803fe0 <event_callback+0xde>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  803fae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803fb1:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  803fb7:	eb 27                	jmp    803fe0 <event_callback+0xde>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  803fb9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803fbc:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  803fc2:	eb 1c                	jmp    803fe0 <event_callback+0xde>
    default:
      LWIP_ASSERT("unknown event", 0);
  803fc4:	c7 44 24 08 ce 2c 81 	movl   $0x812cce,0x8(%esp)
  803fcb:	00 
  803fcc:	c7 44 24 04 17 04 00 	movl   $0x417,0x4(%esp)
  803fd3:	00 
  803fd4:	c7 04 24 b7 2c 81 00 	movl   $0x812cb7,(%esp)
  803fdb:	e8 08 ca ff ff       	call   8009e8 <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  803fe0:	a1 28 63 81 00       	mov    0x816328,%eax
  803fe5:	89 04 24             	mov    %eax,(%esp)
  803fe8:	e8 6a 9b 00 00       	call   80db57 <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  803fed:	89 de                	mov    %ebx,%esi
  803fef:	c1 fe 1f             	sar    $0x1f,%esi
  803ff2:	c1 ee 1d             	shr    $0x1d,%esi
  803ff5:	01 de                	add    %ebx,%esi
  803ff7:	c1 fe 03             	sar    $0x3,%esi
  803ffa:	89 d9                	mov    %ebx,%ecx
  803ffc:	83 e1 07             	and    $0x7,%ecx
  803fff:	b8 01 00 00 00       	mov    $0x1,%eax
  804004:	89 c7                	mov    %eax,%edi
  804006:	d3 e7                	shl    %cl,%edi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  804008:	a1 28 63 81 00       	mov    0x816328,%eax
  80400d:	89 04 24             	mov    %eax,(%esp)
  804010:	e8 45 45 00 00       	call   80855a <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  804015:	8b 1d 20 63 81 00    	mov    0x816320,%ebx
  80401b:	85 db                	test   %ebx,%ebx
  80401d:	74 68                	je     804087 <event_callback+0x185>
      if (scb->sem_signalled == 0) {
  80401f:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  804023:	75 32                	jne    804057 <event_callback+0x155>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  804025:	8b 43 04             	mov    0x4(%ebx),%eax
  804028:	85 c0                	test   %eax,%eax
  80402a:	74 12                	je     80403e <event_callback+0x13c>
  80402c:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  804030:	85 f8                	test   %edi,%eax
  804032:	74 0a                	je     80403e <event_callback+0x13c>
          if (sock->rcvevent)
  804034:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804037:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  80403c:	75 24                	jne    804062 <event_callback+0x160>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  80403e:	8b 43 08             	mov    0x8(%ebx),%eax
  804041:	85 c0                	test   %eax,%eax
  804043:	74 12                	je     804057 <event_callback+0x155>
  804045:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  804049:	85 f8                	test   %edi,%eax
  80404b:	74 0a                	je     804057 <event_callback+0x155>
          if (sock->sendevent)
  80404d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804050:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  804055:	75 0b                	jne    804062 <event_callback+0x160>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  804057:	8b 1b                	mov    (%ebx),%ebx
  804059:	85 db                	test   %ebx,%ebx
  80405b:	75 c2                	jne    80401f <event_callback+0x11d>
  80405d:	8d 76 00             	lea    0x0(%esi),%esi
  804060:	eb 25                	jmp    804087 <event_callback+0x185>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
  804062:	85 db                	test   %ebx,%ebx
  804064:	74 21                	je     804087 <event_callback+0x185>
      scb->sem_signalled = 1;
  804066:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  80406d:	a1 28 63 81 00       	mov    0x816328,%eax
  804072:	89 04 24             	mov    %eax,(%esp)
  804075:	e8 dd 9a 00 00       	call   80db57 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  80407a:	8b 43 14             	mov    0x14(%ebx),%eax
  80407d:	89 04 24             	mov    %eax,(%esp)
  804080:	e8 d2 9a 00 00       	call   80db57 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  804085:	eb 81                	jmp    804008 <event_callback+0x106>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  804087:	a1 28 63 81 00       	mov    0x816328,%eax
  80408c:	89 04 24             	mov    %eax,(%esp)
  80408f:	e8 c3 9a 00 00       	call   80db57 <sys_sem_signal>
      break;
    }
  }
}
  804094:	83 c4 2c             	add    $0x2c,%esp
  804097:	5b                   	pop    %ebx
  804098:	5e                   	pop    %esi
  804099:	5f                   	pop    %edi
  80409a:	5d                   	pop    %ebp
  80409b:	c3                   	ret    

0080409c <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  80409c:	55                   	push   %ebp
  80409d:	89 e5                	mov    %esp,%ebp
  80409f:	83 ec 18             	sub    $0x18,%esp
  socksem   = sys_sem_new(1);
  8040a2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8040a9:	e8 07 99 00 00       	call   80d9b5 <sys_sem_new>
  8040ae:	a3 24 63 81 00       	mov    %eax,0x816324
  selectsem = sys_sem_new(1);
  8040b3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8040ba:	e8 f6 98 00 00       	call   80d9b5 <sys_sem_new>
  8040bf:	a3 28 63 81 00       	mov    %eax,0x816328
}
  8040c4:	c9                   	leave  
  8040c5:	c3                   	ret    

008040c6 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  8040c6:	55                   	push   %ebp
  8040c7:	89 e5                	mov    %esp,%ebp
  8040c9:	57                   	push   %edi
  8040ca:	56                   	push   %esi
  8040cb:	53                   	push   %ebx
  8040cc:	83 ec 5c             	sub    $0x5c,%esp
  8040cf:	8b 7d 0c             	mov    0xc(%ebp),%edi
  8040d2:	8b 75 10             	mov    0x10(%ebp),%esi
  8040d5:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  8040d8:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  8040df:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  8040e2:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  8040e5:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  8040e8:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  8040ef:	a1 28 63 81 00       	mov    0x816328,%eax
  8040f4:	89 04 24             	mov    %eax,(%esp)
  8040f7:	e8 5e 44 00 00       	call   80855a <sys_sem_wait>

  if (readset)
  8040fc:	85 ff                	test   %edi,%edi
  8040fe:	74 07                	je     804107 <lwip_select+0x41>
    lreadset = *readset;
  804100:	8b 07                	mov    (%edi),%eax
  804102:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  804105:	eb 1b                	jmp    804122 <lwip_select+0x5c>
  else
    FD_ZERO(&lreadset);
  804107:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80410e:	00 
  80410f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804116:	00 
  804117:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80411a:	89 04 24             	mov    %eax,(%esp)
  80411d:	e8 34 d4 ff ff       	call   801556 <memset>
  if (writeset)
  804122:	85 f6                	test   %esi,%esi
  804124:	74 07                	je     80412d <lwip_select+0x67>
    lwriteset = *writeset;
  804126:	8b 06                	mov    (%esi),%eax
  804128:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80412b:	eb 1b                	jmp    804148 <lwip_select+0x82>
  else
    FD_ZERO(&lwriteset);
  80412d:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804134:	00 
  804135:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80413c:	00 
  80413d:	8d 45 e0             	lea    -0x20(%ebp),%eax
  804140:	89 04 24             	mov    %eax,(%esp)
  804143:	e8 0e d4 ff ff       	call   801556 <memset>
  if (exceptset)
  804148:	85 db                	test   %ebx,%ebx
  80414a:	74 07                	je     804153 <lwip_select+0x8d>
    lexceptset = *exceptset;
  80414c:	8b 03                	mov    (%ebx),%eax
  80414e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  804151:	eb 1b                	jmp    80416e <lwip_select+0xa8>
  else
    FD_ZERO(&lexceptset);
  804153:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80415a:	00 
  80415b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804162:	00 
  804163:	8d 45 dc             	lea    -0x24(%ebp),%eax
  804166:	89 04 24             	mov    %eax,(%esp)
  804169:	e8 e8 d3 ff ff       	call   801556 <memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  80416e:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  804171:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  804174:	8d 45 dc             	lea    -0x24(%ebp),%eax
  804177:	89 04 24             	mov    %eax,(%esp)
  80417a:	8b 45 08             	mov    0x8(%ebp),%eax
  80417d:	e8 a0 fa ff ff       	call   803c22 <lwip_selscan>
  804182:	89 45 b0             	mov    %eax,-0x50(%ebp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  804185:	85 c0                	test   %eax,%eax
  804187:	0f 85 2e 02 00 00    	jne    8043bb <lwip_select+0x2f5>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  80418d:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  804191:	0f 84 86 00 00 00    	je     80421d <lwip_select+0x157>
  804197:	8b 45 18             	mov    0x18(%ebp),%eax
  80419a:	83 38 00             	cmpl   $0x0,(%eax)
  80419d:	0f 85 55 02 00 00    	jne    8043f8 <lwip_select+0x332>
  8041a3:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8041a7:	0f 85 4b 02 00 00    	jne    8043f8 <lwip_select+0x332>
      sys_sem_signal(selectsem);
  8041ad:	a1 28 63 81 00       	mov    0x816328,%eax
  8041b2:	89 04 24             	mov    %eax,(%esp)
  8041b5:	e8 9d 99 00 00       	call   80db57 <sys_sem_signal>
      if (readset)
  8041ba:	85 ff                	test   %edi,%edi
  8041bc:	74 18                	je     8041d6 <lwip_select+0x110>
        FD_ZERO(readset);
  8041be:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8041c5:	00 
  8041c6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8041cd:	00 
  8041ce:	89 3c 24             	mov    %edi,(%esp)
  8041d1:	e8 80 d3 ff ff       	call   801556 <memset>
      if (writeset)
  8041d6:	85 f6                	test   %esi,%esi
  8041d8:	74 18                	je     8041f2 <lwip_select+0x12c>
        FD_ZERO(writeset);
  8041da:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8041e1:	00 
  8041e2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8041e9:	00 
  8041ea:	89 34 24             	mov    %esi,(%esp)
  8041ed:	e8 64 d3 ff ff       	call   801556 <memset>
      if (exceptset)
  8041f2:	85 db                	test   %ebx,%ebx
  8041f4:	74 18                	je     80420e <lwip_select+0x148>
        FD_ZERO(exceptset);
  8041f6:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8041fd:	00 
  8041fe:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804205:	00 
  804206:	89 1c 24             	mov    %ebx,(%esp)
  804209:	e8 48 d3 ff ff       	call   801556 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  80420e:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  804215:	00 00 00 
  
      return 0;
  804218:	e9 d0 01 00 00       	jmp    8043ed <lwip_select+0x327>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  80421d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804224:	e8 8c 97 00 00       	call   80d9b5 <sys_sem_new>
  804229:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  80422c:	a1 20 63 81 00       	mov    0x816320,%eax
  804231:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  804234:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  804237:	a3 20 63 81 00       	mov    %eax,0x816320
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  80423c:	a1 28 63 81 00       	mov    0x816328,%eax
  804241:	89 04 24             	mov    %eax,(%esp)
  804244:	e8 0e 99 00 00       	call   80db57 <sys_sem_signal>
  804249:	ba 00 00 00 00       	mov    $0x0,%edx
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  80424e:	89 54 24 04          	mov    %edx,0x4(%esp)
  804252:	8b 45 d8             	mov    -0x28(%ebp),%eax
  804255:	89 04 24             	mov    %eax,(%esp)
  804258:	e8 8c 43 00 00       	call   8085e9 <sys_sem_wait_timeout>
  80425d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  804260:	a1 28 63 81 00       	mov    0x816328,%eax
  804265:	89 04 24             	mov    %eax,(%esp)
  804268:	e8 ed 42 00 00       	call   80855a <sys_sem_wait>
    if (select_cb_list == &select_cb)
  80426d:	a1 20 63 81 00       	mov    0x816320,%eax
  804272:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  804275:	39 d0                	cmp    %edx,%eax
  804277:	75 20                	jne    804299 <lwip_select+0x1d3>
      select_cb_list = select_cb.next;
  804279:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  80427c:	a3 20 63 81 00       	mov    %eax,0x816320
  804281:	eb 2c                	jmp    8042af <lwip_select+0x1e9>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  804283:	8b 10                	mov    (%eax),%edx
  804285:	39 ca                	cmp    %ecx,%edx
  804287:	74 09                	je     804292 <lwip_select+0x1cc>
  804289:	89 d0                	mov    %edx,%eax
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  80428b:	85 c0                	test   %eax,%eax
  80428d:	75 f4                	jne    804283 <lwip_select+0x1bd>
  80428f:	90                   	nop
  804290:	eb 1d                	jmp    8042af <lwip_select+0x1e9>
        if (p_selcb->next == &select_cb) {
          p_selcb->next = select_cb.next;
  804292:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  804295:	89 10                	mov    %edx,(%eax)
          break;
  804297:	eb 16                	jmp    8042af <lwip_select+0x1e9>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  804299:	85 c0                	test   %eax,%eax
  80429b:	90                   	nop
  80429c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8042a0:	74 0d                	je     8042af <lwip_select+0x1e9>
        if (p_selcb->next == &select_cb) {
  8042a2:	8b 10                	mov    (%eax),%edx
  8042a4:	8d 4d c4             	lea    -0x3c(%ebp),%ecx
  8042a7:	39 ca                	cmp    %ecx,%edx
  8042a9:	74 e7                	je     804292 <lwip_select+0x1cc>
  8042ab:	89 d0                	mov    %edx,%eax
  8042ad:	eb dc                	jmp    80428b <lwip_select+0x1c5>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  8042af:	a1 28 63 81 00       	mov    0x816328,%eax
  8042b4:	89 04 24             	mov    %eax,(%esp)
  8042b7:	e8 9b 98 00 00       	call   80db57 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  8042bc:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8042bf:	89 04 24             	mov    %eax,(%esp)
  8042c2:	e8 3c 92 00 00       	call   80d503 <sys_sem_free>
    if (i == 0)  {
  8042c7:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8042cb:	75 63                	jne    804330 <lwip_select+0x26a>
      /* Timeout */
      if (readset)
  8042cd:	85 ff                	test   %edi,%edi
  8042cf:	74 18                	je     8042e9 <lwip_select+0x223>
        FD_ZERO(readset);
  8042d1:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8042d8:	00 
  8042d9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8042e0:	00 
  8042e1:	89 3c 24             	mov    %edi,(%esp)
  8042e4:	e8 6d d2 ff ff       	call   801556 <memset>
      if (writeset)
  8042e9:	85 f6                	test   %esi,%esi
  8042eb:	74 18                	je     804305 <lwip_select+0x23f>
        FD_ZERO(writeset);
  8042ed:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8042f4:	00 
  8042f5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8042fc:	00 
  8042fd:	89 34 24             	mov    %esi,(%esp)
  804300:	e8 51 d2 ff ff       	call   801556 <memset>
      if (exceptset)
  804305:	85 db                	test   %ebx,%ebx
  804307:	74 18                	je     804321 <lwip_select+0x25b>
        FD_ZERO(exceptset);
  804309:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804310:	00 
  804311:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804318:	00 
  804319:	89 1c 24             	mov    %ebx,(%esp)
  80431c:	e8 35 d2 ff ff       	call   801556 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  804321:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  804328:	00 00 00 
  
      return 0;
  80432b:	e9 bd 00 00 00       	jmp    8043ed <lwip_select+0x327>
    }
    
    if (readset)
  804330:	85 ff                	test   %edi,%edi
  804332:	74 07                	je     80433b <lwip_select+0x275>
      lreadset = *readset;
  804334:	8b 07                	mov    (%edi),%eax
  804336:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  804339:	eb 1b                	jmp    804356 <lwip_select+0x290>
    else
      FD_ZERO(&lreadset);
  80433b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804342:	00 
  804343:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80434a:	00 
  80434b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80434e:	89 04 24             	mov    %eax,(%esp)
  804351:	e8 00 d2 ff ff       	call   801556 <memset>
    if (writeset)
  804356:	85 f6                	test   %esi,%esi
  804358:	74 07                	je     804361 <lwip_select+0x29b>
      lwriteset = *writeset;
  80435a:	8b 06                	mov    (%esi),%eax
  80435c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80435f:	eb 1b                	jmp    80437c <lwip_select+0x2b6>
    else
      FD_ZERO(&lwriteset);
  804361:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804368:	00 
  804369:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804370:	00 
  804371:	8d 45 e0             	lea    -0x20(%ebp),%eax
  804374:	89 04 24             	mov    %eax,(%esp)
  804377:	e8 da d1 ff ff       	call   801556 <memset>
    if (exceptset)
  80437c:	85 db                	test   %ebx,%ebx
  80437e:	74 07                	je     804387 <lwip_select+0x2c1>
      lexceptset = *exceptset;
  804380:	8b 03                	mov    (%ebx),%eax
  804382:	89 45 dc             	mov    %eax,-0x24(%ebp)
  804385:	eb 1b                	jmp    8043a2 <lwip_select+0x2dc>
    else
      FD_ZERO(&lexceptset);
  804387:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80438e:	00 
  80438f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804396:	00 
  804397:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80439a:	89 04 24             	mov    %eax,(%esp)
  80439d:	e8 b4 d1 ff ff       	call   801556 <memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8043a2:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  8043a5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8043a8:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8043ab:	89 04 24             	mov    %eax,(%esp)
  8043ae:	8b 45 08             	mov    0x8(%ebp),%eax
  8043b1:	e8 6c f8 ff ff       	call   803c22 <lwip_selscan>
  8043b6:	89 45 b0             	mov    %eax,-0x50(%ebp)
  8043b9:	eb 0d                	jmp    8043c8 <lwip_select+0x302>
  } else
    sys_sem_signal(selectsem);
  8043bb:	a1 28 63 81 00       	mov    0x816328,%eax
  8043c0:	89 04 24             	mov    %eax,(%esp)
  8043c3:	e8 8f 97 00 00       	call   80db57 <sys_sem_signal>
  
  if (readset)
  8043c8:	85 ff                	test   %edi,%edi
  8043ca:	74 05                	je     8043d1 <lwip_select+0x30b>
    *readset = lreadset;
  8043cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8043cf:	89 07                	mov    %eax,(%edi)
  if (writeset)
  8043d1:	85 f6                	test   %esi,%esi
  8043d3:	74 05                	je     8043da <lwip_select+0x314>
    *writeset = lwriteset;
  8043d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8043d8:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  8043da:	85 db                	test   %ebx,%ebx
  8043dc:	74 05                	je     8043e3 <lwip_select+0x31d>
    *exceptset = lexceptset;
  8043de:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8043e1:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  8043e3:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8043ea:	00 00 00 
  
  return nready;
}
  8043ed:	8b 45 b0             	mov    -0x50(%ebp),%eax
  8043f0:	83 c4 5c             	add    $0x5c,%esp
  8043f3:	5b                   	pop    %ebx
  8043f4:	5e                   	pop    %esi
  8043f5:	5f                   	pop    %edi
  8043f6:	5d                   	pop    %ebp
  8043f7:	c3                   	ret    
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  8043f8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8043ff:	e8 b1 95 00 00       	call   80d9b5 <sys_sem_new>
  804404:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  804407:	a1 20 63 81 00       	mov    0x816320,%eax
  80440c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  80440f:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  804412:	a3 20 63 81 00       	mov    %eax,0x816320
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  804417:	a1 28 63 81 00       	mov    0x816328,%eax
  80441c:	89 04 24             	mov    %eax,(%esp)
  80441f:	e8 33 97 00 00       	call   80db57 <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  804424:	8b 45 18             	mov    0x18(%ebp),%eax
  804427:	8b 48 04             	mov    0x4(%eax),%ecx
  80442a:	81 c1 f4 01 00 00    	add    $0x1f4,%ecx
  804430:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  804435:	89 c8                	mov    %ecx,%eax
  804437:	f7 ea                	imul   %edx
  804439:	c1 fa 06             	sar    $0x6,%edx
  80443c:	c1 f9 1f             	sar    $0x1f,%ecx
  80443f:	29 ca                	sub    %ecx,%edx
  804441:	8b 45 18             	mov    0x18(%ebp),%eax
  804444:	69 08 e8 03 00 00    	imul   $0x3e8,(%eax),%ecx
      if(msectimeout == 0)
  80444a:	01 ca                	add    %ecx,%edx
  80444c:	0f 85 fc fd ff ff    	jne    80424e <lwip_select+0x188>
  804452:	ba 01 00 00 00       	mov    $0x1,%edx
  804457:	e9 f2 fd ff ff       	jmp    80424e <lwip_select+0x188>

0080445c <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  80445c:	55                   	push   %ebp
  80445d:	89 e5                	mov    %esp,%ebp
  80445f:	56                   	push   %esi
  804460:	53                   	push   %ebx
  804461:	83 ec 10             	sub    $0x10,%esp
  804464:	8b 45 0c             	mov    0xc(%ebp),%eax
  804467:	8b 55 10             	mov    0x10(%ebp),%edx
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  80446a:	83 f8 02             	cmp    $0x2,%eax
  80446d:	74 32                	je     8044a1 <lwip_socket+0x45>
  80446f:	83 f8 03             	cmp    $0x3,%eax
  804472:	74 0e                	je     804482 <lwip_socket+0x26>
  804474:	83 f8 01             	cmp    $0x1,%eax
  804477:	75 73                	jne    8044ec <lwip_socket+0x90>
  804479:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  804480:	eb 4a                	jmp    8044cc <lwip_socket+0x70>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  804482:	c7 44 24 08 02 3f 80 	movl   $0x803f02,0x8(%esp)
  804489:	00 
  80448a:	0f b6 d2             	movzbl %dl,%edx
  80448d:	89 54 24 04          	mov    %edx,0x4(%esp)
  804491:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  804498:	e8 6b a6 00 00       	call   80eb08 <netconn_new_with_proto_and_callback>
  80449d:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  80449f:	eb 5c                	jmp    8044fd <lwip_socket+0xa1>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  8044a1:	81 fa 88 00 00 00    	cmp    $0x88,%edx
  8044a7:	0f 94 c0             	sete   %al
  8044aa:	0f b6 c0             	movzbl %al,%eax
  8044ad:	83 c0 20             	add    $0x20,%eax
  8044b0:	c7 44 24 08 02 3f 80 	movl   $0x803f02,0x8(%esp)
  8044b7:	00 
  8044b8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8044bf:	00 
  8044c0:	89 04 24             	mov    %eax,(%esp)
  8044c3:	e8 40 a6 00 00       	call   80eb08 <netconn_new_with_proto_and_callback>
  8044c8:	89 c6                	mov    %eax,%esi
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8044ca:	eb 31                	jmp    8044fd <lwip_socket+0xa1>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8044cc:	c7 44 24 08 02 3f 80 	movl   $0x803f02,0x8(%esp)
  8044d3:	00 
  8044d4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8044db:	00 
  8044dc:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  8044e3:	e8 20 a6 00 00       	call   80eb08 <netconn_new_with_proto_and_callback>
  8044e8:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8044ea:	eb 11                	jmp    8044fd <lwip_socket+0xa1>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  8044ec:	c7 05 20 c2 b3 00 16 	movl   $0x16,0xb3c220
  8044f3:	00 00 00 
  8044f6:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    return -1;
  8044fb:	eb 44                	jmp    804541 <lwip_socket+0xe5>
  }

  if (!conn) {
  8044fd:	85 f6                	test   %esi,%esi
  8044ff:	75 11                	jne    804512 <lwip_socket+0xb6>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  804501:	c7 05 20 c2 b3 00 69 	movl   $0x69,0xb3c220
  804508:	00 00 00 
  80450b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    return -1;
  804510:	eb 2f                	jmp    804541 <lwip_socket+0xe5>
  }

  i = alloc_socket(conn);
  804512:	89 f0                	mov    %esi,%eax
  804514:	e8 40 f9 ff ff       	call   803e59 <alloc_socket>
  804519:	89 c3                	mov    %eax,%ebx

  if (i == -1) {
  80451b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80451e:	75 14                	jne    804534 <lwip_socket+0xd8>
    netconn_delete(conn);
  804520:	89 34 24             	mov    %esi,(%esp)
  804523:	e8 a3 a5 00 00       	call   80eacb <netconn_delete>
    set_errno(ENFILE);
  804528:	c7 05 20 c2 b3 00 17 	movl   $0x17,0xb3c220
  80452f:	00 00 00 
    return -1;
  804532:	eb 0d                	jmp    804541 <lwip_socket+0xe5>
  }
  conn->socket = i;
  804534:	89 46 1c             	mov    %eax,0x1c(%esi)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  804537:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  80453e:	00 00 00 
  return i;
}
  804541:	89 d8                	mov    %ebx,%eax
  804543:	83 c4 10             	add    $0x10,%esp
  804546:	5b                   	pop    %ebx
  804547:	5e                   	pop    %esi
  804548:	5d                   	pop    %ebp
  804549:	c3                   	ret    

0080454a <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  80454a:	55                   	push   %ebp
  80454b:	89 e5                	mov    %esp,%ebp
  80454d:	83 ec 38             	sub    $0x38,%esp
  804550:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  804553:	89 75 f8             	mov    %esi,-0x8(%ebp)
  804556:	89 7d fc             	mov    %edi,-0x4(%ebp)
  804559:	8b 7d 08             	mov    0x8(%ebp),%edi
  80455c:	8b 75 10             	mov    0x10(%ebp),%esi
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  80455f:	89 f8                	mov    %edi,%eax
  804561:	e8 5a ef ff ff       	call   8034c0 <get_socket>
  804566:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804568:	85 c0                	test   %eax,%eax
  80456a:	0f 84 80 00 00 00    	je     8045f0 <lwip_send+0xa6>
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  804570:	8b 00                	mov    (%eax),%eax
  804572:	83 38 10             	cmpl   $0x10,(%eax)
  804575:	74 2e                	je     8045a5 <lwip_send+0x5b>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  804577:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80457e:	00 
  80457f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  804586:	00 
  804587:	8b 45 14             	mov    0x14(%ebp),%eax
  80458a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80458e:	89 74 24 08          	mov    %esi,0x8(%esp)
  804592:	8b 55 0c             	mov    0xc(%ebp),%edx
  804595:	89 54 24 04          	mov    %edx,0x4(%esp)
  804599:	89 3c 24             	mov    %edi,(%esp)
  80459c:	e8 8c 00 00 00       	call   80462d <lwip_sendto>
  8045a1:	89 c6                	mov    %eax,%esi
  8045a3:	eb 50                	jmp    8045f5 <lwip_send+0xab>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  8045a5:	8b 55 14             	mov    0x14(%ebp),%edx
  8045a8:	83 e2 10             	and    $0x10,%edx
  8045ab:	83 fa 01             	cmp    $0x1,%edx
  8045ae:	19 d2                	sbb    %edx,%edx
  8045b0:	83 e2 fe             	and    $0xfffffffe,%edx
  8045b3:	83 c2 03             	add    $0x3,%edx
  8045b6:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8045ba:	89 74 24 08          	mov    %esi,0x8(%esp)
  8045be:	8b 55 0c             	mov    0xc(%ebp),%edx
  8045c1:	89 54 24 04          	mov    %edx,0x4(%esp)
  8045c5:	89 04 24             	mov    %eax,(%esp)
  8045c8:	e8 e9 9f 00 00       	call   80e5b6 <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  8045cd:	0f be c8             	movsbl %al,%ecx
  8045d0:	f7 d9                	neg    %ecx
  8045d2:	ba 05 00 00 00       	mov    $0x5,%edx
  8045d7:	83 f9 0e             	cmp    $0xe,%ecx
  8045da:	77 07                	ja     8045e3 <lwip_send+0x99>
  8045dc:	8b 14 8d a0 2d 81 00 	mov    0x812da0(,%ecx,4),%edx
  8045e3:	89 53 10             	mov    %edx,0x10(%ebx)
  8045e6:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  return (err==ERR_OK?size:-1);
  8045ec:	84 c0                	test   %al,%al
  8045ee:	74 05                	je     8045f5 <lwip_send+0xab>
  8045f0:	be ff ff ff ff       	mov    $0xffffffff,%esi
}
  8045f5:	89 f0                	mov    %esi,%eax
  8045f7:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8045fa:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8045fd:	8b 7d fc             	mov    -0x4(%ebp),%edi
  804600:	89 ec                	mov    %ebp,%esp
  804602:	5d                   	pop    %ebp
  804603:	c3                   	ret    

00804604 <lwip_write>:
  return i;
}

int
lwip_write(int s, const void *data, int size)
{
  804604:	55                   	push   %ebp
  804605:	89 e5                	mov    %esp,%ebp
  804607:	83 ec 18             	sub    $0x18,%esp
  return lwip_send(s, data, size, 0);
  80460a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804611:	00 
  804612:	8b 45 10             	mov    0x10(%ebp),%eax
  804615:	89 44 24 08          	mov    %eax,0x8(%esp)
  804619:	8b 45 0c             	mov    0xc(%ebp),%eax
  80461c:	89 44 24 04          	mov    %eax,0x4(%esp)
  804620:	8b 45 08             	mov    0x8(%ebp),%eax
  804623:	89 04 24             	mov    %eax,(%esp)
  804626:	e8 1f ff ff ff       	call   80454a <lwip_send>
}
  80462b:	c9                   	leave  
  80462c:	c3                   	ret    

0080462d <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  80462d:	55                   	push   %ebp
  80462e:	89 e5                	mov    %esp,%ebp
  804630:	57                   	push   %edi
  804631:	56                   	push   %esi
  804632:	53                   	push   %ebx
  804633:	83 ec 3c             	sub    $0x3c,%esp
  804636:	8b 7d 10             	mov    0x10(%ebp),%edi
  804639:	8b 75 18             	mov    0x18(%ebp),%esi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  80463c:	8b 45 08             	mov    0x8(%ebp),%eax
  80463f:	e8 7c ee ff ff       	call   8034c0 <get_socket>
  804644:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804646:	85 c0                	test   %eax,%eax
  804648:	0f 84 2e 01 00 00    	je     80477c <lwip_sendto+0x14f>
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  80464e:	8b 00                	mov    (%eax),%eax
  804650:	83 38 10             	cmpl   $0x10,(%eax)
  804653:	75 24                	jne    804679 <lwip_sendto+0x4c>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  804655:	8b 45 14             	mov    0x14(%ebp),%eax
  804658:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80465c:	89 7c 24 08          	mov    %edi,0x8(%esp)
  804660:	8b 45 0c             	mov    0xc(%ebp),%eax
  804663:	89 44 24 04          	mov    %eax,0x4(%esp)
  804667:	8b 45 08             	mov    0x8(%ebp),%eax
  80466a:	89 04 24             	mov    %eax,(%esp)
  80466d:	e8 d8 fe ff ff       	call   80454a <lwip_send>
  804672:	89 c7                	mov    %eax,%edi
  804674:	e9 08 01 00 00       	jmp    804781 <lwip_sendto+0x154>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  804679:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  80467f:	76 1c                	jbe    80469d <lwip_sendto+0x70>
  804681:	c7 44 24 08 60 2d 81 	movl   $0x812d60,0x8(%esp)
  804688:	00 
  804689:	c7 44 24 04 97 02 00 	movl   $0x297,0x4(%esp)
  804690:	00 
  804691:	c7 04 24 b7 2c 81 00 	movl   $0x812cb7,(%esp)
  804698:	e8 4b c3 ff ff       	call   8009e8 <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  80469d:	85 f6                	test   %esi,%esi
  80469f:	0f 95 c0             	setne  %al
  8046a2:	75 06                	jne    8046aa <lwip_sendto+0x7d>
  8046a4:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8046a8:	74 2a                	je     8046d4 <lwip_sendto+0xa7>
  8046aa:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8046ae:	66 90                	xchg   %ax,%ax
  8046b0:	75 06                	jne    8046b8 <lwip_sendto+0x8b>
  8046b2:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8046b6:	74 1c                	je     8046d4 <lwip_sendto+0xa7>
  8046b8:	c7 44 24 08 dc 2c 81 	movl   $0x812cdc,0x8(%esp)
  8046bf:	00 
  8046c0:	c7 44 24 04 9b 02 00 	movl   $0x29b,0x4(%esp)
  8046c7:	00 
  8046c8:	c7 04 24 b7 2c 81 00 	movl   $0x812cb7,(%esp)
  8046cf:	e8 14 c3 ff ff       	call   8009e8 <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  8046d4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  8046db:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  8046e2:	84 c0                	test   %al,%al
  8046e4:	74 1e                	je     804704 <lwip_sendto+0xd7>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  8046e6:	8b 46 04             	mov    0x4(%esi),%eax
  8046e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  8046ec:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8046f0:	89 04 24             	mov    %eax,(%esp)
  8046f3:	e8 89 65 00 00       	call   80ac81 <ntohs>
    buf.addr         = &remote_addr;
  8046f8:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8046fb:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  8046fe:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  804702:	eb 14                	jmp    804718 <lwip_sendto+0xeb>
  } else {
    remote_addr.addr = 0;
  804704:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  80470b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  804712:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  804718:	0f b7 c7             	movzwl %di,%eax
  80471b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80471f:	8b 45 0c             	mov    0xc(%ebp),%eax
  804722:	89 44 24 04          	mov    %eax,0x4(%esp)
  804726:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  804729:	89 04 24             	mov    %eax,(%esp)
  80472c:	e8 ac 0e 00 00       	call   8055dd <netbuf_ref>
  804731:	0f be f0             	movsbl %al,%esi
  804734:	85 f6                	test   %esi,%esi
  804736:	75 14                	jne    80474c <lwip_sendto+0x11f>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  804738:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80473b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80473f:	8b 03                	mov    (%ebx),%eax
  804741:	89 04 24             	mov    %eax,(%esp)
  804744:	e8 ea 9e 00 00       	call   80e633 <netconn_send>
  804749:	0f be f0             	movsbl %al,%esi
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  80474c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80474f:	85 c0                	test   %eax,%eax
  804751:	74 08                	je     80475b <lwip_sendto+0x12e>
    pbuf_free(buf.p);
  804753:	89 04 24             	mov    %eax,(%esp)
  804756:	e8 1d 37 00 00       	call   807e78 <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  80475b:	89 f2                	mov    %esi,%edx
  80475d:	f7 da                	neg    %edx
  80475f:	b8 05 00 00 00       	mov    $0x5,%eax
  804764:	83 fa 0e             	cmp    $0xe,%edx
  804767:	77 07                	ja     804770 <lwip_sendto+0x143>
  804769:	8b 04 95 a0 2d 81 00 	mov    0x812da0(,%edx,4),%eax
  804770:	89 43 10             	mov    %eax,0x10(%ebx)
  804773:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  return (err==ERR_OK?size:-1);
  804778:	85 f6                	test   %esi,%esi
  80477a:	74 05                	je     804781 <lwip_sendto+0x154>
  80477c:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
  804781:	89 f8                	mov    %edi,%eax
  804783:	83 c4 3c             	add    $0x3c,%esp
  804786:	5b                   	pop    %ebx
  804787:	5e                   	pop    %esi
  804788:	5f                   	pop    %edi
  804789:	5d                   	pop    %ebp
  80478a:	c3                   	ret    

0080478b <lwip_recvfrom>:
}

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  80478b:	55                   	push   %ebp
  80478c:	89 e5                	mov    %esp,%ebp
  80478e:	57                   	push   %edi
  80478f:	56                   	push   %esi
  804790:	53                   	push   %ebx
  804791:	83 ec 5c             	sub    $0x5c,%esp
  804794:	8b 75 14             	mov    0x14(%ebp),%esi
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  804797:	8b 45 08             	mov    0x8(%ebp),%eax
  80479a:	e8 21 ed ff ff       	call   8034c0 <get_socket>
  80479f:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8047a1:	66 c7 45 c6 00 00    	movw   $0x0,-0x3a(%ebp)
  8047a7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8047ac:	85 db                	test   %ebx,%ebx
  8047ae:	0f 84 15 02 00 00    	je     8049c9 <lwip_recvfrom+0x23e>
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8047b4:	89 f0                	mov    %esi,%eax
  8047b6:	83 e0 08             	and    $0x8,%eax
  8047b9:	89 45 b0             	mov    %eax,-0x50(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8047bc:	83 e6 01             	and    $0x1,%esi
  8047bf:	89 75 b4             	mov    %esi,-0x4c(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  8047c2:	8b 73 04             	mov    0x4(%ebx),%esi
  8047c5:	85 f6                	test   %esi,%esi
  8047c7:	75 7d                	jne    804846 <lwip_recvfrom+0xbb>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8047c9:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  8047cd:	75 06                	jne    8047d5 <lwip_recvfrom+0x4a>
  8047cf:	f6 43 0f 08          	testb  $0x8,0xf(%ebx)
  8047d3:	74 22                	je     8047f7 <lwip_recvfrom+0x6c>
  8047d5:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  8047da:	75 1b                	jne    8047f7 <lwip_recvfrom+0x6c>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  8047dc:	c7 43 10 0b 00 00 00 	movl   $0xb,0x10(%ebx)
  8047e3:	c7 05 20 c2 b3 00 0b 	movl   $0xb,0xb3c220
  8047ea:	00 00 00 
  8047ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
        return -1;
  8047f2:	e9 d2 01 00 00       	jmp    8049c9 <lwip_recvfrom+0x23e>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  8047f7:	8b 03                	mov    (%ebx),%eax
  8047f9:	89 04 24             	mov    %eax,(%esp)
  8047fc:	e8 18 a1 00 00       	call   80e919 <netconn_recv>
  804801:	89 c6                	mov    %eax,%esi
  804803:	89 43 04             	mov    %eax,0x4(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  804806:	85 c0                	test   %eax,%eax
  804808:	75 3c                	jne    804846 <lwip_recvfrom+0xbb>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  80480a:	8b 13                	mov    (%ebx),%edx
  80480c:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  804810:	74 0b                	je     80481d <lwip_recvfrom+0x92>
  804812:	b8 6e 00 00 00       	mov    $0x6e,%eax
  804817:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  80481b:	74 17                	je     804834 <lwip_recvfrom+0xa9>
  80481d:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  804821:	f7 da                	neg    %edx
  804823:	b8 05 00 00 00       	mov    $0x5,%eax
  804828:	83 fa 0e             	cmp    $0xe,%edx
  80482b:	77 07                	ja     804834 <lwip_recvfrom+0xa9>
  80482d:	8b 04 95 a0 2d 81 00 	mov    0x812da0(,%edx,4),%eax
  804834:	89 43 10             	mov    %eax,0x10(%ebx)
  804837:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  80483c:	b8 00 00 00 00       	mov    $0x0,%eax
        return 0;
  804841:	e9 83 01 00 00       	jmp    8049c9 <lwip_recvfrom+0x23e>
      }
    }

    buflen = netbuf_len(buf);
  804846:	8b 06                	mov    (%esi),%eax
  804848:	0f b7 48 08          	movzwl 0x8(%eax),%ecx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  80484c:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  804850:	66 29 d1             	sub    %dx,%cx
  804853:	66 89 4d c0          	mov    %cx,-0x40(%ebp)

    if (len > buflen) {
  804857:	0f b7 c9             	movzwl %cx,%ecx
  80485a:	89 4d bc             	mov    %ecx,-0x44(%ebp)
      copylen = buflen;
    } else {
      copylen = len;
  80485d:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
    buflen = netbuf_len(buf);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;

    if (len > buflen) {
  804861:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  804864:	7e 04                	jle    80486a <lwip_recvfrom+0xdf>
  804866:	0f b7 7d c0          	movzwl -0x40(%ebp),%edi
      copylen = len;
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80486a:	0f b7 cf             	movzwl %di,%ecx
  80486d:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  804870:	0f b7 d2             	movzwl %dx,%edx
  804873:	89 54 24 0c          	mov    %edx,0xc(%esp)
  804877:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80487b:	0f b7 55 c6          	movzwl -0x3a(%ebp),%edx
  80487f:	03 55 0c             	add    0xc(%ebp),%edx
  804882:	89 54 24 04          	mov    %edx,0x4(%esp)
  804886:	89 04 24             	mov    %eax,(%esp)
  804889:	e8 68 33 00 00       	call   807bf6 <pbuf_copy_partial>

    off += copylen;
  80488e:	66 01 7d c6          	add    %di,-0x3a(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  804892:	8b 03                	mov    (%ebx),%eax
  804894:	89 04 24             	mov    %eax,(%esp)
  804897:	e8 a4 9c 00 00       	call   80e540 <netconn_type>
  80489c:	83 f8 10             	cmp    $0x10,%eax
  80489f:	75 1f                	jne    8048c0 <lwip_recvfrom+0x135>
      len -= copylen;
  8048a1:	8b 45 c0             	mov    -0x40(%ebp),%eax
  8048a4:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8048a7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8048ab:	7e 13                	jle    8048c0 <lwip_recvfrom+0x135>
  8048ad:	8b 06                	mov    (%esi),%eax
  8048af:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  8048b3:	75 0b                	jne    8048c0 <lwip_recvfrom+0x135>
  8048b5:	c6 45 bb 00          	movb   $0x0,-0x45(%ebp)
  8048b9:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  8048be:	75 04                	jne    8048c4 <lwip_recvfrom+0x139>
  8048c0:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8048c4:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8048c8:	75 39                	jne    804903 <lwip_recvfrom+0x178>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8048ca:	8b 03                	mov    (%ebx),%eax
  8048cc:	83 38 10             	cmpl   $0x10,(%eax)
  8048cf:	75 13                	jne    8048e4 <lwip_recvfrom+0x159>
  8048d1:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8048d4:	2b 45 c0             	sub    -0x40(%ebp),%eax
  8048d7:	85 c0                	test   %eax,%eax
  8048d9:	7e 09                	jle    8048e4 <lwip_recvfrom+0x159>
        sock->lastdata = buf;
  8048db:	89 73 04             	mov    %esi,0x4(%ebx)
        sock->lastoffset += copylen;
  8048de:	66 01 7b 08          	add    %di,0x8(%ebx)
    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8048e2:	eb 15                	jmp    8048f9 <lwip_recvfrom+0x16e>
        sock->lastdata = buf;
        sock->lastoffset += copylen;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
      } else {
        sock->lastdata = NULL;
  8048e4:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
        sock->lastoffset = 0;
  8048eb:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  8048f1:	89 34 24             	mov    %esi,(%esp)
  8048f4:	e8 a5 0c 00 00       	call   80559e <netbuf_delete>
      }
    } else {
      done = 1;
    }
  } while (!done);
  8048f9:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
  8048fd:	0f 84 bf fe ff ff    	je     8047c2 <lwip_recvfrom+0x37>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  804903:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  804907:	0f 84 a7 00 00 00    	je     8049b4 <lwip_recvfrom+0x229>
  80490d:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  804911:	0f 84 9d 00 00 00    	je     8049b4 <lwip_recvfrom+0x229>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  804917:	8b 03                	mov    (%ebx),%eax
  804919:	89 04 24             	mov    %eax,(%esp)
  80491c:	e8 1f 9c 00 00       	call   80e540 <netconn_type>
  804921:	83 f8 10             	cmp    $0x10,%eax
  804924:	75 22                	jne    804948 <lwip_recvfrom+0x1bd>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  804926:	8d 7d d8             	lea    -0x28(%ebp),%edi
      netconn_getaddr(sock->conn, addr, &port, 0);
  804929:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804930:	00 
  804931:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  804934:	89 44 24 08          	mov    %eax,0x8(%esp)
  804938:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80493c:	8b 03                	mov    (%ebx),%eax
  80493e:	89 04 24             	mov    %eax,(%esp)
  804941:	e8 ad 9e 00 00       	call   80e7f3 <netconn_getaddr>
  804946:	eb 0b                	jmp    804953 <lwip_recvfrom+0x1c8>
    } else {
      addr = netbuf_fromaddr(buf);
  804948:	8b 7e 08             	mov    0x8(%esi),%edi
      port = netbuf_fromport(buf);
  80494b:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80494f:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  804953:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  80495a:	00 
  80495b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804962:	00 
  804963:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  804966:	89 04 24             	mov    %eax,(%esp)
  804969:	e8 e8 cb ff ff       	call   801556 <memset>
    sin.sin_len = sizeof(sin);
  80496e:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  804972:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  804976:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80497a:	89 04 24             	mov    %eax,(%esp)
  80497d:	e8 f2 62 00 00       	call   80ac74 <htons>
  804982:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  804986:	8b 07                	mov    (%edi),%eax
  804988:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  80498b:	8b 55 1c             	mov    0x1c(%ebp),%edx
  80498e:	83 3a 10             	cmpl   $0x10,(%edx)
  804991:	76 06                	jbe    804999 <lwip_recvfrom+0x20e>
      *fromlen = sizeof(sin);
  804993:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

    SMEMCPY(from, &sin, *fromlen);
  804999:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  80499c:	8b 01                	mov    (%ecx),%eax
  80499e:	89 44 24 08          	mov    %eax,0x8(%esp)
  8049a2:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8049a5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8049a9:	8b 7d 18             	mov    0x18(%ebp),%edi
  8049ac:	89 3c 24             	mov    %edi,(%esp)
  8049af:	e8 7d cc ff ff       	call   801631 <memcpy>
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  8049b4:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8049bb:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8049c2:	00 00 00 
  return off;
  8049c5:	0f b7 45 c6          	movzwl -0x3a(%ebp),%eax
}
  8049c9:	83 c4 5c             	add    $0x5c,%esp
  8049cc:	5b                   	pop    %ebx
  8049cd:	5e                   	pop    %esi
  8049ce:	5f                   	pop    %edi
  8049cf:	5d                   	pop    %ebp
  8049d0:	c3                   	ret    

008049d1 <lwip_recv>:
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
}

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  8049d1:	55                   	push   %ebp
  8049d2:	89 e5                	mov    %esp,%ebp
  8049d4:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8049d7:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8049de:	00 
  8049df:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8049e6:	00 
  8049e7:	8b 45 14             	mov    0x14(%ebp),%eax
  8049ea:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8049ee:	8b 45 10             	mov    0x10(%ebp),%eax
  8049f1:	89 44 24 08          	mov    %eax,0x8(%esp)
  8049f5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8049f8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8049fc:	8b 45 08             	mov    0x8(%ebp),%eax
  8049ff:	89 04 24             	mov    %eax,(%esp)
  804a02:	e8 84 fd ff ff       	call   80478b <lwip_recvfrom>
}
  804a07:	c9                   	leave  
  804a08:	c3                   	ret    

00804a09 <lwip_read>:
  return off;
}

int
lwip_read(int s, void *mem, int len)
{
  804a09:	55                   	push   %ebp
  804a0a:	89 e5                	mov    %esp,%ebp
  804a0c:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  804a0f:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  804a16:	00 
  804a17:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  804a1e:	00 
  804a1f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804a26:	00 
  804a27:	8b 45 10             	mov    0x10(%ebp),%eax
  804a2a:	89 44 24 08          	mov    %eax,0x8(%esp)
  804a2e:	8b 45 0c             	mov    0xc(%ebp),%eax
  804a31:	89 44 24 04          	mov    %eax,0x4(%esp)
  804a35:	8b 45 08             	mov    0x8(%ebp),%eax
  804a38:	89 04 24             	mov    %eax,(%esp)
  804a3b:	e8 4b fd ff ff       	call   80478b <lwip_recvfrom>
}
  804a40:	c9                   	leave  
  804a41:	c3                   	ret    

00804a42 <lwip_close>:
  return 0;
}

int
lwip_close(int s)
{
  804a42:	55                   	push   %ebp
  804a43:	89 e5                	mov    %esp,%ebp
  804a45:	53                   	push   %ebx
  804a46:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  804a49:	8b 45 08             	mov    0x8(%ebp),%eax
  804a4c:	e8 6f ea ff ff       	call   8034c0 <get_socket>
  804a51:	89 c3                	mov    %eax,%ebx
  if (!sock) {
  804a53:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804a58:	85 db                	test   %ebx,%ebx
  804a5a:	74 5c                	je     804ab8 <lwip_close+0x76>
    return -1;
  }

  netconn_delete(sock->conn);
  804a5c:	8b 03                	mov    (%ebx),%eax
  804a5e:	89 04 24             	mov    %eax,(%esp)
  804a61:	e8 65 a0 00 00       	call   80eacb <netconn_delete>

  sys_sem_wait(socksem);
  804a66:	a1 24 63 81 00       	mov    0x816324,%eax
  804a6b:	89 04 24             	mov    %eax,(%esp)
  804a6e:	e8 e7 3a 00 00       	call   80855a <sys_sem_wait>
  if (sock->lastdata) {
  804a73:	8b 43 04             	mov    0x4(%ebx),%eax
  804a76:	85 c0                	test   %eax,%eax
  804a78:	74 08                	je     804a82 <lwip_close+0x40>
    netbuf_delete(sock->lastdata);
  804a7a:	89 04 24             	mov    %eax,(%esp)
  804a7d:	e8 1c 0b 00 00       	call   80559e <netbuf_delete>
  }
  sock->lastdata   = NULL;
  804a82:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  804a89:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  804a8f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  804a95:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804a9c:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  804aa3:	00 00 00 
  sys_sem_signal(socksem);
  804aa6:	a1 24 63 81 00       	mov    0x816324,%eax
  804aab:	89 04 24             	mov    %eax,(%esp)
  804aae:	e8 a4 90 00 00       	call   80db57 <sys_sem_signal>
  804ab3:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804ab8:	83 c4 14             	add    $0x14,%esp
  804abb:	5b                   	pop    %ebx
  804abc:	5d                   	pop    %ebp
  804abd:	c3                   	ret    

00804abe <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  804abe:	55                   	push   %ebp
  804abf:	89 e5                	mov    %esp,%ebp
  804ac1:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  804ac4:	8b 45 08             	mov    0x8(%ebp),%eax
  804ac7:	89 04 24             	mov    %eax,(%esp)
  804aca:	e8 73 ff ff ff       	call   804a42 <lwip_close>
}
  804acf:	c9                   	leave  
  804ad0:	c3                   	ret    

00804ad1 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  804ad1:	55                   	push   %ebp
  804ad2:	89 e5                	mov    %esp,%ebp
  804ad4:	56                   	push   %esi
  804ad5:	53                   	push   %ebx
  804ad6:	83 ec 10             	sub    $0x10,%esp
  804ad9:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  804adc:	8b 45 08             	mov    0x8(%ebp),%eax
  804adf:	e8 dc e9 ff ff       	call   8034c0 <get_socket>
  804ae4:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804ae6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804aeb:	85 db                	test   %ebx,%ebx
  804aed:	74 6a                	je     804b59 <lwip_listen+0x88>
  804aef:	89 f0                	mov    %esi,%eax
  804af1:	c1 f8 1f             	sar    $0x1f,%eax
  804af4:	f7 d0                	not    %eax
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  804af6:	21 c6                	and    %eax,%esi
  804af8:	81 fe ff 00 00 00    	cmp    $0xff,%esi
  804afe:	7e 05                	jle    804b05 <lwip_listen+0x34>
  804b00:	be ff 00 00 00       	mov    $0xff,%esi
  804b05:	81 e6 ff 00 00 00    	and    $0xff,%esi
  804b0b:	89 74 24 04          	mov    %esi,0x4(%esp)
  804b0f:	8b 03                	mov    (%ebx),%eax
  804b11:	89 04 24             	mov    %eax,(%esp)
  804b14:	e8 9a 9b 00 00       	call   80e6b3 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  804b19:	84 c0                	test   %al,%al
  804b1b:	74 26                	je     804b43 <lwip_listen+0x72>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  804b1d:	0f be c0             	movsbl %al,%eax
  804b20:	f7 d8                	neg    %eax
  804b22:	ba 05 00 00 00       	mov    $0x5,%edx
  804b27:	83 f8 0e             	cmp    $0xe,%eax
  804b2a:	77 07                	ja     804b33 <lwip_listen+0x62>
  804b2c:	8b 14 85 a0 2d 81 00 	mov    0x812da0(,%eax,4),%edx
  804b33:	89 53 10             	mov    %edx,0x10(%ebx)
  804b36:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  804b3c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  804b41:	eb 16                	jmp    804b59 <lwip_listen+0x88>
  }

  sock_set_errno(sock, 0);
  804b43:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804b4a:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  804b51:	00 00 00 
  804b54:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804b59:	83 c4 10             	add    $0x10,%esp
  804b5c:	5b                   	pop    %ebx
  804b5d:	5e                   	pop    %esi
  804b5e:	5d                   	pop    %ebp
  804b5f:	c3                   	ret    

00804b60 <lwip_connect>:
  return 0;
}

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  804b60:	55                   	push   %ebp
  804b61:	89 e5                	mov    %esp,%ebp
  804b63:	53                   	push   %ebx
  804b64:	83 ec 24             	sub    $0x24,%esp
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  804b67:	8b 45 08             	mov    0x8(%ebp),%eax
  804b6a:	e8 51 e9 ff ff       	call   8034c0 <get_socket>
  804b6f:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804b71:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804b76:	85 db                	test   %ebx,%ebx
  804b78:	0f 84 95 00 00 00    	je     804c13 <lwip_connect+0xb3>
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  804b7e:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  804b82:	75 09                	jne    804b8d <lwip_connect+0x2d>
  804b84:	8b 45 0c             	mov    0xc(%ebp),%eax
  804b87:	80 78 01 02          	cmpb   $0x2,0x1(%eax)
  804b8b:	74 1c                	je     804ba9 <lwip_connect+0x49>
  804b8d:	c7 44 24 08 f9 2c 81 	movl   $0x812cf9,0x8(%esp)
  804b94:	00 
  804b95:	c7 44 24 04 86 01 00 	movl   $0x186,0x4(%esp)
  804b9c:	00 
  804b9d:	c7 04 24 b7 2c 81 00 	movl   $0x812cb7,(%esp)
  804ba4:	e8 3f be ff ff       	call   8009e8 <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  804ba9:	8b 50 04             	mov    0x4(%eax),%edx
  804bac:	89 55 f4             	mov    %edx,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  804baf:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  804bb3:	89 04 24             	mov    %eax,(%esp)
  804bb6:	e8 c6 60 00 00       	call   80ac81 <ntohs>
  804bbb:	0f b7 c0             	movzwl %ax,%eax
  804bbe:	89 44 24 08          	mov    %eax,0x8(%esp)
  804bc2:	8d 45 f4             	lea    -0xc(%ebp),%eax
  804bc5:	89 44 24 04          	mov    %eax,0x4(%esp)
  804bc9:	8b 03                	mov    (%ebx),%eax
  804bcb:	89 04 24             	mov    %eax,(%esp)
  804bce:	e8 72 9b 00 00       	call   80e745 <netconn_connect>
  }

  if (err != ERR_OK) {
  804bd3:	84 c0                	test   %al,%al
  804bd5:	74 26                	je     804bfd <lwip_connect+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  804bd7:	0f be c0             	movsbl %al,%eax
  804bda:	f7 d8                	neg    %eax
  804bdc:	ba 05 00 00 00       	mov    $0x5,%edx
  804be1:	83 f8 0e             	cmp    $0xe,%eax
  804be4:	77 07                	ja     804bed <lwip_connect+0x8d>
  804be6:	8b 14 85 a0 2d 81 00 	mov    0x812da0(,%eax,4),%edx
  804bed:	89 53 10             	mov    %edx,0x10(%ebx)
  804bf0:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  804bf6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  804bfb:	eb 16                	jmp    804c13 <lwip_connect+0xb3>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  804bfd:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804c04:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  804c0b:	00 00 00 
  804c0e:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804c13:	83 c4 24             	add    $0x24,%esp
  804c16:	5b                   	pop    %ebx
  804c17:	5d                   	pop    %ebp
  804c18:	c3                   	ret    

00804c19 <lwip_bind>:
  return newsock;
}

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  804c19:	55                   	push   %ebp
  804c1a:	89 e5                	mov    %esp,%ebp
  804c1c:	53                   	push   %ebx
  804c1d:	83 ec 24             	sub    $0x24,%esp
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  804c20:	8b 45 08             	mov    0x8(%ebp),%eax
  804c23:	e8 98 e8 ff ff       	call   8034c0 <get_socket>
  804c28:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804c2a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804c2f:	85 db                	test   %ebx,%ebx
  804c31:	0f 84 95 00 00 00    	je     804ccc <lwip_bind+0xb3>
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  804c37:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  804c3b:	75 09                	jne    804c46 <lwip_bind+0x2d>
  804c3d:	8b 45 0c             	mov    0xc(%ebp),%eax
  804c40:	80 78 01 02          	cmpb   $0x2,0x1(%eax)
  804c44:	74 1c                	je     804c62 <lwip_bind+0x49>
  804c46:	c7 44 24 08 17 2d 81 	movl   $0x812d17,0x8(%esp)
  804c4d:	00 
  804c4e:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
  804c55:	00 
  804c56:	c7 04 24 b7 2c 81 00 	movl   $0x812cb7,(%esp)
  804c5d:	e8 86 bd ff ff       	call   8009e8 <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  804c62:	8b 50 04             	mov    0x4(%eax),%edx
  804c65:	89 55 f4             	mov    %edx,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  804c68:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  804c6c:	89 04 24             	mov    %eax,(%esp)
  804c6f:	e8 0d 60 00 00       	call   80ac81 <ntohs>
  804c74:	0f b7 c0             	movzwl %ax,%eax
  804c77:	89 44 24 08          	mov    %eax,0x8(%esp)
  804c7b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  804c7e:	89 44 24 04          	mov    %eax,0x4(%esp)
  804c82:	8b 03                	mov    (%ebx),%eax
  804c84:	89 04 24             	mov    %eax,(%esp)
  804c87:	e8 10 9b 00 00       	call   80e79c <netconn_bind>

  if (err != ERR_OK) {
  804c8c:	84 c0                	test   %al,%al
  804c8e:	74 26                	je     804cb6 <lwip_bind+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  804c90:	0f be c0             	movsbl %al,%eax
  804c93:	f7 d8                	neg    %eax
  804c95:	ba 05 00 00 00       	mov    $0x5,%edx
  804c9a:	83 f8 0e             	cmp    $0xe,%eax
  804c9d:	77 07                	ja     804ca6 <lwip_bind+0x8d>
  804c9f:	8b 14 85 a0 2d 81 00 	mov    0x812da0(,%eax,4),%edx
  804ca6:	89 53 10             	mov    %edx,0x10(%ebx)
  804ca9:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  804caf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  804cb4:	eb 16                	jmp    804ccc <lwip_bind+0xb3>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  804cb6:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804cbd:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  804cc4:	00 00 00 
  804cc7:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804ccc:	83 c4 24             	add    $0x24,%esp
  804ccf:	5b                   	pop    %ebx
  804cd0:	5d                   	pop    %ebp
  804cd1:	c3                   	ret    

00804cd2 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  804cd2:	55                   	push   %ebp
  804cd3:	89 e5                	mov    %esp,%ebp
  804cd5:	57                   	push   %edi
  804cd6:	56                   	push   %esi
  804cd7:	53                   	push   %ebx
  804cd8:	83 ec 4c             	sub    $0x4c,%esp
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  804cdb:	8b 45 08             	mov    0x8(%ebp),%eax
  804cde:	e8 dd e7 ff ff       	call   8034c0 <get_socket>
  804ce3:	89 c7                	mov    %eax,%edi
  if (!sock)
  804ce5:	be ff ff ff ff       	mov    $0xffffffff,%esi
  804cea:	85 c0                	test   %eax,%eax
  804cec:	0f 84 ae 01 00 00    	je     804ea0 <lwip_accept+0x1ce>
    return -1;

  newconn = netconn_accept(sock->conn);
  804cf2:	8b 00                	mov    (%eax),%eax
  804cf4:	89 04 24             	mov    %eax,(%esp)
  804cf7:	e8 93 9b 00 00       	call   80e88f <netconn_accept>
  804cfc:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  804cfe:	85 c0                	test   %eax,%eax
  804d00:	75 2b                	jne    804d2d <lwip_accept+0x5b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  804d02:	8b 07                	mov    (%edi),%eax
  804d04:	0f be 50 0c          	movsbl 0xc(%eax),%edx
  804d08:	f7 da                	neg    %edx
  804d0a:	b8 05 00 00 00       	mov    $0x5,%eax
  804d0f:	83 fa 0e             	cmp    $0xe,%edx
  804d12:	77 07                	ja     804d1b <lwip_accept+0x49>
  804d14:	8b 04 95 a0 2d 81 00 	mov    0x812da0(,%edx,4),%eax
  804d1b:	89 47 10             	mov    %eax,0x10(%edi)
  804d1e:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  804d23:	be ff ff ff ff       	mov    $0xffffffff,%esi
    return -1;
  804d28:	e9 73 01 00 00       	jmp    804ea0 <lwip_accept+0x1ce>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  804d2d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804d34:	00 
  804d35:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  804d38:	89 44 24 08          	mov    %eax,0x8(%esp)
  804d3c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  804d3f:	89 44 24 04          	mov    %eax,0x4(%esp)
  804d43:	89 1c 24             	mov    %ebx,(%esp)
  804d46:	e8 a8 9a 00 00       	call   80e7f3 <netconn_getaddr>
  804d4b:	89 c6                	mov    %eax,%esi
  if (err != ERR_OK) {
  804d4d:	84 c0                	test   %al,%al
  804d4f:	74 32                	je     804d83 <lwip_accept+0xb1>
    netconn_delete(newconn);
  804d51:	89 1c 24             	mov    %ebx,(%esp)
  804d54:	e8 72 9d 00 00       	call   80eacb <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  804d59:	89 f0                	mov    %esi,%eax
  804d5b:	0f be f0             	movsbl %al,%esi
  804d5e:	f7 de                	neg    %esi
  804d60:	b8 05 00 00 00       	mov    $0x5,%eax
  804d65:	83 fe 0e             	cmp    $0xe,%esi
  804d68:	77 07                	ja     804d71 <lwip_accept+0x9f>
  804d6a:	8b 04 b5 a0 2d 81 00 	mov    0x812da0(,%esi,4),%eax
  804d71:	89 47 10             	mov    %eax,0x10(%edi)
  804d74:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  804d79:	be ff ff ff ff       	mov    $0xffffffff,%esi
    return -1;
  804d7e:	e9 1d 01 00 00       	jmp    804ea0 <lwip_accept+0x1ce>
  }

  memset(&sin, 0, sizeof(sin));
  804d83:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  804d8a:	00 
  804d8b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804d92:	00 
  804d93:	8d 45 d0             	lea    -0x30(%ebp),%eax
  804d96:	89 04 24             	mov    %eax,(%esp)
  804d99:	e8 b8 c7 ff ff       	call   801556 <memset>
  sin.sin_len = sizeof(sin);
  804d9e:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  804da2:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  804da6:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  804daa:	89 04 24             	mov    %eax,(%esp)
  804dad:	e8 c2 5e 00 00       	call   80ac74 <htons>
  804db2:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  804db6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804db9:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  804dbc:	8b 55 10             	mov    0x10(%ebp),%edx
  804dbf:	83 3a 10             	cmpl   $0x10,(%edx)
  804dc2:	76 06                	jbe    804dca <lwip_accept+0xf8>
    *addrlen = sizeof(sin);
  804dc4:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

  SMEMCPY(addr, &sin, *addrlen);
  804dca:	8b 55 10             	mov    0x10(%ebp),%edx
  804dcd:	8b 02                	mov    (%edx),%eax
  804dcf:	89 44 24 08          	mov    %eax,0x8(%esp)
  804dd3:	8d 45 d0             	lea    -0x30(%ebp),%eax
  804dd6:	89 44 24 04          	mov    %eax,0x4(%esp)
  804dda:	8b 45 0c             	mov    0xc(%ebp),%eax
  804ddd:	89 04 24             	mov    %eax,(%esp)
  804de0:	e8 4c c8 ff ff       	call   801631 <memcpy>

  newsock = alloc_socket(newconn);
  804de5:	89 d8                	mov    %ebx,%eax
  804de7:	e8 6d f0 ff ff       	call   803e59 <alloc_socket>
  804dec:	89 c6                	mov    %eax,%esi
  if (newsock == -1) {
  804dee:	83 f8 ff             	cmp    $0xffffffff,%eax
  804df1:	75 1e                	jne    804e11 <lwip_accept+0x13f>
    netconn_delete(newconn);
  804df3:	89 1c 24             	mov    %ebx,(%esp)
  804df6:	e8 d0 9c 00 00       	call   80eacb <netconn_delete>
    sock_set_errno(sock, ENFILE);
  804dfb:	c7 47 10 17 00 00 00 	movl   $0x17,0x10(%edi)
  804e02:	c7 05 20 c2 b3 00 17 	movl   $0x17,0xb3c220
  804e09:	00 00 00 
    return -1;
  804e0c:	e9 8f 00 00 00       	jmp    804ea0 <lwip_accept+0x1ce>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  804e11:	83 fe 1f             	cmp    $0x1f,%esi
  804e14:	76 1c                	jbe    804e32 <lwip_accept+0x160>
  804e16:	c7 44 24 08 32 2d 81 	movl   $0x812d32,0x8(%esp)
  804e1d:	00 
  804e1e:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  804e25:	00 
  804e26:	c7 04 24 b7 2c 81 00 	movl   $0x812cb7,(%esp)
  804e2d:	e8 b6 bb ff ff       	call   8009e8 <_panic>
  newconn->callback = event_callback;
  804e32:	c7 43 2c 02 3f 80 00 	movl   $0x803f02,0x2c(%ebx)
  nsock = &sockets[newsock];
  804e39:	8d 04 80             	lea    (%eax,%eax,4),%eax
  804e3c:	8d 04 85 a0 60 81 00 	lea    0x8160a0(,%eax,4),%eax
  804e43:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  804e46:	85 c0                	test   %eax,%eax
  804e48:	75 1c                	jne    804e66 <lwip_accept+0x194>
  804e4a:	c7 44 24 08 47 2d 81 	movl   $0x812d47,0x8(%esp)
  804e51:	00 
  804e52:	c7 44 24 04 28 01 00 	movl   $0x128,0x4(%esp)
  804e59:	00 
  804e5a:	c7 04 24 b7 2c 81 00 	movl   $0x812cb7,(%esp)
  804e61:	e8 82 bb ff ff       	call   8009e8 <_panic>

  sys_sem_wait(socksem);
  804e66:	a1 24 63 81 00       	mov    0x816324,%eax
  804e6b:	89 04 24             	mov    %eax,(%esp)
  804e6e:	e8 e7 36 00 00       	call   80855a <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  804e73:	8b 43 1c             	mov    0x1c(%ebx),%eax
  804e76:	f7 d0                	not    %eax
  804e78:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  804e7b:	66 01 42 0a          	add    %ax,0xa(%edx)
  newconn->socket = newsock;
  804e7f:	89 73 1c             	mov    %esi,0x1c(%ebx)
  sys_sem_signal(socksem);
  804e82:	a1 24 63 81 00       	mov    0x816324,%eax
  804e87:	89 04 24             	mov    %eax,(%esp)
  804e8a:	e8 c8 8c 00 00       	call   80db57 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  804e8f:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  804e96:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  804e9d:	00 00 00 
  return newsock;
}
  804ea0:	89 f0                	mov    %esi,%eax
  804ea2:	83 c4 4c             	add    $0x4c,%esp
  804ea5:	5b                   	pop    %ebx
  804ea6:	5e                   	pop    %esi
  804ea7:	5f                   	pop    %edi
  804ea8:	5d                   	pop    %ebp
  804ea9:	c3                   	ret    
  804eaa:	00 00                	add    %al,(%eax)
  804eac:	00 00                	add    %al,(%eax)
	...

00804eb0 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  804eb0:	55                   	push   %ebp
  804eb1:	89 e5                	mov    %esp,%ebp
  804eb3:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  804eb6:	8b 45 08             	mov    0x8(%ebp),%eax
  804eb9:	89 04 24             	mov    %eax,(%esp)
  804ebc:	e8 b7 2f 00 00       	call   807e78 <pbuf_free>
}
  804ec1:	c9                   	leave  
  804ec2:	c3                   	ret    

00804ec3 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  804ec3:	55                   	push   %ebp
  804ec4:	89 e5                	mov    %esp,%ebp
  804ec6:	83 ec 28             	sub    $0x28,%esp
  lwip_init();
  804ec9:	e8 62 08 00 00       	call   805730 <lwip_init>

  tcpip_init_done = initfunc;
  804ece:	8b 45 08             	mov    0x8(%ebp),%eax
  804ed1:	a3 2c 63 81 00       	mov    %eax,0x81632c
  tcpip_init_done_arg = arg;
  804ed6:	8b 45 0c             	mov    0xc(%ebp),%eax
  804ed9:	a3 30 63 81 00       	mov    %eax,0x816330
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  804ede:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804ee5:	e8 55 8b 00 00       	call   80da3f <sys_mbox_new>
  804eea:	a3 3c 50 81 00       	mov    %eax,0x81503c
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  804eef:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  804ef6:	00 
  804ef7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804efe:	00 
  804eff:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804f06:	00 
  804f07:	c7 44 24 04 66 4f 80 	movl   $0x804f66,0x4(%esp)
  804f0e:	00 
  804f0f:	c7 04 24 e6 2d 81 00 	movl   $0x812de6,(%esp)
  804f16:	e8 8f 88 00 00       	call   80d7aa <sys_thread_new>
}
  804f1b:	c9                   	leave  
  804f1c:	c3                   	ret    

00804f1d <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  804f1d:	55                   	push   %ebp
  804f1e:	89 e5                	mov    %esp,%ebp
  804f20:	83 ec 18             	sub    $0x18,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  804f23:	83 3d 34 63 81 00 00 	cmpl   $0x0,0x816334
  804f2a:	75 38                	jne    804f64 <tcp_timer_needed+0x47>
  804f2c:	83 3d 0c f0 b3 00 00 	cmpl   $0x0,0xb3f00c
  804f33:	75 09                	jne    804f3e <tcp_timer_needed+0x21>
  804f35:	83 3d 20 f0 b3 00 00 	cmpl   $0x0,0xb3f020
  804f3c:	74 26                	je     804f64 <tcp_timer_needed+0x47>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  804f3e:	c7 05 34 63 81 00 01 	movl   $0x1,0x816334
  804f45:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  804f48:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804f4f:	00 
  804f50:	c7 44 24 04 81 53 80 	movl   $0x805381,0x4(%esp)
  804f57:	00 
  804f58:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  804f5f:	e8 26 35 00 00       	call   80848a <sys_timeout>
  }
}
  804f64:	c9                   	leave  
  804f65:	c3                   	ret    

00804f66 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  804f66:	55                   	push   %ebp
  804f67:	89 e5                	mov    %esp,%ebp
  804f69:	53                   	push   %ebx
  804f6a:	83 ec 24             	sub    $0x24,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  804f6d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804f74:	00 
  804f75:	c7 44 24 04 5e 51 80 	movl   $0x80515e,0x4(%esp)
  804f7c:	00 
  804f7d:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  804f84:	e8 01 35 00 00       	call   80848a <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  804f89:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804f90:	00 
  804f91:	c7 44 24 04 35 51 80 	movl   $0x805135,0x4(%esp)
  804f98:	00 
  804f99:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  804fa0:	e8 e5 34 00 00       	call   80848a <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  804fa5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804fac:	00 
  804fad:	c7 44 24 04 0c 51 80 	movl   $0x80510c,0x4(%esp)
  804fb4:	00 
  804fb5:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  804fbc:	e8 c9 34 00 00       	call   80848a <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  804fc1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804fc8:	00 
  804fc9:	c7 44 24 04 e3 50 80 	movl   $0x8050e3,0x4(%esp)
  804fd0:	00 
  804fd1:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  804fd8:	e8 ad 34 00 00       	call   80848a <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  804fdd:	a1 2c 63 81 00       	mov    0x81632c,%eax
  804fe2:	85 c0                	test   %eax,%eax
  804fe4:	74 0b                	je     804ff1 <tcpip_thread+0x8b>
    tcpip_init_done(tcpip_init_done_arg);
  804fe6:	8b 15 30 63 81 00    	mov    0x816330,%edx
  804fec:	89 14 24             	mov    %edx,(%esp)
  804fef:	ff d0                	call   *%eax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  804ff1:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  804ff4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  804ff8:	a1 3c 50 81 00       	mov    0x81503c,%eax
  804ffd:	89 04 24             	mov    %eax,(%esp)
  805000:	e8 77 36 00 00       	call   80867c <sys_mbox_fetch>
    switch (msg->type) {
  805005:	8b 45 f4             	mov    -0xc(%ebp),%eax
  805008:	8b 10                	mov    (%eax),%edx
  80500a:	83 fa 01             	cmp    $0x1,%edx
  80500d:	74 28                	je     805037 <tcpip_thread+0xd1>
  80500f:	83 fa 01             	cmp    $0x1,%edx
  805012:	72 16                	jb     80502a <tcpip_thread+0xc4>
  805014:	83 fa 02             	cmp    $0x2,%edx
  805017:	74 5f                	je     805078 <tcpip_thread+0x112>
  805019:	83 fa 03             	cmp    $0x3,%edx
  80501c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  805020:	75 d2                	jne    804ff4 <tcpip_thread+0x8e>
  805022:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  805028:	eb 6f                	jmp    805099 <tcpip_thread+0x133>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  80502a:	8b 40 08             	mov    0x8(%eax),%eax
  80502d:	8d 50 04             	lea    0x4(%eax),%edx
  805030:	89 14 24             	mov    %edx,(%esp)
  805033:	ff 10                	call   *(%eax)
      break;
  805035:	eb bd                	jmp    804ff4 <tcpip_thread+0x8e>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  805037:	8b 50 0c             	mov    0xc(%eax),%edx
  80503a:	f6 42 2e 20          	testb  $0x20,0x2e(%edx)
  80503e:	74 11                	je     805051 <tcpip_thread+0xeb>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  805040:	89 54 24 04          	mov    %edx,0x4(%esp)
  805044:	8b 40 08             	mov    0x8(%eax),%eax
  805047:	89 04 24             	mov    %eax,(%esp)
  80504a:	e8 78 83 00 00       	call   80d3c7 <ethernet_input>
  80504f:	eb 0f                	jmp    805060 <tcpip_thread+0xfa>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  805051:	89 54 24 04          	mov    %edx,0x4(%esp)
  805055:	8b 40 08             	mov    0x8(%eax),%eax
  805058:	89 04 24             	mov    %eax,(%esp)
  80505b:	e8 d4 4a 00 00       	call   809b34 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  805060:	8b 45 f4             	mov    -0xc(%ebp),%eax
  805063:	89 44 24 04          	mov    %eax,0x4(%esp)
  805067:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  80506e:	e8 6d 26 00 00       	call   8076e0 <memp_free>
      break;
  805073:	e9 7c ff ff ff       	jmp    804ff4 <tcpip_thread+0x8e>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  805078:	8b 50 0c             	mov    0xc(%eax),%edx
  80507b:	89 14 24             	mov    %edx,(%esp)
  80507e:	ff 50 08             	call   *0x8(%eax)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  805081:	8b 45 f4             	mov    -0xc(%ebp),%eax
  805084:	89 44 24 04          	mov    %eax,0x4(%esp)
  805088:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80508f:	e8 4c 26 00 00       	call   8076e0 <memp_free>
      break;
  805094:	e9 5b ff ff ff       	jmp    804ff4 <tcpip_thread+0x8e>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  805099:	8b 50 08             	mov    0x8(%eax),%edx
  80509c:	83 fa ff             	cmp    $0xffffffff,%edx
  80509f:	74 18                	je     8050b9 <tcpip_thread+0x153>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  8050a1:	8b 48 10             	mov    0x10(%eax),%ecx
  8050a4:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8050a8:	8b 40 0c             	mov    0xc(%eax),%eax
  8050ab:	89 44 24 04          	mov    %eax,0x4(%esp)
  8050af:	89 14 24             	mov    %edx,(%esp)
  8050b2:	e8 d3 33 00 00       	call   80848a <sys_timeout>
  8050b7:	eb 12                	jmp    8050cb <tcpip_thread+0x165>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  8050b9:	8b 50 10             	mov    0x10(%eax),%edx
  8050bc:	89 54 24 04          	mov    %edx,0x4(%esp)
  8050c0:	8b 40 0c             	mov    0xc(%eax),%eax
  8050c3:	89 04 24             	mov    %eax,(%esp)
  8050c6:	e8 32 33 00 00       	call   8083fd <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8050cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8050ce:	89 44 24 04          	mov    %eax,0x4(%esp)
  8050d2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8050d9:	e8 02 26 00 00       	call   8076e0 <memp_free>
  8050de:	e9 11 ff ff ff       	jmp    804ff4 <tcpip_thread+0x8e>

008050e3 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  8050e3:	55                   	push   %ebp
  8050e4:	89 e5                	mov    %esp,%ebp
  8050e6:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  8050e9:	e8 f4 1e 00 00       	call   806fe2 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8050ee:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8050f5:	00 
  8050f6:	c7 44 24 04 e3 50 80 	movl   $0x8050e3,0x4(%esp)
  8050fd:	00 
  8050fe:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  805105:	e8 80 33 00 00       	call   80848a <sys_timeout>
}
  80510a:	c9                   	leave  
  80510b:	c3                   	ret    

0080510c <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  80510c:	55                   	push   %ebp
  80510d:	89 e5                	mov    %esp,%ebp
  80510f:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  805112:	e8 92 12 00 00       	call   8063a9 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  805117:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80511e:	00 
  80511f:	c7 44 24 04 0c 51 80 	movl   $0x80510c,0x4(%esp)
  805126:	00 
  805127:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  80512e:	e8 57 33 00 00       	call   80848a <sys_timeout>
}
  805133:	c9                   	leave  
  805134:	c3                   	ret    

00805135 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  805135:	55                   	push   %ebp
  805136:	89 e5                	mov    %esp,%ebp
  805138:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  80513b:	e8 5c 7e 00 00       	call   80cf9c <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  805140:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805147:	00 
  805148:	c7 44 24 04 35 51 80 	movl   $0x805135,0x4(%esp)
  80514f:	00 
  805150:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  805157:	e8 2e 33 00 00       	call   80848a <sys_timeout>
}
  80515c:	c9                   	leave  
  80515d:	c3                   	ret    

0080515e <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  80515e:	55                   	push   %ebp
  80515f:	89 e5                	mov    %esp,%ebp
  805161:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  805164:	e8 ac 50 00 00       	call   80a215 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  805169:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805170:	00 
  805171:	c7 44 24 04 5e 51 80 	movl   $0x80515e,0x4(%esp)
  805178:	00 
  805179:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  805180:	e8 05 33 00 00       	call   80848a <sys_timeout>
}
  805185:	c9                   	leave  
  805186:	c3                   	ret    

00805187 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  805187:	55                   	push   %ebp
  805188:	89 e5                	mov    %esp,%ebp
  80518a:	53                   	push   %ebx
  80518b:	83 ec 34             	sub    $0x34,%esp
  80518e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  805191:	8b 15 3c 50 81 00    	mov    0x81503c,%edx
  805197:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80519c:	83 fa ff             	cmp    $0xffffffff,%edx
  80519f:	74 34                	je     8051d5 <tcpip_apimsg+0x4e>
    msg.type = TCPIP_MSG_API;
  8051a1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  8051a8:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  8051ab:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8051ae:	89 44 24 04          	mov    %eax,0x4(%esp)
  8051b2:	89 14 24             	mov    %edx,(%esp)
  8051b5:	e8 06 8c 00 00       	call   80ddc0 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  8051ba:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8051c1:	00 
  8051c2:	8b 43 04             	mov    0x4(%ebx),%eax
  8051c5:	8b 40 10             	mov    0x10(%eax),%eax
  8051c8:	89 04 24             	mov    %eax,(%esp)
  8051cb:	e8 96 86 00 00       	call   80d866 <sys_arch_sem_wait>
  8051d0:	b8 00 00 00 00       	mov    $0x0,%eax
    return ERR_OK;
  }
  return ERR_VAL;
}
  8051d5:	83 c4 34             	add    $0x34,%esp
  8051d8:	5b                   	pop    %ebx
  8051d9:	5d                   	pop    %ebp
  8051da:	c3                   	ret    

008051db <tcpip_timeout>:
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8051db:	55                   	push   %ebp
  8051dc:	89 e5                	mov    %esp,%ebp
  8051de:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8051e1:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8051e6:	83 3d 3c 50 81 00 ff 	cmpl   $0xffffffff,0x81503c
  8051ed:	74 45                	je     805234 <tcpip_timeout+0x59>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8051ef:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8051f6:	e8 29 25 00 00       	call   807724 <memp_malloc>
  8051fb:	89 c2                	mov    %eax,%edx
    if (msg == NULL) {
  8051fd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805202:	85 d2                	test   %edx,%edx
  805204:	74 2e                	je     805234 <tcpip_timeout+0x59>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  805206:	c7 02 03 00 00 00    	movl   $0x3,(%edx)
    msg->msg.tmo.msecs = msecs;
  80520c:	8b 45 08             	mov    0x8(%ebp),%eax
  80520f:	89 42 08             	mov    %eax,0x8(%edx)
    msg->msg.tmo.h = h;
  805212:	8b 45 0c             	mov    0xc(%ebp),%eax
  805215:	89 42 0c             	mov    %eax,0xc(%edx)
    msg->msg.tmo.arg = arg;
  805218:	8b 45 10             	mov    0x10(%ebp),%eax
  80521b:	89 42 10             	mov    %eax,0x10(%edx)
    sys_mbox_post(mbox, msg);
  80521e:	89 54 24 04          	mov    %edx,0x4(%esp)
  805222:	a1 3c 50 81 00       	mov    0x81503c,%eax
  805227:	89 04 24             	mov    %eax,(%esp)
  80522a:	e8 91 8b 00 00       	call   80ddc0 <sys_mbox_post>
  80522f:	b8 00 00 00 00       	mov    $0x0,%eax
    return ERR_OK;
  }
  return ERR_VAL;
}
  805234:	c9                   	leave  
  805235:	c3                   	ret    

00805236 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  805236:	55                   	push   %ebp
  805237:	89 e5                	mov    %esp,%ebp
  805239:	83 ec 18             	sub    $0x18,%esp
  80523c:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80523f:	89 75 fc             	mov    %esi,-0x4(%ebp)
  805242:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  805246:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80524b:	83 3d 3c 50 81 00 ff 	cmpl   $0xffffffff,0x81503c
  805252:	74 6f                	je     8052c3 <tcpip_callback_with_block+0x8d>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  805254:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80525b:	e8 c4 24 00 00       	call   807724 <memp_malloc>
  805260:	89 c6                	mov    %eax,%esi
    if (msg == NULL) {
  805262:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805267:	85 f6                	test   %esi,%esi
  805269:	74 58                	je     8052c3 <tcpip_callback_with_block+0x8d>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  80526b:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
    msg->msg.cb.f = f;
  805271:	8b 45 08             	mov    0x8(%ebp),%eax
  805274:	89 46 08             	mov    %eax,0x8(%esi)
    msg->msg.cb.ctx = ctx;
  805277:	8b 45 0c             	mov    0xc(%ebp),%eax
  80527a:	89 46 0c             	mov    %eax,0xc(%esi)
    if (block) {
  80527d:	84 db                	test   %bl,%bl
  80527f:	74 18                	je     805299 <tcpip_callback_with_block+0x63>
      sys_mbox_post(mbox, msg);
  805281:	89 74 24 04          	mov    %esi,0x4(%esp)
  805285:	a1 3c 50 81 00       	mov    0x81503c,%eax
  80528a:	89 04 24             	mov    %eax,(%esp)
  80528d:	e8 2e 8b 00 00       	call   80ddc0 <sys_mbox_post>
  805292:	b8 00 00 00 00       	mov    $0x0,%eax
  805297:	eb 2a                	jmp    8052c3 <tcpip_callback_with_block+0x8d>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  805299:	89 74 24 04          	mov    %esi,0x4(%esp)
  80529d:	a1 3c 50 81 00       	mov    0x81503c,%eax
  8052a2:	89 04 24             	mov    %eax,(%esp)
  8052a5:	e8 48 8a 00 00       	call   80dcf2 <sys_mbox_trypost>
  8052aa:	84 c0                	test   %al,%al
  8052ac:	74 15                	je     8052c3 <tcpip_callback_with_block+0x8d>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  8052ae:	89 74 24 04          	mov    %esi,0x4(%esp)
  8052b2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8052b9:	e8 22 24 00 00       	call   8076e0 <memp_free>
  8052be:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  8052c3:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8052c6:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8052c9:	89 ec                	mov    %ebp,%esp
  8052cb:	5d                   	pop    %ebp
  8052cc:	c3                   	ret    

008052cd <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  8052cd:	55                   	push   %ebp
  8052ce:	89 e5                	mov    %esp,%ebp
  8052d0:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  8052d3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8052da:	00 
  8052db:	8b 45 08             	mov    0x8(%ebp),%eax
  8052de:	89 44 24 04          	mov    %eax,0x4(%esp)
  8052e2:	c7 04 24 6e 74 80 00 	movl   $0x80746e,(%esp)
  8052e9:	e8 48 ff ff ff       	call   805236 <tcpip_callback_with_block>
}
  8052ee:	c9                   	leave  
  8052ef:	c3                   	ret    

008052f0 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  8052f0:	55                   	push   %ebp
  8052f1:	89 e5                	mov    %esp,%ebp
  8052f3:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8052f6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8052fd:	00 
  8052fe:	8b 45 08             	mov    0x8(%ebp),%eax
  805301:	89 44 24 04          	mov    %eax,0x4(%esp)
  805305:	c7 04 24 b0 4e 80 00 	movl   $0x804eb0,(%esp)
  80530c:	e8 25 ff ff ff       	call   805236 <tcpip_callback_with_block>
}
  805311:	c9                   	leave  
  805312:	c3                   	ret    

00805313 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  805313:	55                   	push   %ebp
  805314:	89 e5                	mov    %esp,%ebp
  805316:	53                   	push   %ebx
  805317:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80531a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80531f:	83 3d 3c 50 81 00 ff 	cmpl   $0xffffffff,0x81503c
  805326:	74 53                	je     80537b <tcpip_input+0x68>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  805328:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  80532f:	e8 f0 23 00 00       	call   807724 <memp_malloc>
  805334:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  805336:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80533b:	85 db                	test   %ebx,%ebx
  80533d:	74 3c                	je     80537b <tcpip_input+0x68>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  80533f:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
    msg->msg.inp.p = p;
  805345:	8b 45 08             	mov    0x8(%ebp),%eax
  805348:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  80534b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80534e:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  805351:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805355:	a1 3c 50 81 00       	mov    0x81503c,%eax
  80535a:	89 04 24             	mov    %eax,(%esp)
  80535d:	e8 90 89 00 00       	call   80dcf2 <sys_mbox_trypost>
  805362:	84 c0                	test   %al,%al
  805364:	74 15                	je     80537b <tcpip_input+0x68>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  805366:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80536a:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  805371:	e8 6a 23 00 00       	call   8076e0 <memp_free>
  805376:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  80537b:	83 c4 14             	add    $0x14,%esp
  80537e:	5b                   	pop    %ebx
  80537f:	5d                   	pop    %ebp
  805380:	c3                   	ret    

00805381 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  805381:	55                   	push   %ebp
  805382:	89 e5                	mov    %esp,%ebp
  805384:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  805387:	e8 2c 43 00 00       	call   8096b8 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  80538c:	83 3d 0c f0 b3 00 00 	cmpl   $0x0,0xb3f00c
  805393:	75 09                	jne    80539e <tcpip_tcp_timer+0x1d>
  805395:	83 3d 20 f0 b3 00 00 	cmpl   $0x0,0xb3f020
  80539c:	74 1e                	je     8053bc <tcpip_tcp_timer+0x3b>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80539e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8053a5:	00 
  8053a6:	c7 44 24 04 81 53 80 	movl   $0x805381,0x4(%esp)
  8053ad:	00 
  8053ae:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  8053b5:	e8 d0 30 00 00       	call   80848a <sys_timeout>
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  8053ba:	eb 0a                	jmp    8053c6 <tcpip_tcp_timer+0x45>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  8053bc:	c7 05 34 63 81 00 00 	movl   $0x0,0x816334
  8053c3:	00 00 00 
  }
}
  8053c6:	c9                   	leave  
  8053c7:	c3                   	ret    

008053c8 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8053c8:	55                   	push   %ebp
  8053c9:	89 e5                	mov    %esp,%ebp
  8053cb:	83 ec 18             	sub    $0x18,%esp
  8053ce:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8053d1:	85 c0                	test   %eax,%eax
  8053d3:	75 1c                	jne    8053f1 <netbuf_first+0x29>
  8053d5:	c7 44 24 08 f3 2d 81 	movl   $0x812df3,0x8(%esp)
  8053dc:	00 
  8053dd:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
  8053e4:	00 
  8053e5:	c7 04 24 0c 2e 81 00 	movl   $0x812e0c,(%esp)
  8053ec:	e8 f7 b5 ff ff       	call   8009e8 <_panic>
  buf->ptr = buf->p;
  8053f1:	8b 10                	mov    (%eax),%edx
  8053f3:	89 50 04             	mov    %edx,0x4(%eax)
}
  8053f6:	c9                   	leave  
  8053f7:	c3                   	ret    

008053f8 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  8053f8:	55                   	push   %ebp
  8053f9:	89 e5                	mov    %esp,%ebp
  8053fb:	83 ec 18             	sub    $0x18,%esp
  8053fe:	8b 55 08             	mov    0x8(%ebp),%edx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  805401:	85 d2                	test   %edx,%edx
  805403:	75 1c                	jne    805421 <netbuf_next+0x29>
  805405:	c7 44 24 08 f3 2d 81 	movl   $0x812df3,0x8(%esp)
  80540c:	00 
  80540d:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
  805414:	00 
  805415:	c7 04 24 0c 2e 81 00 	movl   $0x812e0c,(%esp)
  80541c:	e8 c7 b5 ff ff       	call   8009e8 <_panic>
  if (buf->ptr->next == NULL) {
  805421:	8b 42 04             	mov    0x4(%edx),%eax
  805424:	8b 08                	mov    (%eax),%ecx
  805426:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80542b:	85 c9                	test   %ecx,%ecx
  80542d:	74 09                	je     805438 <netbuf_next+0x40>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  80542f:	89 4a 04             	mov    %ecx,0x4(%edx)
  805432:	83 39 00             	cmpl   $0x0,(%ecx)
  805435:	0f 94 c0             	sete   %al
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  805438:	c9                   	leave  
  805439:	c3                   	ret    

0080543a <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  80543a:	55                   	push   %ebp
  80543b:	89 e5                	mov    %esp,%ebp
  80543d:	56                   	push   %esi
  80543e:	53                   	push   %ebx
  80543f:	83 ec 10             	sub    $0x10,%esp
  805442:	8b 55 08             	mov    0x8(%ebp),%edx
  805445:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  805448:	8b 4d 10             	mov    0x10(%ebp),%ecx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  80544b:	85 d2                	test   %edx,%edx
  80544d:	75 1c                	jne    80546b <netbuf_data+0x31>
  80544f:	c7 44 24 08 22 2e 81 	movl   $0x812e22,0x8(%esp)
  805456:	00 
  805457:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  80545e:	00 
  80545f:	c7 04 24 0c 2e 81 00 	movl   $0x812e0c,(%esp)
  805466:	e8 7d b5 ff ff       	call   8009e8 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  80546b:	85 db                	test   %ebx,%ebx
  80546d:	75 1c                	jne    80548b <netbuf_data+0x51>
  80546f:	c7 44 24 08 3b 2e 81 	movl   $0x812e3b,0x8(%esp)
  805476:	00 
  805477:	c7 44 24 04 ba 00 00 	movl   $0xba,0x4(%esp)
  80547e:	00 
  80547f:	c7 04 24 0c 2e 81 00 	movl   $0x812e0c,(%esp)
  805486:	e8 5d b5 ff ff       	call   8009e8 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  80548b:	85 c9                	test   %ecx,%ecx
  80548d:	75 1c                	jne    8054ab <netbuf_data+0x71>
  80548f:	c7 44 24 08 58 2e 81 	movl   $0x812e58,0x8(%esp)
  805496:	00 
  805497:	c7 44 24 04 bb 00 00 	movl   $0xbb,0x4(%esp)
  80549e:	00 
  80549f:	c7 04 24 0c 2e 81 00 	movl   $0x812e0c,(%esp)
  8054a6:	e8 3d b5 ff ff       	call   8009e8 <_panic>

  if (buf->ptr == NULL) {
  8054ab:	8b 72 04             	mov    0x4(%edx),%esi
  8054ae:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8054b3:	85 f6                	test   %esi,%esi
  8054b5:	74 14                	je     8054cb <netbuf_data+0x91>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  8054b7:	8b 46 04             	mov    0x4(%esi),%eax
  8054ba:	89 03                	mov    %eax,(%ebx)
  *len = buf->ptr->len;
  8054bc:	8b 42 04             	mov    0x4(%edx),%eax
  8054bf:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  8054c3:	66 89 01             	mov    %ax,(%ecx)
  8054c6:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  8054cb:	83 c4 10             	add    $0x10,%esp
  8054ce:	5b                   	pop    %ebx
  8054cf:	5e                   	pop    %esi
  8054d0:	5d                   	pop    %ebp
  8054d1:	c3                   	ret    

008054d2 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  8054d2:	55                   	push   %ebp
  8054d3:	89 e5                	mov    %esp,%ebp
  8054d5:	83 ec 18             	sub    $0x18,%esp
  8054d8:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8054db:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8054de:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8054e1:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8054e4:	85 db                	test   %ebx,%ebx
  8054e6:	75 1c                	jne    805504 <netbuf_chain+0x32>
  8054e8:	c7 44 24 08 71 2e 81 	movl   $0x812e71,0x8(%esp)
  8054ef:	00 
  8054f0:	c7 44 24 04 a6 00 00 	movl   $0xa6,0x4(%esp)
  8054f7:	00 
  8054f8:	c7 04 24 0c 2e 81 00 	movl   $0x812e0c,(%esp)
  8054ff:	e8 e4 b4 ff ff       	call   8009e8 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  805504:	85 f6                	test   %esi,%esi
  805506:	75 1c                	jne    805524 <netbuf_chain+0x52>
  805508:	c7 44 24 08 8a 2e 81 	movl   $0x812e8a,0x8(%esp)
  80550f:	00 
  805510:	c7 44 24 04 a7 00 00 	movl   $0xa7,0x4(%esp)
  805517:	00 
  805518:	c7 04 24 0c 2e 81 00 	movl   $0x812e0c,(%esp)
  80551f:	e8 c4 b4 ff ff       	call   8009e8 <_panic>
  pbuf_chain(head->p, tail->p);
  805524:	8b 06                	mov    (%esi),%eax
  805526:	89 44 24 04          	mov    %eax,0x4(%esp)
  80552a:	8b 03                	mov    (%ebx),%eax
  80552c:	89 04 24             	mov    %eax,(%esp)
  80552f:	e8 a8 25 00 00       	call   807adc <pbuf_chain>
  head->ptr = head->p;
  805534:	8b 03                	mov    (%ebx),%eax
  805536:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  805539:	89 74 24 04          	mov    %esi,0x4(%esp)
  80553d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  805544:	e8 97 21 00 00       	call   8076e0 <memp_free>
}
  805549:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80554c:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80554f:	89 ec                	mov    %ebp,%esp
  805551:	5d                   	pop    %ebp
  805552:	c3                   	ret    

00805553 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  805553:	55                   	push   %ebp
  805554:	89 e5                	mov    %esp,%ebp
  805556:	53                   	push   %ebx
  805557:	83 ec 14             	sub    $0x14,%esp
  80555a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80555d:	85 db                	test   %ebx,%ebx
  80555f:	75 1c                	jne    80557d <netbuf_free+0x2a>
  805561:	c7 44 24 08 f3 2d 81 	movl   $0x812df3,0x8(%esp)
  805568:	00 
  805569:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  805570:	00 
  805571:	c7 04 24 0c 2e 81 00 	movl   $0x812e0c,(%esp)
  805578:	e8 6b b4 ff ff       	call   8009e8 <_panic>
  if (buf->p != NULL) {
  80557d:	8b 03                	mov    (%ebx),%eax
  80557f:	85 c0                	test   %eax,%eax
  805581:	74 08                	je     80558b <netbuf_free+0x38>
    pbuf_free(buf->p);
  805583:	89 04 24             	mov    %eax,(%esp)
  805586:	e8 ed 28 00 00       	call   807e78 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  80558b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  805592:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  805598:	83 c4 14             	add    $0x14,%esp
  80559b:	5b                   	pop    %ebx
  80559c:	5d                   	pop    %ebp
  80559d:	c3                   	ret    

0080559e <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  80559e:	55                   	push   %ebp
  80559f:	89 e5                	mov    %esp,%ebp
  8055a1:	53                   	push   %ebx
  8055a2:	83 ec 14             	sub    $0x14,%esp
  8055a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  8055a8:	85 db                	test   %ebx,%ebx
  8055aa:	74 2b                	je     8055d7 <netbuf_delete+0x39>
    if (buf->p != NULL) {
  8055ac:	8b 03                	mov    (%ebx),%eax
  8055ae:	85 c0                	test   %eax,%eax
  8055b0:	74 15                	je     8055c7 <netbuf_delete+0x29>
      pbuf_free(buf->p);
  8055b2:	89 04 24             	mov    %eax,(%esp)
  8055b5:	e8 be 28 00 00       	call   807e78 <pbuf_free>
      buf->p = buf->ptr = NULL;
  8055ba:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8055c1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    }
    memp_free(MEMP_NETBUF, buf);
  8055c7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8055cb:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  8055d2:	e8 09 21 00 00       	call   8076e0 <memp_free>
  }
}
  8055d7:	83 c4 14             	add    $0x14,%esp
  8055da:	5b                   	pop    %ebx
  8055db:	5d                   	pop    %ebp
  8055dc:	c3                   	ret    

008055dd <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  8055dd:	55                   	push   %ebp
  8055de:	89 e5                	mov    %esp,%ebp
  8055e0:	56                   	push   %esi
  8055e1:	53                   	push   %ebx
  8055e2:	83 ec 10             	sub    $0x10,%esp
  8055e5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8055e8:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8055ec:	85 db                	test   %ebx,%ebx
  8055ee:	75 1c                	jne    80560c <netbuf_ref+0x2f>
  8055f0:	c7 44 24 08 a5 2e 81 	movl   $0x812ea5,0x8(%esp)
  8055f7:	00 
  8055f8:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  8055ff:	00 
  805600:	c7 04 24 0c 2e 81 00 	movl   $0x812e0c,(%esp)
  805607:	e8 dc b3 ff ff       	call   8009e8 <_panic>
  if (buf->p != NULL) {
  80560c:	8b 03                	mov    (%ebx),%eax
  80560e:	85 c0                	test   %eax,%eax
  805610:	74 08                	je     80561a <netbuf_ref+0x3d>
    pbuf_free(buf->p);
  805612:	89 04 24             	mov    %eax,(%esp)
  805615:	e8 5e 28 00 00       	call   807e78 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  80561a:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  805621:	00 
  805622:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805629:	00 
  80562a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805631:	e8 fd 2a 00 00       	call   808133 <pbuf_alloc>
  805636:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  805638:	85 c0                	test   %eax,%eax
  80563a:	75 0e                	jne    80564a <netbuf_ref+0x6d>
    buf->ptr = NULL;
  80563c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  805643:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  805648:	eb 1a                	jmp    805664 <netbuf_ref+0x87>
  }
  buf->p->payload = (void*)dataptr;
  80564a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80564d:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  805650:	8b 03                	mov    (%ebx),%eax
  805652:	66 89 70 08          	mov    %si,0x8(%eax)
  805656:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  80565a:	8b 03                	mov    (%ebx),%eax
  80565c:	89 43 04             	mov    %eax,0x4(%ebx)
  80565f:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  805664:	83 c4 10             	add    $0x10,%esp
  805667:	5b                   	pop    %ebx
  805668:	5e                   	pop    %esi
  805669:	5d                   	pop    %ebp
  80566a:	c3                   	ret    

0080566b <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  80566b:	55                   	push   %ebp
  80566c:	89 e5                	mov    %esp,%ebp
  80566e:	56                   	push   %esi
  80566f:	53                   	push   %ebx
  805670:	83 ec 10             	sub    $0x10,%esp
  805673:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805676:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80567a:	85 db                	test   %ebx,%ebx
  80567c:	75 1c                	jne    80569a <netbuf_alloc+0x2f>
  80567e:	c7 44 24 08 bd 2e 81 	movl   $0x812ebd,0x8(%esp)
  805685:	00 
  805686:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  80568d:	00 
  80568e:	c7 04 24 0c 2e 81 00 	movl   $0x812e0c,(%esp)
  805695:	e8 4e b3 ff ff       	call   8009e8 <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  80569a:	8b 03                	mov    (%ebx),%eax
  80569c:	85 c0                	test   %eax,%eax
  80569e:	74 08                	je     8056a8 <netbuf_alloc+0x3d>
    pbuf_free(buf->p);
  8056a0:	89 04 24             	mov    %eax,(%esp)
  8056a3:	e8 d0 27 00 00       	call   807e78 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  8056a8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8056af:	00 
  8056b0:	0f b7 c6             	movzwl %si,%eax
  8056b3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8056b7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8056be:	e8 70 2a 00 00       	call   808133 <pbuf_alloc>
  8056c3:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8056c5:	ba 00 00 00 00       	mov    $0x0,%edx
  8056ca:	85 c0                	test   %eax,%eax
  8056cc:	74 28                	je     8056f6 <netbuf_alloc+0x8b>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8056ce:	66 3b 70 0a          	cmp    0xa(%eax),%si
  8056d2:	76 1c                	jbe    8056f0 <netbuf_alloc+0x85>
  8056d4:	c7 44 24 08 d8 2e 81 	movl   $0x812ed8,0x8(%esp)
  8056db:	00 
  8056dc:	c7 44 24 04 6e 00 00 	movl   $0x6e,0x4(%esp)
  8056e3:	00 
  8056e4:	c7 04 24 0c 2e 81 00 	movl   $0x812e0c,(%esp)
  8056eb:	e8 f8 b2 ff ff       	call   8009e8 <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8056f0:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  8056f3:	8b 50 04             	mov    0x4(%eax),%edx
}
  8056f6:	89 d0                	mov    %edx,%eax
  8056f8:	83 c4 10             	add    $0x10,%esp
  8056fb:	5b                   	pop    %ebx
  8056fc:	5e                   	pop    %esi
  8056fd:	5d                   	pop    %ebp
  8056fe:	c3                   	ret    

008056ff <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  8056ff:	55                   	push   %ebp
  805700:	89 e5                	mov    %esp,%ebp
  805702:	83 ec 18             	sub    $0x18,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  805705:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80570c:	e8 13 20 00 00       	call   807724 <memp_malloc>
  if (buf != NULL) {
  805711:	85 c0                	test   %eax,%eax
  805713:	74 14                	je     805729 <netbuf_new+0x2a>
    buf->p = NULL;
  805715:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  80571b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  805722:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  805729:	c9                   	leave  
  80572a:	c3                   	ret    
  80572b:	00 00                	add    %al,(%eax)
  80572d:	00 00                	add    %al,(%eax)
	...

00805730 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  805730:	55                   	push   %ebp
  805731:	89 e5                	mov    %esp,%ebp
  805733:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  805736:	e8 35 7d 00 00       	call   80d470 <sys_init>
  mem_init();
  80573b:	e8 be 1e 00 00       	call   8075fe <mem_init>
  memp_init();
  805740:	e8 17 1f 00 00       	call   80765c <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  805745:	e8 52 e9 ff ff       	call   80409c <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  80574a:	c9                   	leave  
  80574b:	c3                   	ret    
  80574c:	00 00                	add    %al,(%eax)
	...

00805750 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  805750:	55                   	push   %ebp
  805751:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  805753:	38 10                	cmp    %dl,(%eax)
  805755:	74 06                	je     80575d <dhcp_set_state+0xd>
    dhcp->state = new_state;
  805757:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  805759:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  80575d:	5d                   	pop    %ebp
  80575e:	c3                   	ret    

0080575f <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80575f:	55                   	push   %ebp
  805760:	89 e5                	mov    %esp,%ebp
  805762:	57                   	push   %edi
  805763:	56                   	push   %esi
  805764:	53                   	push   %ebx
  805765:	83 ec 08             	sub    $0x8,%esp
  805768:	88 55 f3             	mov    %dl,-0xd(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80576b:	8b 70 14             	mov    0x14(%eax),%esi
  80576e:	85 f6                	test   %esi,%esi
  805770:	0f 84 e6 00 00 00    	je     80585c <dhcp_get_option_ptr+0xfd>
  805776:	0f b7 78 18          	movzwl 0x18(%eax),%edi
  80577a:	66 85 ff             	test   %di,%di
  80577d:	0f 84 d9 00 00 00    	je     80585c <dhcp_get_option_ptr+0xfd>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  805783:	0f b6 0e             	movzbl (%esi),%ecx
  805786:	80 f9 ff             	cmp    $0xff,%cl
  805789:	0f 84 cd 00 00 00    	je     80585c <dhcp_get_option_ptr+0xfd>
  80578f:	89 f3                	mov    %esi,%ebx
  805791:	c6 45 f2 00          	movb   $0x0,-0xe(%ebp)
  805795:	ba 00 00 00 00       	mov    $0x0,%edx
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80579a:	80 f9 34             	cmp    $0x34,%cl
  80579d:	75 12                	jne    8057b1 <dhcp_get_option_ptr+0x52>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  80579f:	8d 4a 02             	lea    0x2(%edx),%ecx
        overload = options[offset++];
  8057a2:	0f b7 c9             	movzwl %cx,%ecx
  8057a5:	0f b6 0c 0e          	movzbl (%esi,%ecx,1),%ecx
  8057a9:	88 4d f2             	mov    %cl,-0xe(%ebp)
  8057ac:	83 c2 03             	add    $0x3,%edx
  8057af:	eb 17                	jmp    8057c8 <dhcp_get_option_ptr+0x69>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  8057b1:	3a 4d f3             	cmp    -0xd(%ebp),%cl
  8057b4:	0f 84 a7 00 00 00    	je     805861 <dhcp_get_option_ptr+0x102>
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  8057ba:	8d 4a 01             	lea    0x1(%edx),%ecx
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  8057bd:	0f b7 c9             	movzwl %cx,%ecx
  8057c0:	0f b6 0c 0e          	movzbl (%esi,%ecx,1),%ecx
  8057c4:	8d 54 0a 02          	lea    0x2(%edx,%ecx,1),%edx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8057c8:	66 39 d7             	cmp    %dx,%di
  8057cb:	76 0e                	jbe    8057db <dhcp_get_option_ptr+0x7c>
  8057cd:	0f b7 da             	movzwl %dx,%ebx
  8057d0:	8d 1c 1e             	lea    (%esi,%ebx,1),%ebx
  8057d3:	0f b6 0b             	movzbl (%ebx),%ecx
  8057d6:	80 f9 ff             	cmp    $0xff,%cl
  8057d9:	75 bf                	jne    80579a <dhcp_get_option_ptr+0x3b>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  8057db:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
  8057df:	74 7b                	je     80585c <dhcp_get_option_ptr+0xfd>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  8057e1:	80 7d f2 01          	cmpb   $0x1,-0xe(%ebp)
  8057e5:	75 0d                	jne    8057f4 <dhcp_get_option_ptr+0x95>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  8057e7:	8b 58 10             	mov    0x10(%eax),%ebx
  8057ea:	83 c3 6c             	add    $0x6c,%ebx
  8057ed:	b9 80 00 00 00       	mov    $0x80,%ecx
  8057f2:	eb 1e                	jmp    805812 <dhcp_get_option_ptr+0xb3>
        field_len = DHCP_FILE_LEN;
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  8057f4:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
  8057f8:	75 0d                	jne    805807 <dhcp_get_option_ptr+0xa8>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  8057fa:	8b 58 10             	mov    0x10(%eax),%ebx
  8057fd:	83 c3 2c             	add    $0x2c,%ebx
  805800:	b9 40 00 00 00       	mov    $0x40,%ecx
  805805:	eb 0b                	jmp    805812 <dhcp_get_option_ptr+0xb3>
        field_len = DHCP_SNAME_LEN;
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  805807:	8b 58 10             	mov    0x10(%eax),%ebx
  80580a:	83 c3 2c             	add    $0x2c,%ebx
  80580d:	b9 c0 00 00 00       	mov    $0xc0,%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  805812:	0f b6 13             	movzbl (%ebx),%edx
  805815:	80 fa ff             	cmp    $0xff,%dl
  805818:	74 42                	je     80585c <dhcp_get_option_ptr+0xfd>
        if (options[offset] == option_type) {
  80581a:	b8 00 00 00 00       	mov    $0x0,%eax
  80581f:	38 55 f3             	cmp    %dl,-0xd(%ebp)
  805822:	75 0e                	jne    805832 <dhcp_get_option_ptr+0xd3>
  805824:	eb 3b                	jmp    805861 <dhcp_get_option_ptr+0x102>
  805826:	89 f9                	mov    %edi,%ecx
  805828:	38 d1                	cmp    %dl,%cl
  80582a:	75 0e                	jne    80583a <dhcp_get_option_ptr+0xdb>
  80582c:	89 f3                	mov    %esi,%ebx
  80582e:	66 90                	xchg   %ax,%ax
  805830:	eb 2f                	jmp    805861 <dhcp_get_option_ptr+0x102>
  805832:	66 89 4d ee          	mov    %cx,-0x12(%ebp)
  805836:	0f b6 7d f3          	movzbl -0xd(%ebp),%edi
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  80583a:	8d 50 01             	lea    0x1(%eax),%edx
          offset += 1 + options[offset];
  80583d:	0f b7 d2             	movzwl %dx,%edx
  805840:	0f b6 14 13          	movzbl (%ebx,%edx,1),%edx
  805844:	8d 44 02 02          	lea    0x2(%edx,%eax,1),%eax
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  805848:	66 39 45 ee          	cmp    %ax,-0x12(%ebp)
  80584c:	76 0e                	jbe    80585c <dhcp_get_option_ptr+0xfd>
  80584e:	0f b7 f0             	movzwl %ax,%esi
  805851:	8d 34 33             	lea    (%ebx,%esi,1),%esi
  805854:	0f b6 16             	movzbl (%esi),%edx
  805857:	80 fa ff             	cmp    $0xff,%dl
  80585a:	75 ca                	jne    805826 <dhcp_get_option_ptr+0xc7>
  80585c:	bb 00 00 00 00       	mov    $0x0,%ebx
        }
      }
    }
  }
  return NULL;
}
  805861:	89 d8                	mov    %ebx,%eax
  805863:	83 c4 08             	add    $0x8,%esp
  805866:	5b                   	pop    %ebx
  805867:	5e                   	pop    %esi
  805868:	5f                   	pop    %edi
  805869:	5d                   	pop    %ebp
  80586a:	c3                   	ret    

0080586b <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  80586b:	55                   	push   %ebp
  80586c:	89 e5                	mov    %esp,%ebp
  80586e:	0f b6 00             	movzbl (%eax),%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
}
  805871:	5d                   	pop    %ebp
  805872:	c3                   	ret    

00805873 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  805873:	55                   	push   %ebp
  805874:	89 e5                	mov    %esp,%ebp
  805876:	53                   	push   %ebx
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  805877:	0f b6 10             	movzbl (%eax),%edx
  80587a:	c1 e2 18             	shl    $0x18,%edx
  value |= (u32_t)(*ptr++) << 16;
  80587d:	0f b6 58 01          	movzbl 0x1(%eax),%ebx
  805881:	c1 e3 10             	shl    $0x10,%ebx
  805884:	09 d3                	or     %edx,%ebx
  805886:	8d 50 02             	lea    0x2(%eax),%edx
  value |= (u32_t)(*ptr++) << 8;
  805889:	0f b6 0a             	movzbl (%edx),%ecx
  80588c:	c1 e1 08             	shl    $0x8,%ecx
  80588f:	89 d8                	mov    %ebx,%eax
  805891:	09 c8                	or     %ecx,%eax
  805893:	0f b6 52 01          	movzbl 0x1(%edx),%edx
  805897:	09 d0                	or     %edx,%eax
  value |= (u32_t)(*ptr++);
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  805899:	5b                   	pop    %ebx
  80589a:	5d                   	pop    %ebp
  80589b:	c3                   	ret    

0080589c <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  80589c:	55                   	push   %ebp
  80589d:	89 e5                	mov    %esp,%ebp
  80589f:	83 ec 28             	sub    $0x28,%esp
  8058a2:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8058a5:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8058a8:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  8058ab:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  8058af:	0f b7 fb             	movzwl %bx,%edi
  8058b2:	0f b6 f1             	movzbl %cl,%esi
  8058b5:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  8058b9:	83 fe 44             	cmp    $0x44,%esi
  8058bc:	76 1c                	jbe    8058da <dhcp_option+0x3e>
  8058be:	c7 44 24 08 fc 2e 81 	movl   $0x812efc,0x8(%esp)
  8058c5:	00 
  8058c6:	c7 44 24 04 5a 04 00 	movl   $0x45a,0x4(%esp)
  8058cd:	00 
  8058ce:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  8058d5:	e8 0e b1 ff ff       	call   8009e8 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  8058da:	8b 78 20             	mov    0x20(%eax),%edi
  8058dd:	0f b7 f3             	movzwl %bx,%esi
  8058e0:	88 94 37 f0 00 00 00 	mov    %dl,0xf0(%edi,%esi,1)
  8058e7:	8d 53 01             	lea    0x1(%ebx),%edx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  8058ea:	8b 70 20             	mov    0x20(%eax),%esi
  8058ed:	0f b7 d2             	movzwl %dx,%edx
  8058f0:	88 8c 16 f0 00 00 00 	mov    %cl,0xf0(%esi,%edx,1)
  8058f7:	83 c3 02             	add    $0x2,%ebx
  8058fa:	66 89 58 24          	mov    %bx,0x24(%eax)
}
  8058fe:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805901:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805904:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805907:	89 ec                	mov    %ebp,%esp
  805909:	5d                   	pop    %ebp
  80590a:	c3                   	ret    

0080590b <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  80590b:	55                   	push   %ebp
  80590c:	89 e5                	mov    %esp,%ebp
  80590e:	83 ec 18             	sub    $0x18,%esp
  805911:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  805914:	89 75 fc             	mov    %esi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  805917:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  80591b:	66 83 f9 43          	cmp    $0x43,%cx
  80591f:	76 1c                	jbe    80593d <dhcp_option_byte+0x32>
  805921:	c7 44 24 08 44 2f 81 	movl   $0x812f44,0x8(%esp)
  805928:	00 
  805929:	c7 44 24 04 65 04 00 	movl   $0x465,0x4(%esp)
  805930:	00 
  805931:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  805938:	e8 ab b0 ff ff       	call   8009e8 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80593d:	8b 70 20             	mov    0x20(%eax),%esi
  805940:	0f b7 d9             	movzwl %cx,%ebx
  805943:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  80594a:	83 c1 01             	add    $0x1,%ecx
  80594d:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  805951:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  805954:	8b 75 fc             	mov    -0x4(%ebp),%esi
  805957:	89 ec                	mov    %ebp,%esp
  805959:	5d                   	pop    %ebp
  80595a:	c3                   	ret    

0080595b <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  80595b:	55                   	push   %ebp
  80595c:	89 e5                	mov    %esp,%ebp
  80595e:	53                   	push   %ebx
  80595f:	83 ec 14             	sub    $0x14,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  805962:	85 c0                	test   %eax,%eax
  805964:	75 1c                	jne    805982 <dhcp_option_trailer+0x27>
  805966:	c7 44 24 08 80 2f 81 	movl   $0x812f80,0x8(%esp)
  80596d:	00 
  80596e:	c7 44 24 04 80 05 00 	movl   $0x580,0x4(%esp)
  805975:	00 
  805976:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  80597d:	e8 66 b0 ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  805982:	8b 48 20             	mov    0x20(%eax),%ecx
  805985:	85 c9                	test   %ecx,%ecx
  805987:	75 1c                	jne    8059a5 <dhcp_option_trailer+0x4a>
  805989:	c7 44 24 08 a4 2f 81 	movl   $0x812fa4,0x8(%esp)
  805990:	00 
  805991:	c7 44 24 04 81 05 00 	movl   $0x581,0x4(%esp)
  805998:	00 
  805999:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  8059a0:	e8 43 b0 ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8059a5:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8059a9:	66 83 fa 43          	cmp    $0x43,%dx
  8059ad:	76 1c                	jbe    8059cb <dhcp_option_trailer+0x70>
  8059af:	c7 44 24 08 d0 2f 81 	movl   $0x812fd0,0x8(%esp)
  8059b6:	00 
  8059b7:	c7 44 24 04 82 05 00 	movl   $0x582,0x4(%esp)
  8059be:	00 
  8059bf:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  8059c6:	e8 1d b0 ff ff       	call   8009e8 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  8059cb:	0f b7 da             	movzwl %dx,%ebx
  8059ce:	c6 84 19 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%ebx,1)
  8059d5:	ff 
  8059d6:	83 c2 01             	add    $0x1,%edx
  8059d9:	66 89 50 24          	mov    %dx,0x24(%eax)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  8059dd:	eb 31                	jmp    805a10 <dhcp_option_trailer+0xb5>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8059df:	c7 44 24 08 d0 2f 81 	movl   $0x812fd0,0x8(%esp)
  8059e6:	00 
  8059e7:	c7 44 24 04 87 05 00 	movl   $0x587,0x4(%esp)
  8059ee:	00 
  8059ef:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  8059f6:	e8 ed af ff ff       	call   8009e8 <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  8059fb:	8b 58 20             	mov    0x20(%eax),%ebx
  8059fe:	0f b7 ca             	movzwl %dx,%ecx
  805a01:	c6 84 0b f0 00 00 00 	movb   $0x0,0xf0(%ebx,%ecx,1)
  805a08:	00 
  805a09:	83 c2 01             	add    $0x1,%edx
  805a0c:	66 89 50 24          	mov    %dx,0x24(%eax)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  805a10:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  805a14:	66 83 fa 43          	cmp    $0x43,%dx
  805a18:	76 e1                	jbe    8059fb <dhcp_option_trailer+0xa0>
  805a1a:	f6 c2 03             	test   $0x3,%dl
  805a1d:	75 c0                	jne    8059df <dhcp_option_trailer+0x84>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  805a1f:	83 c4 14             	add    $0x14,%esp
  805a22:	5b                   	pop    %ebx
  805a23:	5d                   	pop    %ebp
  805a24:	c3                   	ret    

00805a25 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  805a25:	55                   	push   %ebp
  805a26:	89 e5                	mov    %esp,%ebp
  805a28:	83 ec 48             	sub    $0x48,%esp
  805a2b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805a2e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805a31:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  805a34:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  805a38:	0f b7 d9             	movzwl %cx,%ebx
  805a3b:	83 c3 02             	add    $0x2,%ebx
  805a3e:	83 fb 44             	cmp    $0x44,%ebx
  805a41:	76 1c                	jbe    805a5f <dhcp_option_short+0x3a>
  805a43:	c7 44 24 08 10 30 81 	movl   $0x813010,0x8(%esp)
  805a4a:	00 
  805a4b:	c7 44 24 04 6c 04 00 	movl   $0x46c,0x4(%esp)
  805a52:	00 
  805a53:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  805a5a:	e8 89 af ff ff       	call   8009e8 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  805a5f:	0f b7 d9             	movzwl %cx,%ebx
  805a62:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805a65:	89 d6                	mov    %edx,%esi
  805a67:	66 c1 ee 08          	shr    $0x8,%si
  805a6b:	66 89 75 d6          	mov    %si,-0x2a(%ebp)
  805a6f:	0f b6 5d d6          	movzbl -0x2a(%ebp),%ebx
  805a73:	8b 78 20             	mov    0x20(%eax),%edi
  805a76:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805a79:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805a80:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  805a83:	8b 70 20             	mov    0x20(%eax),%esi
  805a86:	0f b7 db             	movzwl %bx,%ebx
  805a89:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  805a90:	83 c1 02             	add    $0x2,%ecx
  805a93:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  805a97:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805a9a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805a9d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805aa0:	89 ec                	mov    %ebp,%esp
  805aa2:	5d                   	pop    %ebp
  805aa3:	c3                   	ret    

00805aa4 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  805aa4:	55                   	push   %ebp
  805aa5:	89 e5                	mov    %esp,%ebp
  805aa7:	83 ec 48             	sub    $0x48,%esp
  805aaa:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805aad:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805ab0:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  805ab3:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  805ab7:	0f b7 d9             	movzwl %cx,%ebx
  805aba:	83 c3 04             	add    $0x4,%ebx
  805abd:	83 fb 44             	cmp    $0x44,%ebx
  805ac0:	76 1c                	jbe    805ade <dhcp_option_long+0x3a>
  805ac2:	c7 44 24 08 54 30 81 	movl   $0x813054,0x8(%esp)
  805ac9:	00 
  805aca:	c7 44 24 04 74 04 00 	movl   $0x474,0x4(%esp)
  805ad1:	00 
  805ad2:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  805ad9:	e8 0a af ff ff       	call   8009e8 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  805ade:	0f b7 d9             	movzwl %cx,%ebx
  805ae1:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805ae4:	89 d6                	mov    %edx,%esi
  805ae6:	c1 ee 18             	shr    $0x18,%esi
  805ae9:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  805aec:	0f b6 5d d4          	movzbl -0x2c(%ebp),%ebx
  805af0:	8b 78 20             	mov    0x20(%eax),%edi
  805af3:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805af6:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805afd:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  805b00:	0f b7 db             	movzwl %bx,%ebx
  805b03:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805b06:	89 d3                	mov    %edx,%ebx
  805b08:	c1 eb 10             	shr    $0x10,%ebx
  805b0b:	8b 78 20             	mov    0x20(%eax),%edi
  805b0e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805b11:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805b18:	8d 59 02             	lea    0x2(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  805b1b:	0f b7 db             	movzwl %bx,%ebx
  805b1e:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805b21:	0f b6 de             	movzbl %dh,%ebx
  805b24:	8b 78 20             	mov    0x20(%eax),%edi
  805b27:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805b2a:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805b31:	8d 59 03             	lea    0x3(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  805b34:	8b 70 20             	mov    0x20(%eax),%esi
  805b37:	0f b7 db             	movzwl %bx,%ebx
  805b3a:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  805b41:	83 c1 04             	add    $0x4,%ecx
  805b44:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  805b48:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805b4b:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805b4e:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805b51:	89 ec                	mov    %ebp,%esp
  805b53:	5d                   	pop    %ebp
  805b54:	c3                   	ret    

00805b55 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  805b55:	55                   	push   %ebp
  805b56:	89 e5                	mov    %esp,%ebp
  805b58:	53                   	push   %ebx
  805b59:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  805b5c:	85 c0                	test   %eax,%eax
  805b5e:	75 1c                	jne    805b7c <dhcp_delete_request+0x27>
  805b60:	c7 44 24 08 94 30 81 	movl   $0x813094,0x8(%esp)
  805b67:	00 
  805b68:	c7 44 24 04 69 05 00 	movl   $0x569,0x4(%esp)
  805b6f:	00 
  805b70:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  805b77:	e8 6c ae ff ff       	call   8009e8 <_panic>
  dhcp = netif->dhcp;
  805b7c:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  805b7f:	85 db                	test   %ebx,%ebx
  805b81:	75 1c                	jne    805b9f <dhcp_delete_request+0x4a>
  805b83:	c7 44 24 08 b8 30 81 	movl   $0x8130b8,0x8(%esp)
  805b8a:	00 
  805b8b:	c7 44 24 04 6b 05 00 	movl   $0x56b,0x4(%esp)
  805b92:	00 
  805b93:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  805b9a:	e8 49 ae ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  805b9f:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805ba2:	85 c0                	test   %eax,%eax
  805ba4:	75 1c                	jne    805bc2 <dhcp_delete_request+0x6d>
  805ba6:	c7 44 24 08 dc 30 81 	movl   $0x8130dc,0x8(%esp)
  805bad:	00 
  805bae:	c7 44 24 04 6c 05 00 	movl   $0x56c,0x4(%esp)
  805bb5:	00 
  805bb6:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  805bbd:	e8 26 ae ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  805bc2:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  805bc6:	75 1c                	jne    805be4 <dhcp_delete_request+0x8f>
  805bc8:	c7 44 24 08 08 31 81 	movl   $0x813108,0x8(%esp)
  805bcf:	00 
  805bd0:	c7 44 24 04 6d 05 00 	movl   $0x56d,0x4(%esp)
  805bd7:	00 
  805bd8:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  805bdf:	e8 04 ae ff ff       	call   8009e8 <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  805be4:	89 04 24             	mov    %eax,(%esp)
  805be7:	e8 8c 22 00 00       	call   807e78 <pbuf_free>
  }
  dhcp->p_out = NULL;
  805bec:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  805bf3:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  805bfa:	83 c4 14             	add    $0x14,%esp
  805bfd:	5b                   	pop    %ebx
  805bfe:	5d                   	pop    %ebp
  805bff:	c3                   	ret    

00805c00 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  805c00:	55                   	push   %ebp
  805c01:	89 e5                	mov    %esp,%ebp
  805c03:	53                   	push   %ebx
  805c04:	83 ec 14             	sub    $0x14,%esp
  805c07:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  805c09:	8b 40 10             	mov    0x10(%eax),%eax
  805c0c:	85 c0                	test   %eax,%eax
  805c0e:	74 0f                	je     805c1f <dhcp_free_reply+0x1f>
    mem_free((void *)dhcp->msg_in);
  805c10:	89 04 24             	mov    %eax,(%esp)
  805c13:	e8 56 18 00 00       	call   80746e <mem_free>
    dhcp->msg_in = NULL;
  805c18:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  }
  if (dhcp->options_in) {
  805c1f:	8b 43 14             	mov    0x14(%ebx),%eax
  805c22:	85 c0                	test   %eax,%eax
  805c24:	74 15                	je     805c3b <dhcp_free_reply+0x3b>
    mem_free((void *)dhcp->options_in);
  805c26:	89 04 24             	mov    %eax,(%esp)
  805c29:	e8 40 18 00 00       	call   80746e <mem_free>
    dhcp->options_in = NULL;
  805c2e:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  805c35:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  805c3b:	83 c4 14             	add    $0x14,%esp
  805c3e:	5b                   	pop    %ebx
  805c3f:	5d                   	pop    %ebp
  805c40:	c3                   	ret    

00805c41 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  805c41:	55                   	push   %ebp
  805c42:	89 e5                	mov    %esp,%ebp
  805c44:	56                   	push   %esi
  805c45:	53                   	push   %ebx
  805c46:	83 ec 10             	sub    $0x10,%esp
  805c49:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  805c4c:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  805c4f:	85 f6                	test   %esi,%esi
  805c51:	75 1c                	jne    805c6f <dhcp_stop+0x2e>
  805c53:	c7 44 24 08 5f 32 81 	movl   $0x81325f,0x8(%esp)
  805c5a:	00 
  805c5b:	c7 44 24 04 2c 04 00 	movl   $0x42c,0x4(%esp)
  805c62:	00 
  805c63:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  805c6a:	e8 79 ad ff ff       	call   8009e8 <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  805c6f:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  805c73:	85 db                	test   %ebx,%ebx
  805c75:	74 42                	je     805cb9 <dhcp_stop+0x78>
    if (dhcp->pcb != NULL) {
  805c77:	8b 43 08             	mov    0x8(%ebx),%eax
  805c7a:	85 c0                	test   %eax,%eax
  805c7c:	74 0f                	je     805c8d <dhcp_stop+0x4c>
      udp_remove(dhcp->pcb);
  805c7e:	89 04 24             	mov    %eax,(%esp)
  805c81:	e8 e6 63 00 00       	call   80c06c <udp_remove>
      dhcp->pcb = NULL;
  805c86:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    }
    if (dhcp->p != NULL) {
  805c8d:	8b 43 0c             	mov    0xc(%ebx),%eax
  805c90:	85 c0                	test   %eax,%eax
  805c92:	74 0f                	je     805ca3 <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  805c94:	89 04 24             	mov    %eax,(%esp)
  805c97:	e8 dc 21 00 00       	call   807e78 <pbuf_free>
      dhcp->p = NULL;
  805c9c:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  805ca3:	89 d8                	mov    %ebx,%eax
  805ca5:	e8 56 ff ff ff       	call   805c00 <dhcp_free_reply>
    mem_free((void *)dhcp);
  805caa:	89 1c 24             	mov    %ebx,(%esp)
  805cad:	e8 bc 17 00 00       	call   80746e <mem_free>
    netif->dhcp = NULL;
  805cb2:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  }
}
  805cb9:	83 c4 10             	add    $0x10,%esp
  805cbc:	5b                   	pop    %ebx
  805cbd:	5e                   	pop    %esi
  805cbe:	5d                   	pop    %ebp
  805cbf:	c3                   	ret    

00805cc0 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  805cc0:	55                   	push   %ebp
  805cc1:	89 e5                	mov    %esp,%ebp
  805cc3:	57                   	push   %edi
  805cc4:	56                   	push   %esi
  805cc5:	53                   	push   %ebx
  805cc6:	83 ec 2c             	sub    $0x2c,%esp
  805cc9:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  805ccb:	85 c0                	test   %eax,%eax
  805ccd:	75 1c                	jne    805ceb <dhcp_create_request+0x2b>
  805ccf:	c7 44 24 08 34 31 81 	movl   $0x813134,0x8(%esp)
  805cd6:	00 
  805cd7:	c7 44 24 04 2d 05 00 	movl   $0x52d,0x4(%esp)
  805cde:	00 
  805cdf:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  805ce6:	e8 fd ac ff ff       	call   8009e8 <_panic>
  dhcp = netif->dhcp;
  805ceb:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  805cee:	85 db                	test   %ebx,%ebx
  805cf0:	75 1c                	jne    805d0e <dhcp_create_request+0x4e>
  805cf2:	c7 44 24 08 58 31 81 	movl   $0x813158,0x8(%esp)
  805cf9:	00 
  805cfa:	c7 44 24 04 2f 05 00 	movl   $0x52f,0x4(%esp)
  805d01:	00 
  805d02:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  805d09:	e8 da ac ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  805d0e:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  805d12:	74 1c                	je     805d30 <dhcp_create_request+0x70>
  805d14:	c7 44 24 08 7c 31 81 	movl   $0x81317c,0x8(%esp)
  805d1b:	00 
  805d1c:	c7 44 24 04 30 05 00 	movl   $0x530,0x4(%esp)
  805d23:	00 
  805d24:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  805d2b:	e8 b8 ac ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  805d30:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  805d34:	74 1c                	je     805d52 <dhcp_create_request+0x92>
  805d36:	c7 44 24 08 a8 31 81 	movl   $0x8131a8,0x8(%esp)
  805d3d:	00 
  805d3e:	c7 44 24 04 31 05 00 	movl   $0x531,0x4(%esp)
  805d45:	00 
  805d46:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  805d4d:	e8 96 ac ff ff       	call   8009e8 <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  805d52:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805d59:	00 
  805d5a:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
  805d61:	00 
  805d62:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805d69:	e8 c5 23 00 00       	call   808133 <pbuf_alloc>
  805d6e:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  805d71:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  805d76:	85 c0                	test   %eax,%eax
  805d78:	0f 84 2d 01 00 00    	je     805eab <dhcp_create_request+0x1eb>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  805d7e:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  805d84:	77 1c                	ja     805da2 <dhcp_create_request+0xe2>
  805d86:	c7 44 24 08 d4 31 81 	movl   $0x8131d4,0x8(%esp)
  805d8d:	00 
  805d8e:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  805d95:	00 
  805d96:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  805d9d:	e8 46 ac ff ff       	call   8009e8 <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  805da2:	8b 15 40 50 81 00    	mov    0x815040,%edx
  805da8:	89 53 04             	mov    %edx,0x4(%ebx)
  805dab:	83 c2 01             	add    $0x1,%edx
  805dae:	89 15 40 50 81 00    	mov    %edx,0x815040
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  805db4:	8b 40 04             	mov    0x4(%eax),%eax
  805db7:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  805dba:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  805dbd:	8b 43 20             	mov    0x20(%ebx),%eax
  805dc0:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  805dc4:	8b 43 20             	mov    0x20(%ebx),%eax
  805dc7:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  805dcb:	8b 43 20             	mov    0x20(%ebx),%eax
  805dce:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  805dd2:	8b 73 20             	mov    0x20(%ebx),%esi
  805dd5:	8b 43 04             	mov    0x4(%ebx),%eax
  805dd8:	89 04 24             	mov    %eax,(%esp)
  805ddb:	e8 b5 4e 00 00       	call   80ac95 <htonl>
  805de0:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  805de3:	8b 43 20             	mov    0x20(%ebx),%eax
  805de6:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  805dec:	8b 43 20             	mov    0x20(%ebx),%eax
  805def:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  805df5:	8b 43 20             	mov    0x20(%ebx),%eax
  805df8:	8b 57 04             	mov    0x4(%edi),%edx
  805dfb:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  805dfe:	8b 43 20             	mov    0x20(%ebx),%eax
  805e01:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  805e08:	8b 43 20             	mov    0x20(%ebx),%eax
  805e0b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  805e12:	8b 43 20             	mov    0x20(%ebx),%eax
  805e15:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  805e1c:	b8 00 00 00 00       	mov    $0x0,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  805e21:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805e24:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  805e27:	8b 5a 20             	mov    0x20(%edx),%ebx
  805e2a:	89 c1                	mov    %eax,%ecx
  805e2c:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  805e30:	ba 00 00 00 00       	mov    $0x0,%edx
  805e35:	66 39 c6             	cmp    %ax,%si
  805e38:	76 05                	jbe    805e3f <dhcp_create_request+0x17f>
  805e3a:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  805e3f:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  805e43:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  805e46:	83 f8 10             	cmp    $0x10,%eax
  805e49:	75 d9                	jne    805e24 <dhcp_create_request+0x164>
  805e4b:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  805e4e:	b0 00                	mov    $0x0,%al
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  805e50:	8b 53 20             	mov    0x20(%ebx),%edx
  805e53:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  805e58:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  805e5b:	83 f8 40             	cmp    $0x40,%eax
  805e5e:	75 f0                	jne    805e50 <dhcp_create_request+0x190>
  805e60:	b0 00                	mov    $0x0,%al
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  805e62:	8b 53 20             	mov    0x20(%ebx),%edx
  805e65:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  805e6a:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  805e6d:	3d 80 00 00 00       	cmp    $0x80,%eax
  805e72:	75 ee                	jne    805e62 <dhcp_create_request+0x1a2>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  805e74:	8b 73 20             	mov    0x20(%ebx),%esi
  805e77:	c7 04 24 63 53 82 63 	movl   $0x63825363,(%esp)
  805e7e:	e8 12 4e 00 00       	call   80ac95 <htonl>
  805e83:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  805e89:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  805e8f:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  805e94:	8b 53 20             	mov    0x20(%ebx),%edx
  805e97:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  805e9e:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  805ea1:	83 f8 44             	cmp    $0x44,%eax
  805ea4:	75 ee                	jne    805e94 <dhcp_create_request+0x1d4>
  805ea6:	ba 00 00 00 00       	mov    $0x0,%edx
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  805eab:	89 d0                	mov    %edx,%eax
  805ead:	83 c4 2c             	add    $0x2c,%esp
  805eb0:	5b                   	pop    %ebx
  805eb1:	5e                   	pop    %esi
  805eb2:	5f                   	pop    %edi
  805eb3:	5d                   	pop    %ebp
  805eb4:	c3                   	ret    

00805eb5 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  805eb5:	55                   	push   %ebp
  805eb6:	89 e5                	mov    %esp,%ebp
  805eb8:	57                   	push   %edi
  805eb9:	56                   	push   %esi
  805eba:	53                   	push   %ebx
  805ebb:	83 ec 3c             	sub    $0x3c,%esp
  805ebe:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  805ec1:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  805ec4:	ba 0d 00 00 00       	mov    $0xd,%edx
  805ec9:	89 d8                	mov    %ebx,%eax
  805ecb:	e8 80 f8 ff ff       	call   805750 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  805ed0:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  805ed7:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  805ede:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  805ee5:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  805eec:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  805ef3:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  805efa:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  805f01:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  805f08:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805f0f:	89 f0                	mov    %esi,%eax
  805f11:	e8 aa fd ff ff       	call   805cc0 <dhcp_create_request>
  805f16:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  805f18:	84 c0                	test   %al,%al
  805f1a:	0f 85 87 00 00 00    	jne    805fa7 <dhcp_release+0xf2>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805f20:	b9 01 00 00 00       	mov    $0x1,%ecx
  805f25:	ba 35 00 00 00       	mov    $0x35,%edx
  805f2a:	89 d8                	mov    %ebx,%eax
  805f2c:	e8 6b f9 ff ff       	call   80589c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  805f31:	ba 07 00 00 00       	mov    $0x7,%edx
  805f36:	89 d8                	mov    %ebx,%eax
  805f38:	e8 ce f9 ff ff       	call   80590b <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  805f3d:	89 d8                	mov    %ebx,%eax
  805f3f:	e8 17 fa ff ff       	call   80595b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805f44:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  805f48:	66 05 f0 00          	add    $0xf0,%ax
  805f4c:	0f b7 c0             	movzwl %ax,%eax
  805f4f:	89 44 24 04          	mov    %eax,0x4(%esp)
  805f53:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805f56:	89 04 24             	mov    %eax,(%esp)
  805f59:	e8 a2 20 00 00       	call   808000 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  805f5e:	8d 43 2c             	lea    0x2c(%ebx),%eax
  805f61:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  805f64:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  805f6b:	00 
  805f6c:	89 44 24 04          	mov    %eax,0x4(%esp)
  805f70:	8b 43 08             	mov    0x8(%ebx),%eax
  805f73:	89 04 24             	mov    %eax,(%esp)
  805f76:	e8 03 62 00 00       	call   80c17e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  805f7b:	89 74 24 10          	mov    %esi,0x10(%esp)
  805f7f:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  805f86:	00 
  805f87:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805f8a:	89 44 24 08          	mov    %eax,0x8(%esp)
  805f8e:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805f91:	89 44 24 04          	mov    %eax,0x4(%esp)
  805f95:	8b 43 08             	mov    0x8(%ebx),%eax
  805f98:	89 04 24             	mov    %eax,(%esp)
  805f9b:	e8 60 62 00 00       	call   80c200 <udp_sendto_if>
    dhcp_delete_request(netif);
  805fa0:	89 f0                	mov    %esi,%eax
  805fa2:	e8 ae fb ff ff       	call   805b55 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805fa7:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  805fab:	83 c1 01             	add    $0x1,%ecx
  805fae:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  805fb1:	ba 10 27 00 00       	mov    $0x2710,%edx
  805fb6:	80 f9 09             	cmp    $0x9,%cl
  805fb9:	77 08                	ja     805fc3 <dhcp_release+0x10e>
  805fbb:	0f b6 c9             	movzbl %cl,%ecx
  805fbe:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805fc3:	0f b7 d2             	movzwl %dx,%edx
  805fc6:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  805fcc:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  805fd1:	89 d0                	mov    %edx,%eax
  805fd3:	f7 e9                	imul   %ecx
  805fd5:	c1 fa 05             	sar    $0x5,%edx
  805fd8:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  805fdc:	89 34 24             	mov    %esi,(%esp)
  805fdf:	e8 84 18 00 00       	call   807868 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  805fe4:	c7 44 24 04 2c 3b 81 	movl   $0x813b2c,0x4(%esp)
  805feb:	00 
  805fec:	89 34 24             	mov    %esi,(%esp)
  805fef:	e8 d0 18 00 00       	call   8078c4 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  805ff4:	c7 44 24 04 2c 3b 81 	movl   $0x813b2c,0x4(%esp)
  805ffb:	00 
  805ffc:	89 34 24             	mov    %esi,(%esp)
  805fff:	e8 cb 17 00 00       	call   8077cf <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  806004:	c7 44 24 04 2c 3b 81 	movl   $0x813b2c,0x4(%esp)
  80600b:	00 
  80600c:	89 34 24             	mov    %esi,(%esp)
  80600f:	e8 d4 17 00 00       	call   8077e8 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  806014:	89 f8                	mov    %edi,%eax
  806016:	83 c4 3c             	add    $0x3c,%esp
  806019:	5b                   	pop    %ebx
  80601a:	5e                   	pop    %esi
  80601b:	5f                   	pop    %edi
  80601c:	5d                   	pop    %ebp
  80601d:	c3                   	ret    

0080601e <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  80601e:	55                   	push   %ebp
  80601f:	89 e5                	mov    %esp,%ebp
  806021:	83 ec 48             	sub    $0x48,%esp
  806024:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  806027:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80602a:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80602d:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  806030:	8b 5f 20             	mov    0x20(%edi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  806033:	ba 05 00 00 00       	mov    $0x5,%edx
  806038:	89 d8                	mov    %ebx,%eax
  80603a:	e8 11 f7 ff ff       	call   805750 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80603f:	89 f8                	mov    %edi,%eax
  806041:	e8 7a fc ff ff       	call   805cc0 <dhcp_create_request>
  806046:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  806048:	84 c0                	test   %al,%al
  80604a:	0f 85 a4 00 00 00    	jne    8060f4 <dhcp_renew+0xd6>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  806050:	b9 01 00 00 00       	mov    $0x1,%ecx
  806055:	ba 35 00 00 00       	mov    $0x35,%edx
  80605a:	89 d8                	mov    %ebx,%eax
  80605c:	e8 3b f8 ff ff       	call   80589c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  806061:	ba 03 00 00 00       	mov    $0x3,%edx
  806066:	89 d8                	mov    %ebx,%eax
  806068:	e8 9e f8 ff ff       	call   80590b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80606d:	b9 02 00 00 00       	mov    $0x2,%ecx
  806072:	ba 39 00 00 00       	mov    $0x39,%edx
  806077:	89 d8                	mov    %ebx,%eax
  806079:	e8 1e f8 ff ff       	call   80589c <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  80607e:	ba 40 02 00 00       	mov    $0x240,%edx
  806083:	89 d8                	mov    %ebx,%eax
  806085:	e8 9b f9 ff ff       	call   805a25 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  80608a:	89 d8                	mov    %ebx,%eax
  80608c:	e8 ca f8 ff ff       	call   80595b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806091:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  806095:	66 05 f0 00          	add    $0xf0,%ax
  806099:	0f b7 c0             	movzwl %ax,%eax
  80609c:	89 44 24 04          	mov    %eax,0x4(%esp)
  8060a0:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8060a3:	89 04 24             	mov    %eax,(%esp)
  8060a6:	e8 55 1f 00 00       	call   808000 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  8060ab:	8d 43 2c             	lea    0x2c(%ebx),%eax
  8060ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8060b1:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8060b8:	00 
  8060b9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8060bd:	8b 43 08             	mov    0x8(%ebx),%eax
  8060c0:	89 04 24             	mov    %eax,(%esp)
  8060c3:	e8 b6 60 00 00       	call   80c17e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  8060c8:	89 7c 24 10          	mov    %edi,0x10(%esp)
  8060cc:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8060d3:	00 
  8060d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8060d7:	89 44 24 08          	mov    %eax,0x8(%esp)
  8060db:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8060de:	89 44 24 04          	mov    %eax,0x4(%esp)
  8060e2:	8b 43 08             	mov    0x8(%ebx),%eax
  8060e5:	89 04 24             	mov    %eax,(%esp)
  8060e8:	e8 13 61 00 00       	call   80c200 <udp_sendto_if>
    dhcp_delete_request(netif);
  8060ed:	89 f8                	mov    %edi,%eax
  8060ef:	e8 61 fa ff ff       	call   805b55 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8060f4:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  8060f8:	83 c1 01             	add    $0x1,%ecx
  8060fb:	88 4b 01             	mov    %cl,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  8060fe:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  806103:	80 f9 09             	cmp    $0x9,%cl
  806106:	77 08                	ja     806110 <dhcp_renew+0xf2>
  806108:	0f b6 c9             	movzbl %cl,%ecx
  80610b:	66 69 d1 d0 07       	imul   $0x7d0,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  806110:	0f b7 d2             	movzwl %dx,%edx
  806113:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  806119:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  80611e:	89 d0                	mov    %edx,%eax
  806120:	f7 e9                	imul   %ecx
  806122:	c1 fa 05             	sar    $0x5,%edx
  806125:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  806129:	89 f0                	mov    %esi,%eax
  80612b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80612e:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806131:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806134:	89 ec                	mov    %ebp,%esp
  806136:	5d                   	pop    %ebp
  806137:	c3                   	ret    

00806138 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  806138:	55                   	push   %ebp
  806139:	89 e5                	mov    %esp,%ebp
  80613b:	57                   	push   %edi
  80613c:	56                   	push   %esi
  80613d:	53                   	push   %ebx
  80613e:	83 ec 2c             	sub    $0x2c,%esp
  806141:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  806143:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  806146:	a1 2c 3b 81 00       	mov    0x813b2c,%eax
  80614b:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80614e:	89 f8                	mov    %edi,%eax
  806150:	e8 6b fb ff ff       	call   805cc0 <dhcp_create_request>
  806155:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  806157:	84 c0                	test   %al,%al
  806159:	0f 85 f0 00 00 00    	jne    80624f <dhcp_discover+0x117>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80615f:	b9 01 00 00 00       	mov    $0x1,%ecx
  806164:	ba 35 00 00 00       	mov    $0x35,%edx
  806169:	89 d8                	mov    %ebx,%eax
  80616b:	e8 2c f7 ff ff       	call   80589c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  806170:	ba 01 00 00 00       	mov    $0x1,%edx
  806175:	89 d8                	mov    %ebx,%eax
  806177:	e8 8f f7 ff ff       	call   80590b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80617c:	b9 02 00 00 00       	mov    $0x2,%ecx
  806181:	ba 39 00 00 00       	mov    $0x39,%edx
  806186:	89 d8                	mov    %ebx,%eax
  806188:	e8 0f f7 ff ff       	call   80589c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80618d:	ba 40 02 00 00       	mov    $0x240,%edx
  806192:	89 d8                	mov    %ebx,%eax
  806194:	e8 8c f8 ff ff       	call   805a25 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  806199:	b9 04 00 00 00       	mov    $0x4,%ecx
  80619e:	ba 37 00 00 00       	mov    $0x37,%edx
  8061a3:	89 d8                	mov    %ebx,%eax
  8061a5:	e8 f2 f6 ff ff       	call   80589c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  8061aa:	ba 01 00 00 00       	mov    $0x1,%edx
  8061af:	89 d8                	mov    %ebx,%eax
  8061b1:	e8 55 f7 ff ff       	call   80590b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  8061b6:	ba 03 00 00 00       	mov    $0x3,%edx
  8061bb:	89 d8                	mov    %ebx,%eax
  8061bd:	e8 49 f7 ff ff       	call   80590b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  8061c2:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8061c7:	89 d8                	mov    %ebx,%eax
  8061c9:	e8 3d f7 ff ff       	call   80590b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8061ce:	ba 06 00 00 00       	mov    $0x6,%edx
  8061d3:	89 d8                	mov    %ebx,%eax
  8061d5:	e8 31 f7 ff ff       	call   80590b <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  8061da:	89 d8                	mov    %ebx,%eax
  8061dc:	e8 7a f7 ff ff       	call   80595b <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8061e1:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8061e5:	66 05 f0 00          	add    $0xf0,%ax
  8061e9:	0f b7 c0             	movzwl %ax,%eax
  8061ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  8061f0:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8061f3:	89 04 24             	mov    %eax,(%esp)
  8061f6:	e8 05 1e 00 00       	call   808000 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8061fb:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806202:	00 
  806203:	c7 44 24 04 2c 3b 81 	movl   $0x813b2c,0x4(%esp)
  80620a:	00 
  80620b:	8b 43 08             	mov    0x8(%ebx),%eax
  80620e:	89 04 24             	mov    %eax,(%esp)
  806211:	e8 68 5f 00 00       	call   80c17e <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806216:	89 7c 24 10          	mov    %edi,0x10(%esp)
  80621a:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806221:	00 
  806222:	c7 44 24 08 30 3b 81 	movl   $0x813b30,0x8(%esp)
  806229:	00 
  80622a:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80622d:	89 44 24 04          	mov    %eax,0x4(%esp)
  806231:	8b 43 08             	mov    0x8(%ebx),%eax
  806234:	89 04 24             	mov    %eax,(%esp)
  806237:	e8 c4 5f 00 00       	call   80c200 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  80623c:	89 f8                	mov    %edi,%eax
  80623e:	e8 12 f9 ff ff       	call   805b55 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  806243:	ba 06 00 00 00       	mov    $0x6,%edx
  806248:	89 d8                	mov    %ebx,%eax
  80624a:	e8 01 f5 ff ff       	call   805750 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80624f:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  806253:	83 c1 01             	add    $0x1,%ecx
  806256:	88 4b 01             	mov    %cl,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  806259:	ba 10 27 00 00       	mov    $0x2710,%edx
  80625e:	80 f9 03             	cmp    $0x3,%cl
  806261:	77 0b                	ja     80626e <dhcp_discover+0x136>
  806263:	0f b6 d1             	movzbl %cl,%edx
  806266:	83 c2 01             	add    $0x1,%edx
  806269:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80626e:	0f b7 d2             	movzwl %dx,%edx
  806271:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  806277:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  80627c:	89 d0                	mov    %edx,%eax
  80627e:	f7 e9                	imul   %ecx
  806280:	c1 fa 05             	sar    $0x5,%edx
  806283:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  806287:	89 f0                	mov    %esi,%eax
  806289:	83 c4 2c             	add    $0x2c,%esp
  80628c:	5b                   	pop    %ebx
  80628d:	5e                   	pop    %esi
  80628e:	5f                   	pop    %edi
  80628f:	5d                   	pop    %ebp
  806290:	c3                   	ret    

00806291 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  806291:	55                   	push   %ebp
  806292:	89 e5                	mov    %esp,%ebp
  806294:	83 ec 38             	sub    $0x38,%esp
  806297:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80629a:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80629d:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8062a0:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  8062a2:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  8062a5:	ba 04 00 00 00       	mov    $0x4,%edx
  8062aa:	89 d8                	mov    %ebx,%eax
  8062ac:	e8 9f f4 ff ff       	call   805750 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8062b1:	89 f8                	mov    %edi,%eax
  8062b3:	e8 08 fa ff ff       	call   805cc0 <dhcp_create_request>
  8062b8:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  8062ba:	84 c0                	test   %al,%al
  8062bc:	0f 85 a3 00 00 00    	jne    806365 <dhcp_rebind+0xd4>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8062c2:	b9 01 00 00 00       	mov    $0x1,%ecx
  8062c7:	ba 35 00 00 00       	mov    $0x35,%edx
  8062cc:	89 d8                	mov    %ebx,%eax
  8062ce:	e8 c9 f5 ff ff       	call   80589c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8062d3:	ba 03 00 00 00       	mov    $0x3,%edx
  8062d8:	89 d8                	mov    %ebx,%eax
  8062da:	e8 2c f6 ff ff       	call   80590b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8062df:	b9 02 00 00 00       	mov    $0x2,%ecx
  8062e4:	ba 39 00 00 00       	mov    $0x39,%edx
  8062e9:	89 d8                	mov    %ebx,%eax
  8062eb:	e8 ac f5 ff ff       	call   80589c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8062f0:	ba 40 02 00 00       	mov    $0x240,%edx
  8062f5:	89 d8                	mov    %ebx,%eax
  8062f7:	e8 29 f7 ff ff       	call   805a25 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  8062fc:	89 d8                	mov    %ebx,%eax
  8062fe:	e8 58 f6 ff ff       	call   80595b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806303:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  806307:	66 05 f0 00          	add    $0xf0,%ax
  80630b:	0f b7 c0             	movzwl %ax,%eax
  80630e:	89 44 24 04          	mov    %eax,0x4(%esp)
  806312:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806315:	89 04 24             	mov    %eax,(%esp)
  806318:	e8 e3 1c 00 00       	call   808000 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80631d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806324:	00 
  806325:	c7 44 24 04 2c 3b 81 	movl   $0x813b2c,0x4(%esp)
  80632c:	00 
  80632d:	8b 43 08             	mov    0x8(%ebx),%eax
  806330:	89 04 24             	mov    %eax,(%esp)
  806333:	e8 46 5e 00 00       	call   80c17e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806338:	89 7c 24 10          	mov    %edi,0x10(%esp)
  80633c:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806343:	00 
  806344:	c7 44 24 08 30 3b 81 	movl   $0x813b30,0x8(%esp)
  80634b:	00 
  80634c:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80634f:	89 44 24 04          	mov    %eax,0x4(%esp)
  806353:	8b 43 08             	mov    0x8(%ebx),%eax
  806356:	89 04 24             	mov    %eax,(%esp)
  806359:	e8 a2 5e 00 00       	call   80c200 <udp_sendto_if>
    dhcp_delete_request(netif);
  80635e:	89 f8                	mov    %edi,%eax
  806360:	e8 f0 f7 ff ff       	call   805b55 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  806365:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  806369:	83 c1 01             	add    $0x1,%ecx
  80636c:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80636f:	ba 10 27 00 00       	mov    $0x2710,%edx
  806374:	80 f9 09             	cmp    $0x9,%cl
  806377:	77 08                	ja     806381 <dhcp_rebind+0xf0>
  806379:	0f b6 c9             	movzbl %cl,%ecx
  80637c:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  806381:	0f b7 d2             	movzwl %dx,%edx
  806384:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  80638a:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  80638f:	89 d0                	mov    %edx,%eax
  806391:	f7 e9                	imul   %ecx
  806393:	c1 fa 05             	sar    $0x5,%edx
  806396:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  80639a:	89 f0                	mov    %esi,%eax
  80639c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80639f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8063a2:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8063a5:	89 ec                	mov    %ebp,%esp
  8063a7:	5d                   	pop    %ebp
  8063a8:	c3                   	ret    

008063a9 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  8063a9:	55                   	push   %ebp
  8063aa:	89 e5                	mov    %esp,%ebp
  8063ac:	53                   	push   %ebx
  8063ad:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  8063b0:	8b 1d 04 f0 b3 00    	mov    0xb3f004,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  8063b6:	85 db                	test   %ebx,%ebx
  8063b8:	74 67                	je     806421 <dhcp_coarse_tmr+0x78>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  8063ba:	8b 43 20             	mov    0x20(%ebx),%eax
  8063bd:	85 c0                	test   %eax,%eax
  8063bf:	74 5a                	je     80641b <dhcp_coarse_tmr+0x72>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  8063c1:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  8063c5:	8d 4a ff             	lea    -0x1(%edx),%ecx
  8063c8:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  8063cc:	66 83 fa 01          	cmp    $0x1,%dx
  8063d0:	75 1b                	jne    8063ed <dhcp_coarse_tmr+0x44>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  8063d2:	8b 43 20             	mov    0x20(%ebx),%eax
  8063d5:	0f b6 00             	movzbl (%eax),%eax
  8063d8:	3c 01                	cmp    $0x1,%al
  8063da:	74 08                	je     8063e4 <dhcp_coarse_tmr+0x3b>
  8063dc:	3c 0a                	cmp    $0xa,%al
  8063de:	74 04                	je     8063e4 <dhcp_coarse_tmr+0x3b>
  8063e0:	3c 05                	cmp    $0x5,%al
  8063e2:	75 37                	jne    80641b <dhcp_coarse_tmr+0x72>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  8063e4:	89 d8                	mov    %ebx,%eax
  8063e6:	e8 a6 fe ff ff       	call   806291 <dhcp_rebind>
  8063eb:	eb 2e                	jmp    80641b <dhcp_coarse_tmr+0x72>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  8063ed:	8b 53 20             	mov    0x20(%ebx),%edx
  8063f0:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  8063f4:	8d 48 ff             	lea    -0x1(%eax),%ecx
  8063f7:	66 89 4a 28          	mov    %cx,0x28(%edx)
  8063fb:	66 83 f8 01          	cmp    $0x1,%ax
  8063ff:	75 1a                	jne    80641b <dhcp_coarse_tmr+0x72>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  806401:	8b 43 20             	mov    0x20(%ebx),%eax
  806404:	0f b6 00             	movzbl (%eax),%eax
  806407:	3c 01                	cmp    $0x1,%al
  806409:	74 08                	je     806413 <dhcp_coarse_tmr+0x6a>
  80640b:	3c 0a                	cmp    $0xa,%al
  80640d:	74 04                	je     806413 <dhcp_coarse_tmr+0x6a>
  80640f:	3c 05                	cmp    $0x5,%al
  806411:	75 08                	jne    80641b <dhcp_coarse_tmr+0x72>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  806413:	89 1c 24             	mov    %ebx,(%esp)
  806416:	e8 03 fc ff ff       	call   80601e <dhcp_renew>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  80641b:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  80641d:	85 db                	test   %ebx,%ebx
  80641f:	75 99                	jne    8063ba <dhcp_coarse_tmr+0x11>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  806421:	83 c4 14             	add    $0x14,%esp
  806424:	5b                   	pop    %ebx
  806425:	5d                   	pop    %ebp
  806426:	c3                   	ret    

00806427 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  806427:	55                   	push   %ebp
  806428:	89 e5                	mov    %esp,%ebp
  80642a:	83 ec 28             	sub    $0x28,%esp
  80642d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  806430:	89 75 fc             	mov    %esi,-0x4(%ebp)
  806433:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  806436:	85 f6                	test   %esi,%esi
  806438:	75 1c                	jne    806456 <dhcp_arp_reply+0x2f>
  80643a:	c7 44 24 08 83 32 81 	movl   $0x813283,0x8(%esp)
  806441:	00 
  806442:	c7 44 24 04 b5 02 00 	movl   $0x2b5,0x4(%esp)
  806449:	00 
  80644a:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  806451:	e8 92 a5 ff ff       	call   8009e8 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  806456:	8b 5e 20             	mov    0x20(%esi),%ebx
  806459:	85 db                	test   %ebx,%ebx
  80645b:	0f 84 04 01 00 00    	je     806565 <dhcp_arp_reply+0x13e>
  806461:	80 3b 08             	cmpb   $0x8,(%ebx)
  806464:	0f 85 fb 00 00 00    	jne    806565 <dhcp_arp_reply+0x13e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  80646a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80646d:	8b 00                	mov    (%eax),%eax
  80646f:	3b 43 30             	cmp    0x30(%ebx),%eax
  806472:	0f 85 ed 00 00 00    	jne    806565 <dhcp_arp_reply+0x13e>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  806478:	ba 0c 00 00 00       	mov    $0xc,%edx
  80647d:	89 d8                	mov    %ebx,%eax
  80647f:	e8 cc f2 ff ff       	call   805750 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  806484:	89 f0                	mov    %esi,%eax
  806486:	e8 35 f8 ff ff       	call   805cc0 <dhcp_create_request>
  if (result == ERR_OK) {
  80648b:	84 c0                	test   %al,%al
  80648d:	0f 85 c8 00 00 00    	jne    80655b <dhcp_arp_reply+0x134>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  806493:	b9 01 00 00 00       	mov    $0x1,%ecx
  806498:	ba 35 00 00 00       	mov    $0x35,%edx
  80649d:	89 d8                	mov    %ebx,%eax
  80649f:	e8 f8 f3 ff ff       	call   80589c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  8064a4:	ba 04 00 00 00       	mov    $0x4,%edx
  8064a9:	89 d8                	mov    %ebx,%eax
  8064ab:	e8 5b f4 ff ff       	call   80590b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8064b0:	b9 02 00 00 00       	mov    $0x2,%ecx
  8064b5:	ba 39 00 00 00       	mov    $0x39,%edx
  8064ba:	89 d8                	mov    %ebx,%eax
  8064bc:	e8 db f3 ff ff       	call   80589c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8064c1:	ba 40 02 00 00       	mov    $0x240,%edx
  8064c6:	89 d8                	mov    %ebx,%eax
  8064c8:	e8 58 f5 ff ff       	call   805a25 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8064cd:	b9 04 00 00 00       	mov    $0x4,%ecx
  8064d2:	ba 32 00 00 00       	mov    $0x32,%edx
  8064d7:	89 d8                	mov    %ebx,%eax
  8064d9:	e8 be f3 ff ff       	call   80589c <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8064de:	8b 43 30             	mov    0x30(%ebx),%eax
  8064e1:	89 04 24             	mov    %eax,(%esp)
  8064e4:	e8 d1 49 00 00       	call   80aeba <ntohl>
  8064e9:	89 c2                	mov    %eax,%edx
  8064eb:	89 d8                	mov    %ebx,%eax
  8064ed:	e8 b2 f5 ff ff       	call   805aa4 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  8064f2:	89 d8                	mov    %ebx,%eax
  8064f4:	e8 62 f4 ff ff       	call   80595b <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8064f9:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8064fd:	66 05 f0 00          	add    $0xf0,%ax
  806501:	0f b7 c0             	movzwl %ax,%eax
  806504:	89 44 24 04          	mov    %eax,0x4(%esp)
  806508:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80650b:	89 04 24             	mov    %eax,(%esp)
  80650e:	e8 ed 1a 00 00       	call   808000 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806513:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80651a:	00 
  80651b:	c7 44 24 04 2c 3b 81 	movl   $0x813b2c,0x4(%esp)
  806522:	00 
  806523:	8b 43 08             	mov    0x8(%ebx),%eax
  806526:	89 04 24             	mov    %eax,(%esp)
  806529:	e8 50 5c 00 00       	call   80c17e <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80652e:	89 74 24 10          	mov    %esi,0x10(%esp)
  806532:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806539:	00 
  80653a:	c7 44 24 08 30 3b 81 	movl   $0x813b30,0x8(%esp)
  806541:	00 
  806542:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806545:	89 44 24 04          	mov    %eax,0x4(%esp)
  806549:	8b 43 08             	mov    0x8(%ebx),%eax
  80654c:	89 04 24             	mov    %eax,(%esp)
  80654f:	e8 ac 5c 00 00       	call   80c200 <udp_sendto_if>
    dhcp_delete_request(netif);
  806554:	89 f0                	mov    %esi,%eax
  806556:	e8 fa f5 ff ff       	call   805b55 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80655b:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80655f:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  806565:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  806568:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80656b:	89 ec                	mov    %ebp,%esp
  80656d:	5d                   	pop    %ebp
  80656e:	c3                   	ret    

0080656f <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  80656f:	55                   	push   %ebp
  806570:	89 e5                	mov    %esp,%ebp
  806572:	57                   	push   %edi
  806573:	56                   	push   %esi
  806574:	53                   	push   %ebx
  806575:	83 ec 2c             	sub    $0x2c,%esp
  806578:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  80657a:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80657d:	e8 3e f7 ff ff       	call   805cc0 <dhcp_create_request>
  806582:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  806584:	84 c0                	test   %al,%al
  806586:	0f 85 3a 01 00 00    	jne    8066c6 <dhcp_select+0x157>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80658c:	b9 01 00 00 00       	mov    $0x1,%ecx
  806591:	ba 35 00 00 00       	mov    $0x35,%edx
  806596:	89 d8                	mov    %ebx,%eax
  806598:	e8 ff f2 ff ff       	call   80589c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80659d:	ba 03 00 00 00       	mov    $0x3,%edx
  8065a2:	89 d8                	mov    %ebx,%eax
  8065a4:	e8 62 f3 ff ff       	call   80590b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8065a9:	b9 02 00 00 00       	mov    $0x2,%ecx
  8065ae:	ba 39 00 00 00       	mov    $0x39,%edx
  8065b3:	89 d8                	mov    %ebx,%eax
  8065b5:	e8 e2 f2 ff ff       	call   80589c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8065ba:	ba 40 02 00 00       	mov    $0x240,%edx
  8065bf:	89 d8                	mov    %ebx,%eax
  8065c1:	e8 5f f4 ff ff       	call   805a25 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8065c6:	b9 04 00 00 00       	mov    $0x4,%ecx
  8065cb:	ba 32 00 00 00       	mov    $0x32,%edx
  8065d0:	89 d8                	mov    %ebx,%eax
  8065d2:	e8 c5 f2 ff ff       	call   80589c <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8065d7:	8b 43 30             	mov    0x30(%ebx),%eax
  8065da:	89 04 24             	mov    %eax,(%esp)
  8065dd:	e8 d8 48 00 00       	call   80aeba <ntohl>
  8065e2:	89 c2                	mov    %eax,%edx
  8065e4:	89 d8                	mov    %ebx,%eax
  8065e6:	e8 b9 f4 ff ff       	call   805aa4 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8065eb:	b9 04 00 00 00       	mov    $0x4,%ecx
  8065f0:	ba 36 00 00 00       	mov    $0x36,%edx
  8065f5:	89 d8                	mov    %ebx,%eax
  8065f7:	e8 a0 f2 ff ff       	call   80589c <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  8065fc:	8b 43 2c             	mov    0x2c(%ebx),%eax
  8065ff:	89 04 24             	mov    %eax,(%esp)
  806602:	e8 b3 48 00 00       	call   80aeba <ntohl>
  806607:	89 c2                	mov    %eax,%edx
  806609:	89 d8                	mov    %ebx,%eax
  80660b:	e8 94 f4 ff ff       	call   805aa4 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  806610:	b9 04 00 00 00       	mov    $0x4,%ecx
  806615:	ba 37 00 00 00       	mov    $0x37,%edx
  80661a:	89 d8                	mov    %ebx,%eax
  80661c:	e8 7b f2 ff ff       	call   80589c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  806621:	ba 01 00 00 00       	mov    $0x1,%edx
  806626:	89 d8                	mov    %ebx,%eax
  806628:	e8 de f2 ff ff       	call   80590b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80662d:	ba 03 00 00 00       	mov    $0x3,%edx
  806632:	89 d8                	mov    %ebx,%eax
  806634:	e8 d2 f2 ff ff       	call   80590b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  806639:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80663e:	89 d8                	mov    %ebx,%eax
  806640:	e8 c6 f2 ff ff       	call   80590b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  806645:	ba 06 00 00 00       	mov    $0x6,%edx
  80664a:	89 d8                	mov    %ebx,%eax
  80664c:	e8 ba f2 ff ff       	call   80590b <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  806651:	89 d8                	mov    %ebx,%eax
  806653:	e8 03 f3 ff ff       	call   80595b <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806658:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80665c:	66 05 f0 00          	add    $0xf0,%ax
  806660:	0f b7 c0             	movzwl %ax,%eax
  806663:	89 44 24 04          	mov    %eax,0x4(%esp)
  806667:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80666a:	89 04 24             	mov    %eax,(%esp)
  80666d:	e8 8e 19 00 00       	call   808000 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806672:	89 7c 24 10          	mov    %edi,0x10(%esp)
  806676:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  80667d:	00 
  80667e:	c7 44 24 08 30 3b 81 	movl   $0x813b30,0x8(%esp)
  806685:	00 
  806686:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806689:	89 44 24 04          	mov    %eax,0x4(%esp)
  80668d:	8b 43 08             	mov    0x8(%ebx),%eax
  806690:	89 04 24             	mov    %eax,(%esp)
  806693:	e8 68 5b 00 00       	call   80c200 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806698:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80669f:	00 
  8066a0:	c7 44 24 04 2c 3b 81 	movl   $0x813b2c,0x4(%esp)
  8066a7:	00 
  8066a8:	8b 43 08             	mov    0x8(%ebx),%eax
  8066ab:	89 04 24             	mov    %eax,(%esp)
  8066ae:	e8 cb 5a 00 00       	call   80c17e <udp_connect>
    dhcp_delete_request(netif);
  8066b3:	89 f8                	mov    %edi,%eax
  8066b5:	e8 9b f4 ff ff       	call   805b55 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8066ba:	ba 01 00 00 00       	mov    $0x1,%edx
  8066bf:	89 d8                	mov    %ebx,%eax
  8066c1:	e8 8a f0 ff ff       	call   805750 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8066c6:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  8066ca:	83 c1 01             	add    $0x1,%ecx
  8066cd:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  8066d0:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  8066d5:	80 f9 03             	cmp    $0x3,%cl
  8066d8:	77 08                	ja     8066e2 <dhcp_select+0x173>
  8066da:	0f b6 c9             	movzbl %cl,%ecx
  8066dd:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8066e2:	0f b7 d2             	movzwl %dx,%edx
  8066e5:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8066eb:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8066f0:	89 d0                	mov    %edx,%eax
  8066f2:	f7 e9                	imul   %ecx
  8066f4:	c1 fa 05             	sar    $0x5,%edx
  8066f7:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8066fb:	89 f0                	mov    %esi,%eax
  8066fd:	83 c4 2c             	add    $0x2c,%esp
  806700:	5b                   	pop    %ebx
  806701:	5e                   	pop    %esi
  806702:	5f                   	pop    %edi
  806703:	5d                   	pop    %ebp
  806704:	c3                   	ret    

00806705 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  806705:	55                   	push   %ebp
  806706:	89 e5                	mov    %esp,%ebp
  806708:	83 ec 38             	sub    $0x38,%esp
  80670b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80670e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  806711:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806714:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  806717:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  80671a:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  806721:	e8 ba 09 00 00       	call   8070e0 <mem_malloc>
  806726:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
  806728:	85 c0                	test   %eax,%eax
  80672a:	0f 84 40 01 00 00    	je     806870 <dhcp_inform+0x16b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  806730:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  806733:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  80673a:	00 
  80673b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806742:	00 
  806743:	89 04 24             	mov    %eax,(%esp)
  806746:	e8 0b ae ff ff       	call   801556 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  80674b:	e8 df 58 00 00       	call   80c02f <udp_new>
  806750:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  806753:	85 c0                	test   %eax,%eax
  806755:	75 0e                	jne    806765 <dhcp_inform+0x60>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  806757:	89 1c 24             	mov    %ebx,(%esp)
  80675a:	e8 0f 0d 00 00       	call   80746e <mem_free>
    return;
  80675f:	90                   	nop
  806760:	e9 0b 01 00 00       	jmp    806870 <dhcp_inform+0x16b>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  806765:	89 f0                	mov    %esi,%eax
  806767:	e8 54 f5 ff ff       	call   805cc0 <dhcp_create_request>
  if (result == ERR_OK) {
  80676c:	84 c0                	test   %al,%al
  80676e:	66 90                	xchg   %ax,%ax
  806770:	0f 85 d9 00 00 00    	jne    80684f <dhcp_inform+0x14a>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  806776:	b9 01 00 00 00       	mov    $0x1,%ecx
  80677b:	ba 35 00 00 00       	mov    $0x35,%edx
  806780:	89 d8                	mov    %ebx,%eax
  806782:	e8 15 f1 ff ff       	call   80589c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  806787:	ba 08 00 00 00       	mov    $0x8,%edx
  80678c:	89 d8                	mov    %ebx,%eax
  80678e:	e8 78 f1 ff ff       	call   80590b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  806793:	b9 02 00 00 00       	mov    $0x2,%ecx
  806798:	ba 39 00 00 00       	mov    $0x39,%edx
  80679d:	89 d8                	mov    %ebx,%eax
  80679f:	e8 f8 f0 ff ff       	call   80589c <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  8067a4:	ba 40 02 00 00       	mov    $0x240,%edx
  8067a9:	89 d8                	mov    %ebx,%eax
  8067ab:	e8 75 f2 ff ff       	call   805a25 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  8067b0:	89 d8                	mov    %ebx,%eax
  8067b2:	e8 a4 f1 ff ff       	call   80595b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8067b7:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8067bb:	66 05 f0 00          	add    $0xf0,%ax
  8067bf:	0f b7 c0             	movzwl %ax,%eax
  8067c2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8067c6:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8067c9:	89 04 24             	mov    %eax,(%esp)
  8067cc:	e8 2f 18 00 00       	call   808000 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  8067d1:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  8067d8:	00 
  8067d9:	c7 44 24 04 2c 3b 81 	movl   $0x813b2c,0x4(%esp)
  8067e0:	00 
  8067e1:	8b 43 08             	mov    0x8(%ebx),%eax
  8067e4:	89 04 24             	mov    %eax,(%esp)
  8067e7:	e8 cc 58 00 00       	call   80c0b8 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  8067ec:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8067f3:	00 
  8067f4:	c7 44 24 04 30 3b 81 	movl   $0x813b30,0x4(%esp)
  8067fb:	00 
  8067fc:	8b 43 08             	mov    0x8(%ebx),%eax
  8067ff:	89 04 24             	mov    %eax,(%esp)
  806802:	e8 77 59 00 00       	call   80c17e <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806807:	89 74 24 10          	mov    %esi,0x10(%esp)
  80680b:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806812:	00 
  806813:	c7 44 24 08 30 3b 81 	movl   $0x813b30,0x8(%esp)
  80681a:	00 
  80681b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80681e:	89 44 24 04          	mov    %eax,0x4(%esp)
  806822:	8b 43 08             	mov    0x8(%ebx),%eax
  806825:	89 04 24             	mov    %eax,(%esp)
  806828:	e8 d3 59 00 00       	call   80c200 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80682d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806834:	00 
  806835:	c7 44 24 04 2c 3b 81 	movl   $0x813b2c,0x4(%esp)
  80683c:	00 
  80683d:	8b 43 08             	mov    0x8(%ebx),%eax
  806840:	89 04 24             	mov    %eax,(%esp)
  806843:	e8 36 59 00 00       	call   80c17e <udp_connect>
    dhcp_delete_request(netif);
  806848:	89 f0                	mov    %esi,%eax
  80684a:	e8 06 f3 ff ff       	call   805b55 <dhcp_delete_request>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  80684f:	8b 43 08             	mov    0x8(%ebx),%eax
  806852:	85 c0                	test   %eax,%eax
  806854:	74 08                	je     80685e <dhcp_inform+0x159>
      udp_remove(dhcp->pcb);
  806856:	89 04 24             	mov    %eax,(%esp)
  806859:	e8 0e 58 00 00       	call   80c06c <udp_remove>
    }
    dhcp->pcb = NULL;
  80685e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  806865:	89 1c 24             	mov    %ebx,(%esp)
  806868:	e8 01 0c 00 00       	call   80746e <mem_free>
    netif->dhcp = old_dhcp;
  80686d:	89 7e 20             	mov    %edi,0x20(%esi)
  }
}
  806870:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  806873:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806876:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806879:	89 ec                	mov    %ebp,%esp
  80687b:	5d                   	pop    %ebp
  80687c:	c3                   	ret    

0080687d <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  80687d:	55                   	push   %ebp
  80687e:	89 e5                	mov    %esp,%ebp
  806880:	56                   	push   %esi
  806881:	53                   	push   %ebx
  806882:	83 ec 10             	sub    $0x10,%esp
  806885:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  806888:	85 f6                	test   %esi,%esi
  80688a:	75 1c                	jne    8068a8 <dhcp_start+0x2b>
  80688c:	c7 44 24 08 83 32 81 	movl   $0x813283,0x8(%esp)
  806893:	00 
  806894:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  80689b:	00 
  80689c:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  8068a3:	e8 40 a1 ff ff       	call   8009e8 <_panic>
  dhcp = netif->dhcp;
  8068a8:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  8068ab:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  8068af:	85 db                	test   %ebx,%ebx
  8068b1:	75 1e                	jne    8068d1 <dhcp_start+0x54>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  8068b3:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  8068ba:	e8 21 08 00 00       	call   8070e0 <mem_malloc>
  8068bf:	89 c3                	mov    %eax,%ebx
    if (dhcp == NULL) {
  8068c1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8068c6:	85 db                	test   %ebx,%ebx
  8068c8:	0f 84 a5 00 00 00    	je     806973 <dhcp_start+0xf6>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  8068ce:	89 5e 20             	mov    %ebx,0x20(%esi)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  8068d1:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  8068d8:	00 
  8068d9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8068e0:	00 
  8068e1:	89 1c 24             	mov    %ebx,(%esp)
  8068e4:	e8 6d ac ff ff       	call   801556 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  8068e9:	e8 41 57 00 00       	call   80c02f <udp_new>
  8068ee:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  8068f1:	85 c0                	test   %eax,%eax
  8068f3:	75 16                	jne    80690b <dhcp_start+0x8e>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  8068f5:	89 1c 24             	mov    %ebx,(%esp)
  8068f8:	e8 71 0b 00 00       	call   80746e <mem_free>
    netif->dhcp = dhcp = NULL;
  8068fd:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  806904:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  806909:	eb 68                	jmp    806973 <dhcp_start+0xf6>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80690b:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  806912:	00 
  806913:	c7 44 24 04 2c 3b 81 	movl   $0x813b2c,0x4(%esp)
  80691a:	00 
  80691b:	89 04 24             	mov    %eax,(%esp)
  80691e:	e8 95 57 00 00       	call   80c0b8 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806923:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80692a:	00 
  80692b:	c7 44 24 04 2c 3b 81 	movl   $0x813b2c,0x4(%esp)
  806932:	00 
  806933:	8b 43 08             	mov    0x8(%ebx),%eax
  806936:	89 04 24             	mov    %eax,(%esp)
  806939:	e8 40 58 00 00       	call   80c17e <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  80693e:	89 74 24 08          	mov    %esi,0x8(%esp)
  806942:	c7 44 24 04 52 6b 80 	movl   $0x806b52,0x4(%esp)
  806949:	00 
  80694a:	8b 43 08             	mov    0x8(%ebx),%eax
  80694d:	89 04 24             	mov    %eax,(%esp)
  806950:	e8 c6 56 00 00       	call   80c01b <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  806955:	89 f0                	mov    %esi,%eax
  806957:	e8 dc f7 ff ff       	call   806138 <dhcp_discover>
  if (result != ERR_OK) {
  80695c:	84 c0                	test   %al,%al
  80695e:	74 0f                	je     80696f <dhcp_start+0xf2>
    /* free resources allocated above */
    dhcp_stop(netif);
  806960:	89 34 24             	mov    %esi,(%esp)
  806963:	e8 d9 f2 ff ff       	call   805c41 <dhcp_stop>
  806968:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  80696d:	eb 04                	jmp    806973 <dhcp_start+0xf6>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  80696f:	80 4e 2e 08          	orb    $0x8,0x2e(%esi)
  return result;
}
  806973:	83 c4 10             	add    $0x10,%esp
  806976:	5b                   	pop    %ebx
  806977:	5e                   	pop    %esi
  806978:	5d                   	pop    %ebp
  806979:	c3                   	ret    

0080697a <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  80697a:	55                   	push   %ebp
  80697b:	89 e5                	mov    %esp,%ebp
  80697d:	53                   	push   %ebx
  80697e:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp = netif->dhcp;
  806981:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  806984:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80698b:	00 
  80698c:	8d 53 30             	lea    0x30(%ebx),%edx
  80698f:	89 54 24 04          	mov    %edx,0x4(%esp)
  806993:	89 04 24             	mov    %eax,(%esp)
  806996:	e8 9c 62 00 00       	call   80cc37 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  80699b:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80699f:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  8069a5:	ba 08 00 00 00       	mov    $0x8,%edx
  8069aa:	89 d8                	mov    %ebx,%eax
  8069ac:	e8 9f ed ff ff       	call   805750 <dhcp_set_state>
}
  8069b1:	83 c4 14             	add    $0x14,%esp
  8069b4:	5b                   	pop    %ebx
  8069b5:	5d                   	pop    %ebp
  8069b6:	c3                   	ret    

008069b7 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  8069b7:	55                   	push   %ebp
  8069b8:	89 e5                	mov    %esp,%ebp
  8069ba:	57                   	push   %edi
  8069bb:	56                   	push   %esi
  8069bc:	53                   	push   %ebx
  8069bd:	83 ec 2c             	sub    $0x2c,%esp
  8069c0:	89 c6                	mov    %eax,%esi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  8069c2:	85 c0                	test   %eax,%eax
  8069c4:	75 1c                	jne    8069e2 <dhcp_bind+0x2b>
  8069c6:	c7 44 24 08 78 32 81 	movl   $0x813278,0x8(%esp)
  8069cd:	00 
  8069ce:	c7 44 24 04 3d 03 00 	movl   $0x33d,0x4(%esp)
  8069d5:	00 
  8069d6:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  8069dd:	e8 06 a0 ff ff       	call   8009e8 <_panic>
  dhcp = netif->dhcp;
  8069e2:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  8069e5:	85 db                	test   %ebx,%ebx
  8069e7:	75 1c                	jne    806a05 <dhcp_bind+0x4e>
  8069e9:	c7 44 24 08 91 32 81 	movl   $0x813291,0x8(%esp)
  8069f0:	00 
  8069f1:	c7 44 24 04 3f 03 00 	movl   $0x33f,0x4(%esp)
  8069f8:	00 
  8069f9:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  806a00:	e8 e3 9f ff ff       	call   8009e8 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  806a05:	8b 53 50             	mov    0x50(%ebx),%edx
  806a08:	83 fa ff             	cmp    $0xffffffff,%edx
  806a0b:	74 2b                	je     806a38 <dhcp_bind+0x81>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  806a0d:	83 c2 1e             	add    $0x1e,%edx
  806a10:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  806a15:	89 d0                	mov    %edx,%eax
  806a17:	f7 e1                	mul    %ecx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  806a19:	c1 ea 05             	shr    $0x5,%edx
  806a1c:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  806a22:	76 05                	jbe    806a29 <dhcp_bind+0x72>
  806a24:	ba ff ff 00 00       	mov    $0xffff,%edx
  806a29:	66 89 53 28          	mov    %dx,0x28(%ebx)
    if (dhcp->t1_timeout == 0) {
  806a2d:	66 85 d2             	test   %dx,%dx
  806a30:	75 06                	jne    806a38 <dhcp_bind+0x81>
      dhcp->t1_timeout = 1;
  806a32:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  806a38:	8b 53 54             	mov    0x54(%ebx),%edx
  806a3b:	83 fa ff             	cmp    $0xffffffff,%edx
  806a3e:	74 2b                	je     806a6b <dhcp_bind+0xb4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  806a40:	83 c2 1e             	add    $0x1e,%edx
  806a43:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  806a48:	89 d0                	mov    %edx,%eax
  806a4a:	f7 e1                	mul    %ecx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  806a4c:	c1 ea 05             	shr    $0x5,%edx
  806a4f:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  806a55:	76 05                	jbe    806a5c <dhcp_bind+0xa5>
  806a57:	ba ff ff 00 00       	mov    $0xffff,%edx
  806a5c:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
    if (dhcp->t2_timeout == 0) {
  806a60:	66 85 d2             	test   %dx,%dx
  806a63:	75 06                	jne    806a6b <dhcp_bind+0xb4>
      dhcp->t2_timeout = 1;
  806a65:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  806a6b:	83 fb cc             	cmp    $0xffffffcc,%ebx
  806a6e:	0f 84 c7 00 00 00    	je     806b3b <dhcp_bind+0x184>
  806a74:	8b 43 34             	mov    0x34(%ebx),%eax
  806a77:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  806a7a:	85 c0                	test   %eax,%eax
  806a7c:	75 4b                	jne    806ac9 <dhcp_bind+0x112>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  806a7e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  806a85:	e8 30 44 00 00       	call   80aeba <ntohl>
  806a8a:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  806a8d:	84 c0                	test   %al,%al
  806a8f:	78 11                	js     806aa2 <dhcp_bind+0xeb>
      sn_mask.addr = htonl(0xff000000);
  806a91:	c7 04 24 00 00 00 ff 	movl   $0xff000000,(%esp)
  806a98:	e8 f8 41 00 00       	call   80ac95 <htonl>
  806a9d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806aa0:	eb 27                	jmp    806ac9 <dhcp_bind+0x112>
    } else if (first_octet >= 192) {
  806aa2:	3c bf                	cmp    $0xbf,%al
  806aa4:	76 14                	jbe    806aba <dhcp_bind+0x103>
      sn_mask.addr = htonl(0xffffff00);
  806aa6:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  806aad:	8d 76 00             	lea    0x0(%esi),%esi
  806ab0:	e8 e0 41 00 00       	call   80ac95 <htonl>
  806ab5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806ab8:	eb 0f                	jmp    806ac9 <dhcp_bind+0x112>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  806aba:	c7 04 24 00 00 ff ff 	movl   $0xffff0000,(%esp)
  806ac1:	e8 cf 41 00 00       	call   80ac95 <htonl>
  806ac6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  806ac9:	83 fb c8             	cmp    $0xffffffc8,%ebx
  806acc:	74 79                	je     806b47 <dhcp_bind+0x190>
  806ace:	8b 43 38             	mov    0x38(%ebx),%eax
  806ad1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  806ad4:	85 c0                	test   %eax,%eax
  806ad6:	75 1a                	jne    806af2 <dhcp_bind+0x13b>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  806ad8:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  806adb:	23 7b 30             	and    0x30(%ebx),%edi
  806ade:	89 7d e0             	mov    %edi,-0x20(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  806ae1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  806ae8:	e8 a8 41 00 00       	call   80ac95 <htonl>
  806aed:	09 c7                	or     %eax,%edi
  806aef:	89 7d e0             	mov    %edi,-0x20(%ebp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  806af2:	8d 43 30             	lea    0x30(%ebx),%eax
  806af5:	89 44 24 04          	mov    %eax,0x4(%esp)
  806af9:	89 34 24             	mov    %esi,(%esp)
  806afc:	e8 c3 0d 00 00       	call   8078c4 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  806b01:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  806b04:	89 44 24 04          	mov    %eax,0x4(%esp)
  806b08:	89 34 24             	mov    %esi,(%esp)
  806b0b:	e8 d8 0c 00 00       	call   8077e8 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  806b10:	8d 45 e0             	lea    -0x20(%ebp),%eax
  806b13:	89 44 24 04          	mov    %eax,0x4(%esp)
  806b17:	89 34 24             	mov    %esi,(%esp)
  806b1a:	e8 b0 0c 00 00       	call   8077cf <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  806b1f:	89 34 24             	mov    %esi,(%esp)
  806b22:	e8 67 0d 00 00       	call   80788e <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  806b27:	ba 0a 00 00 00       	mov    $0xa,%edx
  806b2c:	89 d8                	mov    %ebx,%eax
  806b2e:	e8 1d ec ff ff       	call   805750 <dhcp_set_state>
}
  806b33:	83 c4 2c             	add    $0x2c,%esp
  806b36:	5b                   	pop    %ebx
  806b37:	5e                   	pop    %esi
  806b38:	5f                   	pop    %edi
  806b39:	5d                   	pop    %ebp
  806b3a:	c3                   	ret    
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  806b3b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  806b42:	e9 37 ff ff ff       	jmp    806a7e <dhcp_bind+0xc7>
    } else {
      sn_mask.addr = htonl(0xffff0000);
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  806b47:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806b4e:	66 90                	xchg   %ax,%ax
  806b50:	eb 86                	jmp    806ad8 <dhcp_bind+0x121>

00806b52 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  806b52:	55                   	push   %ebp
  806b53:	89 e5                	mov    %esp,%ebp
  806b55:	57                   	push   %edi
  806b56:	56                   	push   %esi
  806b57:	53                   	push   %ebx
  806b58:	83 ec 2c             	sub    $0x2c,%esp
  struct netif *netif = (struct netif *)arg;
  806b5b:	8b 45 08             	mov    0x8(%ebp),%eax
  806b5e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  struct dhcp *dhcp = netif->dhcp;
  806b61:	8b 50 20             	mov    0x20(%eax),%edx
  806b64:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  806b67:	8b 4d 10             	mov    0x10(%ebp),%ecx
  806b6a:	8b 71 04             	mov    0x4(%ecx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  806b6d:	89 4a 0c             	mov    %ecx,0xc(%edx)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  806b70:	80 3e 02             	cmpb   $0x2,(%esi)
  806b73:	0f 85 33 04 00 00    	jne    806fac <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  806b79:	0f b6 78 24          	movzbl 0x24(%eax),%edi
  806b7d:	89 fb                	mov    %edi,%ebx
  806b7f:	84 db                	test   %bl,%bl
  806b81:	74 35                	je     806bb8 <dhcp_recv+0x66>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  806b83:	0f b6 48 25          	movzbl 0x25(%eax),%ecx
  806b87:	89 c2                	mov    %eax,%edx
  806b89:	b8 00 00 00 00       	mov    $0x0,%eax
  806b8e:	3a 4e 1c             	cmp    0x1c(%esi),%cl
  806b91:	74 1c                	je     806baf <dhcp_recv+0x5d>
  806b93:	e9 14 04 00 00       	jmp    806fac <dhcp_recv+0x45a>
  806b98:	0f b6 5a 26          	movzbl 0x26(%edx),%ebx
  806b9c:	0f b6 4c 06 1d       	movzbl 0x1d(%esi,%eax,1),%ecx
  806ba1:	83 c0 01             	add    $0x1,%eax
  806ba4:	83 c2 01             	add    $0x1,%edx
  806ba7:	38 cb                	cmp    %cl,%bl
  806ba9:	0f 85 fd 03 00 00    	jne    806fac <dhcp_recv+0x45a>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  806baf:	8d 48 01             	lea    0x1(%eax),%ecx
  806bb2:	89 fb                	mov    %edi,%ebx
  806bb4:	38 cb                	cmp    %cl,%bl
  806bb6:	77 e0                	ja     806b98 <dhcp_recv+0x46>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  806bb8:	8b 46 04             	mov    0x4(%esi),%eax
  806bbb:	89 04 24             	mov    %eax,(%esp)
  806bbe:	e8 f7 42 00 00       	call   80aeba <ntohl>
  806bc3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806bc6:	3b 42 04             	cmp    0x4(%edx),%eax
  806bc9:	0f 85 dd 03 00 00    	jne    806fac <dhcp_recv+0x45a>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  806bcf:	85 d2                	test   %edx,%edx
  806bd1:	75 1c                	jne    806bef <dhcp_recv+0x9d>
  806bd3:	c7 44 24 08 9c 32 81 	movl   $0x81329c,0x8(%esp)
  806bda:	00 
  806bdb:	c7 44 24 04 89 04 00 	movl   $0x489,0x4(%esp)
  806be2:	00 
  806be3:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  806bea:	e8 f9 9d ff ff       	call   8009e8 <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  806bef:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806bf2:	83 79 0c 00          	cmpl   $0x0,0xc(%ecx)
  806bf6:	75 1c                	jne    806c14 <dhcp_recv+0xc2>
  806bf8:	c7 44 24 08 a9 32 81 	movl   $0x8132a9,0x8(%esp)
  806bff:	00 
  806c00:	c7 44 24 04 8a 04 00 	movl   $0x48a,0x4(%esp)
  806c07:	00 
  806c08:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  806c0f:	e8 d4 9d ff ff       	call   8009e8 <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  806c14:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806c17:	e8 e4 ef ff ff       	call   805c00 <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  806c1c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  806c1f:	8b 43 0c             	mov    0xc(%ebx),%eax
  806c22:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  806c26:	66 3d f0 00          	cmp    $0xf0,%ax
  806c2a:	76 1e                	jbe    806c4a <dhcp_recv+0xf8>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806c2c:	66 2d f0 00          	sub    $0xf0,%ax
  806c30:	66 89 43 18          	mov    %ax,0x18(%ebx)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  806c34:	0f b7 c0             	movzwl %ax,%eax
  806c37:	89 04 24             	mov    %eax,(%esp)
  806c3a:	e8 a1 04 00 00       	call   8070e0 <mem_malloc>
  806c3f:	89 43 14             	mov    %eax,0x14(%ebx)
    if (dhcp->options_in == NULL) {
  806c42:	85 c0                	test   %eax,%eax
  806c44:	0f 84 62 03 00 00    	je     806fac <dhcp_recv+0x45a>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806c4a:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  806c51:	e8 8a 04 00 00       	call   8070e0 <mem_malloc>
  806c56:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806c59:	89 42 10             	mov    %eax,0x10(%edx)
  if (dhcp->msg_in == NULL) {
  806c5c:	85 c0                	test   %eax,%eax
  806c5e:	75 1a                	jne    806c7a <dhcp_recv+0x128>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  806c60:	8b 42 14             	mov    0x14(%edx),%eax
  806c63:	89 04 24             	mov    %eax,(%esp)
  806c66:	e8 03 08 00 00       	call   80746e <mem_free>
    dhcp->options_in = NULL;
  806c6b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806c6e:	c7 41 14 00 00 00 00 	movl   $0x0,0x14(%ecx)
  806c75:	e9 32 03 00 00       	jmp    806fac <dhcp_recv+0x45a>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  806c7a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  806c81:	00 
  806c82:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  806c89:	00 
  806c8a:	89 44 24 04          	mov    %eax,0x4(%esp)
  806c8e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  806c91:	8b 43 0c             	mov    0xc(%ebx),%eax
  806c94:	89 04 24             	mov    %eax,(%esp)
  806c97:	e8 5a 0f 00 00       	call   807bf6 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806c9c:	66 3d f0 00          	cmp    $0xf0,%ax
  806ca0:	74 1c                	je     806cbe <dhcp_recv+0x16c>
  806ca2:	c7 44 24 08 18 32 81 	movl   $0x813218,0x8(%esp)
  806ca9:	00 
  806caa:	c7 44 24 04 a0 04 00 	movl   $0x4a0,0x4(%esp)
  806cb1:	00 
  806cb2:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  806cb9:	e8 2a 9d ff ff       	call   8009e8 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  806cbe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806cc1:	8b 42 14             	mov    0x14(%edx),%eax
  806cc4:	85 c0                	test   %eax,%eax
  806cc6:	0f 84 fd 02 00 00    	je     806fc9 <dhcp_recv+0x477>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806ccc:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  806cd3:	00 
  806cd4:	89 d1                	mov    %edx,%ecx
  806cd6:	0f b7 52 18          	movzwl 0x18(%edx),%edx
  806cda:	89 54 24 08          	mov    %edx,0x8(%esp)
  806cde:	89 44 24 04          	mov    %eax,0x4(%esp)
  806ce2:	8b 41 0c             	mov    0xc(%ecx),%eax
  806ce5:	89 04 24             	mov    %eax,(%esp)
  806ce8:	e8 09 0f 00 00       	call   807bf6 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  806ced:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  806cf0:	66 3b 43 18          	cmp    0x18(%ebx),%ax
  806cf4:	0f 84 cf 02 00 00    	je     806fc9 <dhcp_recv+0x477>
  806cfa:	c7 44 24 08 b9 32 81 	movl   $0x8132b9,0x8(%esp)
  806d01:	00 
  806d02:	c7 44 24 04 a7 04 00 	movl   $0x4a7,0x4(%esp)
  806d09:	00 
  806d0a:	c7 04 24 4a 32 81 00 	movl   $0x81324a,(%esp)
  806d11:	e8 d2 9c ff ff       	call   8009e8 <_panic>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  806d16:	83 c0 02             	add    $0x2,%eax
  806d19:	e8 4d eb ff ff       	call   80586b <dhcp_get_option_byte>
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  806d1e:	3c 05                	cmp    $0x5,%al
  806d20:	0f 85 a6 01 00 00    	jne    806ecc <dhcp_recv+0x37a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  806d26:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806d29:	0f b6 02             	movzbl (%edx),%eax
  806d2c:	3c 01                	cmp    $0x1,%al
  806d2e:	0f 85 77 01 00 00    	jne    806eab <dhcp_recv+0x359>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806d34:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806d37:	8b 59 20             	mov    0x20(%ecx),%ebx
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  806d3a:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  dhcp->offered_gw_addr.addr = 0;
  806d41:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_bc_addr.addr = 0;
  806d48:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  806d4f:	ba 33 00 00 00       	mov    $0x33,%edx
  806d54:	89 d8                	mov    %ebx,%eax
  806d56:	e8 04 ea ff ff       	call   80575f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806d5b:	85 c0                	test   %eax,%eax
  806d5d:	74 0b                	je     806d6a <dhcp_recv+0x218>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  806d5f:	83 c0 02             	add    $0x2,%eax
  806d62:	e8 0c eb ff ff       	call   805873 <dhcp_get_option_long>
  806d67:	89 43 4c             	mov    %eax,0x4c(%ebx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  806d6a:	ba 3a 00 00 00       	mov    $0x3a,%edx
  806d6f:	89 d8                	mov    %ebx,%eax
  806d71:	e8 e9 e9 ff ff       	call   80575f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806d76:	85 c0                	test   %eax,%eax
  806d78:	74 0d                	je     806d87 <dhcp_recv+0x235>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  806d7a:	83 c0 02             	add    $0x2,%eax
  806d7d:	e8 f1 ea ff ff       	call   805873 <dhcp_get_option_long>
  806d82:	89 43 50             	mov    %eax,0x50(%ebx)
  806d85:	eb 08                	jmp    806d8f <dhcp_recv+0x23d>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  806d87:	8b 43 4c             	mov    0x4c(%ebx),%eax
  806d8a:	d1 e8                	shr    %eax
  806d8c:	89 43 50             	mov    %eax,0x50(%ebx)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  806d8f:	ba 3b 00 00 00       	mov    $0x3b,%edx
  806d94:	89 d8                	mov    %ebx,%eax
  806d96:	e8 c4 e9 ff ff       	call   80575f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806d9b:	85 c0                	test   %eax,%eax
  806d9d:	74 0d                	je     806dac <dhcp_recv+0x25a>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  806d9f:	83 c0 02             	add    $0x2,%eax
  806da2:	e8 cc ea ff ff       	call   805873 <dhcp_get_option_long>
  806da7:	89 43 54             	mov    %eax,0x54(%ebx)
  806daa:	eb 06                	jmp    806db2 <dhcp_recv+0x260>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  806dac:	8b 43 4c             	mov    0x4c(%ebx),%eax
  806daf:	89 43 54             	mov    %eax,0x54(%ebx)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  806db2:	8b 53 10             	mov    0x10(%ebx),%edx
  806db5:	b8 00 00 00 00       	mov    $0x0,%eax
  806dba:	83 fa f0             	cmp    $0xfffffff0,%edx
  806dbd:	74 03                	je     806dc2 <dhcp_recv+0x270>
  806dbf:	8b 42 10             	mov    0x10(%edx),%eax
  806dc2:	89 43 30             	mov    %eax,0x30(%ebx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  806dc5:	ba 01 00 00 00       	mov    $0x1,%edx
  806dca:	89 d8                	mov    %ebx,%eax
  806dcc:	e8 8e e9 ff ff       	call   80575f <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  806dd1:	85 c0                	test   %eax,%eax
  806dd3:	74 13                	je     806de8 <dhcp_recv+0x296>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806dd5:	83 c0 02             	add    $0x2,%eax
  806dd8:	e8 96 ea ff ff       	call   805873 <dhcp_get_option_long>
  806ddd:	89 04 24             	mov    %eax,(%esp)
  806de0:	e8 b0 3e 00 00       	call   80ac95 <htonl>
  806de5:	89 43 34             	mov    %eax,0x34(%ebx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  806de8:	ba 03 00 00 00       	mov    $0x3,%edx
  806ded:	89 d8                	mov    %ebx,%eax
  806def:	e8 6b e9 ff ff       	call   80575f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806df4:	85 c0                	test   %eax,%eax
  806df6:	74 13                	je     806e0b <dhcp_recv+0x2b9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806df8:	83 c0 02             	add    $0x2,%eax
  806dfb:	e8 73 ea ff ff       	call   805873 <dhcp_get_option_long>
  806e00:	89 04 24             	mov    %eax,(%esp)
  806e03:	e8 8d 3e 00 00       	call   80ac95 <htonl>
  806e08:	89 43 38             	mov    %eax,0x38(%ebx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  806e0b:	ba 1c 00 00 00       	mov    $0x1c,%edx
  806e10:	89 d8                	mov    %ebx,%eax
  806e12:	e8 48 e9 ff ff       	call   80575f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806e17:	85 c0                	test   %eax,%eax
  806e19:	74 13                	je     806e2e <dhcp_recv+0x2dc>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806e1b:	83 c0 02             	add    $0x2,%eax
  806e1e:	e8 50 ea ff ff       	call   805873 <dhcp_get_option_long>
  806e23:	89 04 24             	mov    %eax,(%esp)
  806e26:	e8 6a 3e 00 00       	call   80ac95 <htonl>
  806e2b:	89 43 3c             	mov    %eax,0x3c(%ebx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  806e2e:	ba 06 00 00 00       	mov    $0x6,%edx
  806e33:	89 d8                	mov    %ebx,%eax
  806e35:	e8 25 e9 ff ff       	call   80575f <dhcp_get_option_ptr>
  806e3a:	89 c6                	mov    %eax,%esi
  if (option_ptr != NULL) {
  806e3c:	85 c0                	test   %eax,%eax
  806e3e:	74 55                	je     806e95 <dhcp_recv+0x343>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  806e40:	8d 40 01             	lea    0x1(%eax),%eax
  806e43:	e8 23 ea ff ff       	call   80586b <dhcp_get_option_byte>
  806e48:	c0 e8 02             	shr    $0x2,%al
  806e4b:	0f b6 c0             	movzbl %al,%eax
  806e4e:	89 43 40             	mov    %eax,0x40(%ebx)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  806e51:	83 f8 02             	cmp    $0x2,%eax
  806e54:	76 07                	jbe    806e5d <dhcp_recv+0x30b>
      dhcp->dns_count = DHCP_MAX_DNS;
  806e56:	c7 43 40 02 00 00 00 	movl   $0x2,0x40(%ebx)
  806e5d:	bf 00 00 00 00       	mov    $0x0,%edi
  806e62:	89 f8                	mov    %edi,%eax
  806e64:	89 f7                	mov    %esi,%edi
  806e66:	89 de                	mov    %ebx,%esi
  806e68:	89 c3                	mov    %eax,%ebx
  806e6a:	eb 21                	jmp    806e8d <dhcp_recv+0x33b>
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  806e6c:	0f b6 c3             	movzbl %bl,%eax
  806e6f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806e72:	8d 44 87 02          	lea    0x2(%edi,%eax,4),%eax
  806e76:	e8 f8 e9 ff ff       	call   805873 <dhcp_get_option_long>
  806e7b:	89 04 24             	mov    %eax,(%esp)
  806e7e:	e8 12 3e 00 00       	call   80ac95 <htonl>
  806e83:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806e86:	89 44 96 44          	mov    %eax,0x44(%esi,%edx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  806e8a:	83 c3 01             	add    $0x1,%ebx
  806e8d:	0f b6 c3             	movzbl %bl,%eax
  806e90:	3b 46 40             	cmp    0x40(%esi),%eax
  806e93:	72 d7                	jb     806e6c <dhcp_recv+0x31a>
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  806e95:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806e98:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  806e9e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806ea1:	e8 d4 fa ff ff       	call   80697a <dhcp_check>
  806ea6:	e9 01 01 00 00       	jmp    806fac <dhcp_recv+0x45a>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  806eab:	83 e8 03             	sub    $0x3,%eax
  806eae:	3c 02                	cmp    $0x2,%al
  806eb0:	0f 87 f6 00 00 00    	ja     806fac <dhcp_recv+0x45a>
      dhcp->request_timeout = 0;
  806eb6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  806eb9:	66 c7 43 26 00 00    	movw   $0x0,0x26(%ebx)
      dhcp_bind(netif);
  806ebf:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806ec2:	e8 f0 fa ff ff       	call   8069b7 <dhcp_bind>
  806ec7:	e9 e0 00 00 00       	jmp    806fac <dhcp_recv+0x45a>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  806ecc:	3c 06                	cmp    $0x6,%al
  806ece:	0f 85 80 00 00 00    	jne    806f54 <dhcp_recv+0x402>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  806ed4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806ed7:	0f b6 02             	movzbl (%edx),%eax
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  806eda:	3c 03                	cmp    $0x3,%al
  806edc:	74 10                	je     806eee <dhcp_recv+0x39c>
  806ede:	3c 01                	cmp    $0x1,%al
  806ee0:	74 0c                	je     806eee <dhcp_recv+0x39c>
  806ee2:	3c 04                	cmp    $0x4,%al
  806ee4:	74 08                	je     806eee <dhcp_recv+0x39c>
  806ee6:	3c 05                	cmp    $0x5,%al
  806ee8:	0f 85 be 00 00 00    	jne    806fac <dhcp_recv+0x45a>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  806eee:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806ef1:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806ef7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806efa:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  806efd:	89 04 24             	mov    %eax,(%esp)
  806f00:	e8 63 09 00 00       	call   807868 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  806f05:	c7 44 24 04 2c 3b 81 	movl   $0x813b2c,0x4(%esp)
  806f0c:	00 
  806f0d:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806f10:	89 14 24             	mov    %edx,(%esp)
  806f13:	e8 ac 09 00 00       	call   8078c4 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  806f18:	c7 44 24 04 2c 3b 81 	movl   $0x813b2c,0x4(%esp)
  806f1f:	00 
  806f20:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806f23:	89 0c 24             	mov    %ecx,(%esp)
  806f26:	e8 a4 08 00 00       	call   8077cf <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  806f2b:	c7 44 24 04 2c 3b 81 	movl   $0x813b2c,0x4(%esp)
  806f32:	00 
  806f33:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806f36:	89 04 24             	mov    %eax,(%esp)
  806f39:	e8 aa 08 00 00       	call   8077e8 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  806f3e:	ba 0c 00 00 00       	mov    $0xc,%edx
  806f43:	89 d8                	mov    %ebx,%eax
  806f45:	e8 06 e8 ff ff       	call   805750 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  806f4a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806f4d:	e8 e6 f1 ff ff       	call   806138 <dhcp_discover>
  806f52:	eb 58                	jmp    806fac <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  806f54:	3c 02                	cmp    $0x2,%al
  806f56:	75 54                	jne    806fac <dhcp_recv+0x45a>
  806f58:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806f5b:	80 3a 06             	cmpb   $0x6,(%edx)
  806f5e:	66 90                	xchg   %ax,%ax
  806f60:	75 4a                	jne    806fac <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  806f62:	66 c7 42 26 00 00    	movw   $0x0,0x26(%edx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806f68:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806f6b:	8b 59 20             	mov    0x20(%ecx),%ebx
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  806f6e:	ba 36 00 00 00       	mov    $0x36,%edx
  806f73:	89 d8                	mov    %ebx,%eax
  806f75:	e8 e5 e7 ff ff       	call   80575f <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  806f7a:	85 c0                	test   %eax,%eax
  806f7c:	74 2e                	je     806fac <dhcp_recv+0x45a>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806f7e:	83 c0 02             	add    $0x2,%eax
  806f81:	e8 ed e8 ff ff       	call   805873 <dhcp_get_option_long>
  806f86:	89 04 24             	mov    %eax,(%esp)
  806f89:	e8 07 3d 00 00       	call   80ac95 <htonl>
  806f8e:	89 43 2c             	mov    %eax,0x2c(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  806f91:	8b 53 10             	mov    0x10(%ebx),%edx
  806f94:	b8 00 00 00 00       	mov    $0x0,%eax
  806f99:	83 fa f0             	cmp    $0xfffffff0,%edx
  806f9c:	74 03                	je     806fa1 <dhcp_recv+0x44f>
  806f9e:	8b 42 10             	mov    0x10(%edx),%eax
  806fa1:	89 43 30             	mov    %eax,0x30(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  806fa4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806fa7:	e8 c3 f5 ff ff       	call   80656f <dhcp_select>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  806fac:	8b 5d 10             	mov    0x10(%ebp),%ebx
  806faf:	89 1c 24             	mov    %ebx,(%esp)
  806fb2:	e8 c1 0e 00 00       	call   807e78 <pbuf_free>
  dhcp->p = NULL;
  806fb7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806fba:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
  806fc1:	83 c4 2c             	add    $0x2c,%esp
  806fc4:	5b                   	pop    %ebx
  806fc5:	5e                   	pop    %esi
  806fc6:	5f                   	pop    %edi
  806fc7:	5d                   	pop    %ebp
  806fc8:	c3                   	ret    
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  806fc9:	ba 35 00 00 00       	mov    $0x35,%edx
  806fce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806fd1:	e8 89 e7 ff ff       	call   80575f <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  806fd6:	85 c0                	test   %eax,%eax
  806fd8:	0f 85 38 fd ff ff    	jne    806d16 <dhcp_recv+0x1c4>
  806fde:	66 90                	xchg   %ax,%ax
  806fe0:	eb ca                	jmp    806fac <dhcp_recv+0x45a>

00806fe2 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  806fe2:	55                   	push   %ebp
  806fe3:	89 e5                	mov    %esp,%ebp
  806fe5:	53                   	push   %ebx
  806fe6:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  806fe9:	8b 1d 04 f0 b3 00    	mov    0xb3f004,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  806fef:	85 db                	test   %ebx,%ebx
  806ff1:	0f 84 dd 00 00 00    	je     8070d4 <dhcp_fine_tmr+0xf2>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  806ff7:	8b 43 20             	mov    0x20(%ebx),%eax
  806ffa:	85 c0                	test   %eax,%eax
  806ffc:	0f 84 c8 00 00 00    	je     8070ca <dhcp_fine_tmr+0xe8>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  807002:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  807006:	66 83 fa 01          	cmp    $0x1,%dx
  80700a:	76 0c                	jbe    807018 <dhcp_fine_tmr+0x36>
        netif->dhcp->request_timeout--;
  80700c:	83 ea 01             	sub    $0x1,%edx
  80700f:	66 89 50 26          	mov    %dx,0x26(%eax)
  807013:	e9 b2 00 00 00       	jmp    8070ca <dhcp_fine_tmr+0xe8>
      }
      else if (netif->dhcp->request_timeout == 1) {
  807018:	66 83 fa 01          	cmp    $0x1,%dx
  80701c:	0f 85 a8 00 00 00    	jne    8070ca <dhcp_fine_tmr+0xe8>
        netif->dhcp->request_timeout--;
  807022:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  807028:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  80702b:	0f b6 02             	movzbl (%edx),%eax
  80702e:	3c 0c                	cmp    $0xc,%al
  807030:	74 04                	je     807036 <dhcp_fine_tmr+0x54>
  807032:	3c 06                	cmp    $0x6,%al
  807034:	75 0f                	jne    807045 <dhcp_fine_tmr+0x63>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  807036:	89 d8                	mov    %ebx,%eax
  807038:	e8 fb f0 ff ff       	call   806138 <dhcp_discover>
  80703d:	8d 76 00             	lea    0x0(%esi),%esi
  807040:	e9 85 00 00 00       	jmp    8070ca <dhcp_fine_tmr+0xe8>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  807045:	3c 01                	cmp    $0x1,%al
  807047:	75 23                	jne    80706c <dhcp_fine_tmr+0x8a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  807049:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  80704d:	8d 76 00             	lea    0x0(%esi),%esi
  807050:	77 09                	ja     80705b <dhcp_fine_tmr+0x79>
      dhcp_select(netif);
  807052:	89 d8                	mov    %ebx,%eax
  807054:	e8 16 f5 ff ff       	call   80656f <dhcp_select>
  807059:	eb 6f                	jmp    8070ca <dhcp_fine_tmr+0xe8>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  80705b:	89 1c 24             	mov    %ebx,(%esp)
  80705e:	e8 52 ee ff ff       	call   805eb5 <dhcp_release>
      dhcp_discover(netif);
  807063:	89 d8                	mov    %ebx,%eax
  807065:	e8 ce f0 ff ff       	call   806138 <dhcp_discover>
  80706a:	eb 5e                	jmp    8070ca <dhcp_fine_tmr+0xe8>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  80706c:	3c 08                	cmp    $0x8,%al
  80706e:	66 90                	xchg   %ax,%ax
  807070:	75 20                	jne    807092 <dhcp_fine_tmr+0xb0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  807072:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  807076:	66 90                	xchg   %ax,%ax
  807078:	77 0d                	ja     807087 <dhcp_fine_tmr+0xa5>
      dhcp_check(netif);
  80707a:	89 d8                	mov    %ebx,%eax
  80707c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  807080:	e8 f5 f8 ff ff       	call   80697a <dhcp_check>
  807085:	eb 43                	jmp    8070ca <dhcp_fine_tmr+0xe8>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  807087:	89 d8                	mov    %ebx,%eax
  807089:	e8 29 f9 ff ff       	call   8069b7 <dhcp_bind>
  80708e:	66 90                	xchg   %ax,%ax
  807090:	eb 38                	jmp    8070ca <dhcp_fine_tmr+0xe8>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  807092:	3c 05                	cmp    $0x5,%al
  807094:	75 11                	jne    8070a7 <dhcp_fine_tmr+0xc5>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  807096:	89 1c 24             	mov    %ebx,(%esp)
  807099:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8070a0:	e8 79 ef ff ff       	call   80601e <dhcp_renew>
  8070a5:	eb 23                	jmp    8070ca <dhcp_fine_tmr+0xe8>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  8070a7:	3c 04                	cmp    $0x4,%al
  8070a9:	75 1f                	jne    8070ca <dhcp_fine_tmr+0xe8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  8070ab:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  8070af:	90                   	nop
  8070b0:	77 09                	ja     8070bb <dhcp_fine_tmr+0xd9>
      dhcp_rebind(netif);
  8070b2:	89 d8                	mov    %ebx,%eax
  8070b4:	e8 d8 f1 ff ff       	call   806291 <dhcp_rebind>
  8070b9:	eb 0f                	jmp    8070ca <dhcp_fine_tmr+0xe8>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  8070bb:	89 1c 24             	mov    %ebx,(%esp)
  8070be:	e8 f2 ed ff ff       	call   805eb5 <dhcp_release>
      dhcp_discover(netif);
  8070c3:	89 d8                	mov    %ebx,%eax
  8070c5:	e8 6e f0 ff ff       	call   806138 <dhcp_discover>
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  8070ca:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  8070cc:	85 db                	test   %ebx,%ebx
  8070ce:	0f 85 23 ff ff ff    	jne    806ff7 <dhcp_fine_tmr+0x15>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  8070d4:	83 c4 14             	add    $0x14,%esp
  8070d7:	5b                   	pop    %ebx
  8070d8:	5d                   	pop    %ebp
  8070d9:	c3                   	ret    
  8070da:	00 00                	add    %al,(%eax)
  8070dc:	00 00                	add    %al,(%eax)
	...

008070e0 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  8070e0:	55                   	push   %ebp
  8070e1:	89 e5                	mov    %esp,%ebp
  8070e3:	83 ec 38             	sub    $0x38,%esp
  8070e6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8070e9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8070ec:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8070ef:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  8070f2:	85 c0                	test   %eax,%eax
  8070f4:	0f 84 be 01 00 00    	je     8072b8 <mem_malloc+0x1d8>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  8070fa:	83 c0 03             	add    $0x3,%eax
  8070fd:	83 e0 fc             	and    $0xfffffffc,%eax
  807100:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(size < MIN_SIZE_ALIGNED) {
  807103:	83 f8 0b             	cmp    $0xb,%eax
  807106:	77 09                	ja     807111 <mem_malloc+0x31>
  807108:	c7 45 e4 0c 00 00 00 	movl   $0xc,-0x1c(%ebp)
  80710f:	eb 0d                	jmp    80711e <mem_malloc+0x3e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  807111:	81 7d e4 00 00 22 00 	cmpl   $0x220000,-0x1c(%ebp)
  807118:	0f 87 9a 01 00 00    	ja     8072b8 <mem_malloc+0x1d8>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80711e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807125:	00 
  807126:	a1 68 63 a3 00       	mov    0xa36368,%eax
  80712b:	89 04 24             	mov    %eax,(%esp)
  80712e:	e8 33 67 00 00       	call   80d866 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  807133:	a1 64 63 a3 00       	mov    0xa36364,%eax
  807138:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80713b:	8b 15 5c 63 a3 00    	mov    0xa3635c,%edx
  807141:	29 d0                	sub    %edx,%eax
  807143:	b9 00 00 22 00       	mov    $0x220000,%ecx
  807148:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
  80714b:	39 c8                	cmp    %ecx,%eax
  80714d:	0f 83 51 01 00 00    	jae    8072a4 <mem_malloc+0x1c4>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  807153:	89 55 e0             	mov    %edx,-0x20(%ebp)
  807156:	8b 75 e0             	mov    -0x20(%ebp),%esi
  807159:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80715c:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  807160:	0f 85 34 01 00 00    	jne    80729a <mem_malloc+0x1ba>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  807166:	8b 3b                	mov    (%ebx),%edi
  807168:	83 ef 0c             	sub    $0xc,%edi
  80716b:	29 c7                	sub    %eax,%edi
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80716d:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  807170:	0f 87 24 01 00 00    	ja     80729a <mem_malloc+0x1ba>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  807176:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807179:	83 c2 18             	add    $0x18,%edx
  80717c:	39 d7                	cmp    %edx,%edi
  80717e:	72 2a                	jb     8071aa <mem_malloc+0xca>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  807180:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807183:	8d 4c 02 0c          	lea    0xc(%edx,%eax,1),%ecx
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  807187:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  80718a:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  80718e:	8b 3b                	mov    (%ebx),%edi
  807190:	89 3a                	mov    %edi,(%edx)
          mem2->prev = ptr;
  807192:	89 42 04             	mov    %eax,0x4(%edx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  807195:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  807197:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  80719b:	8b 02                	mov    (%edx),%eax
  80719d:	3d 00 00 22 00       	cmp    $0x220000,%eax
  8071a2:	74 0a                	je     8071ae <mem_malloc+0xce>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8071a4:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  8071a8:	eb 04                	jmp    8071ae <mem_malloc+0xce>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  8071aa:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  8071ae:	39 5d dc             	cmp    %ebx,-0x24(%ebp)
  8071b1:	75 67                	jne    80721a <mem_malloc+0x13a>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8071b3:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  8071b6:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
  8071ba:	84 c0                	test   %al,%al
  8071bc:	74 31                	je     8071ef <mem_malloc+0x10f>
  8071be:	8b 15 60 63 a3 00    	mov    0xa36360,%edx
  8071c4:	39 d1                	cmp    %edx,%ecx
  8071c6:	74 52                	je     80721a <mem_malloc+0x13a>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  8071c8:	8b 01                	mov    (%ecx),%eax
  8071ca:	8d 0c 06             	lea    (%esi,%eax,1),%ecx
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8071cd:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
  8071d1:	84 c0                	test   %al,%al
  8071d3:	75 0b                	jne    8071e0 <mem_malloc+0x100>
  8071d5:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  8071d8:	89 0d 64 63 a3 00    	mov    %ecx,0xa36364
  8071de:	eb 0f                	jmp    8071ef <mem_malloc+0x10f>
  8071e0:	39 d1                	cmp    %edx,%ecx
  8071e2:	75 e4                	jne    8071c8 <mem_malloc+0xe8>
  8071e4:	89 4d dc             	mov    %ecx,-0x24(%ebp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
  8071e7:	89 0d 64 63 a3 00    	mov    %ecx,0xa36364
  8071ed:	eb 2b                	jmp    80721a <mem_malloc+0x13a>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  8071ef:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8071f2:	3b 15 60 63 a3 00    	cmp    0xa36360,%edx
  8071f8:	74 20                	je     80721a <mem_malloc+0x13a>
  8071fa:	84 c0                	test   %al,%al
  8071fc:	74 1c                	je     80721a <mem_malloc+0x13a>
  8071fe:	c7 44 24 08 d5 32 81 	movl   $0x8132d5,0x8(%esp)
  807205:	00 
  807206:	c7 44 24 04 46 02 00 	movl   $0x246,0x4(%esp)
  80720d:	00 
  80720e:	c7 04 24 ee 32 81 00 	movl   $0x8132ee,(%esp)
  807215:	e8 ce 97 ff ff       	call   8009e8 <_panic>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80721a:	a1 68 63 a3 00       	mov    0xa36368,%eax
  80721f:	89 04 24             	mov    %eax,(%esp)
  807222:	e8 30 69 00 00       	call   80db57 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  807227:	89 d8                	mov    %ebx,%eax
  807229:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80722c:	8d 54 0b 0c          	lea    0xc(%ebx,%ecx,1),%edx
  807230:	39 15 60 63 a3 00    	cmp    %edx,0xa36360
  807236:	73 1c                	jae    807254 <mem_malloc+0x174>
  807238:	c7 44 24 08 78 33 81 	movl   $0x813378,0x8(%esp)
  80723f:	00 
  807240:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  807247:	00 
  807248:	c7 04 24 ee 32 81 00 	movl   $0x8132ee,(%esp)
  80724f:	e8 94 97 ff ff       	call   8009e8 <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  807254:	f6 c3 03             	test   $0x3,%bl
  807257:	74 1c                	je     807275 <mem_malloc+0x195>
  807259:	c7 44 24 08 a8 33 81 	movl   $0x8133a8,0x8(%esp)
  807260:	00 
  807261:	c7 44 24 04 4d 02 00 	movl   $0x24d,0x4(%esp)
  807268:	00 
  807269:	c7 04 24 ee 32 81 00 	movl   $0x8132ee,(%esp)
  807270:	e8 73 97 ff ff       	call   8009e8 <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  807275:	a8 03                	test   $0x3,%al
  807277:	74 1c                	je     807295 <mem_malloc+0x1b5>
  807279:	c7 44 24 08 d8 33 81 	movl   $0x8133d8,0x8(%esp)
  807280:	00 
  807281:	c7 44 24 04 4f 02 00 	movl   $0x24f,0x4(%esp)
  807288:	00 
  807289:	c7 04 24 ee 32 81 00 	movl   $0x8132ee,(%esp)
  807290:	e8 53 97 ff ff       	call   8009e8 <_panic>
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  807295:	8d 43 0c             	lea    0xc(%ebx),%eax
  807298:	eb 23                	jmp    8072bd <mem_malloc+0x1dd>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  80729a:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80729c:	39 c1                	cmp    %eax,%ecx
  80729e:	0f 87 b2 fe ff ff    	ja     807156 <mem_malloc+0x76>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  8072a4:	a1 68 63 a3 00       	mov    0xa36368,%eax
  8072a9:	89 04 24             	mov    %eax,(%esp)
  8072ac:	e8 a6 68 00 00       	call   80db57 <sys_sem_signal>
  8072b1:	b8 00 00 00 00       	mov    $0x0,%eax
  return NULL;
  8072b6:	eb 05                	jmp    8072bd <mem_malloc+0x1dd>
  8072b8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8072bd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8072c0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8072c3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8072c6:	89 ec                	mov    %ebp,%esp
  8072c8:	5d                   	pop    %ebp
  8072c9:	c3                   	ret    

008072ca <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8072ca:	55                   	push   %ebp
  8072cb:	89 e5                	mov    %esp,%ebp
  8072cd:	83 ec 18             	sub    $0x18,%esp
  8072d0:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8072d3:	89 75 fc             	mov    %esi,-0x4(%ebp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8072d6:	8b 75 0c             	mov    0xc(%ebp),%esi
  8072d9:	0f af 75 08          	imul   0x8(%ebp),%esi
  8072dd:	89 34 24             	mov    %esi,(%esp)
  8072e0:	e8 fb fd ff ff       	call   8070e0 <mem_malloc>
  8072e5:	89 c3                	mov    %eax,%ebx
  if (p) {
  8072e7:	85 c0                	test   %eax,%eax
  8072e9:	74 14                	je     8072ff <mem_calloc+0x35>
    /* zero the memory */
    memset(p, 0, count * size);
  8072eb:	89 74 24 08          	mov    %esi,0x8(%esp)
  8072ef:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8072f6:	00 
  8072f7:	89 04 24             	mov    %eax,(%esp)
  8072fa:	e8 57 a2 ff ff       	call   801556 <memset>
  }
  return p;
}
  8072ff:	89 d8                	mov    %ebx,%eax
  807301:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  807304:	8b 75 fc             	mov    -0x4(%ebp),%esi
  807307:	89 ec                	mov    %ebp,%esp
  807309:	5d                   	pop    %ebp
  80730a:	c3                   	ret    

0080730b <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80730b:	55                   	push   %ebp
  80730c:	89 e5                	mov    %esp,%ebp
  80730e:	83 ec 38             	sub    $0x38,%esp
  807311:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  807314:	89 75 f8             	mov    %esi,-0x8(%ebp)
  807317:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80731a:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80731d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  807320:	83 c3 03             	add    $0x3,%ebx
  807323:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  807326:	83 fb 0b             	cmp    $0xb,%ebx
  807329:	77 07                	ja     807332 <mem_realloc+0x27>
  80732b:	bb 0c 00 00 00       	mov    $0xc,%ebx
  807330:	eb 13                	jmp    807345 <mem_realloc+0x3a>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  807332:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  807338:	76 0b                	jbe    807345 <mem_realloc+0x3a>
  80733a:	be 00 00 00 00       	mov    $0x0,%esi
  80733f:	90                   	nop
  807340:	e9 1a 01 00 00       	jmp    80745f <mem_realloc+0x154>
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  807345:	a1 5c 63 a3 00       	mov    0xa3635c,%eax
  80734a:	39 c6                	cmp    %eax,%esi
  80734c:	72 08                	jb     807356 <mem_realloc+0x4b>
  80734e:	3b 35 60 63 a3 00    	cmp    0xa36360,%esi
  807354:	72 1c                	jb     807372 <mem_realloc+0x67>
  807356:	c7 44 24 08 02 33 81 	movl   $0x813302,0x8(%esp)
  80735d:	00 
  80735e:	c7 44 24 04 79 01 00 	movl   $0x179,0x4(%esp)
  807365:	00 
  807366:	c7 04 24 ee 32 81 00 	movl   $0x8132ee,(%esp)
  80736d:	e8 76 96 ff ff       	call   8009e8 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  807372:	8d 7e f4             	lea    -0xc(%esi),%edi
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  807375:	89 fa                	mov    %edi,%edx
  807377:	29 c2                	sub    %eax,%edx
  807379:	89 55 e0             	mov    %edx,-0x20(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80737c:	8b 07                	mov    (%edi),%eax
  80737e:	83 e8 0c             	sub    $0xc,%eax
  807381:	29 d0                	sub    %edx,%eax
  807383:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  807386:	39 d8                	cmp    %ebx,%eax
  807388:	73 1c                	jae    8073a6 <mem_realloc+0x9b>
  80738a:	c7 44 24 08 fc 33 81 	movl   $0x8133fc,0x8(%esp)
  807391:	00 
  807392:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  807399:	00 
  80739a:	c7 04 24 ee 32 81 00 	movl   $0x8132ee,(%esp)
  8073a1:	e8 42 96 ff ff       	call   8009e8 <_panic>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  8073a6:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
  8073a9:	0f 84 b0 00 00 00    	je     80745f <mem_realloc+0x154>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8073af:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8073b6:	00 
  8073b7:	a1 68 63 a3 00       	mov    0xa36368,%eax
  8073bc:	89 04 24             	mov    %eax,(%esp)
  8073bf:	e8 a2 64 00 00       	call   80d866 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  8073c4:	a1 5c 63 a3 00       	mov    0xa3635c,%eax
  8073c9:	89 c2                	mov    %eax,%edx
  8073cb:	03 17                	add    (%edi),%edx
  if(mem2->used == 0) {
  8073cd:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8073d1:	75 41                	jne    807414 <mem_realloc+0x109>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  8073d3:	8b 0a                	mov    (%edx),%ecx
  8073d5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8073d8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8073db:	8d 5c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ebx
    if (lfree == mem2) {
  8073df:	39 15 64 63 a3 00    	cmp    %edx,0xa36364
  8073e5:	75 09                	jne    8073f0 <mem_realloc+0xe5>
      lfree = (struct mem *)&ram[ptr2];
  8073e7:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  8073ea:	89 15 64 63 a3 00    	mov    %edx,0xa36364
    }
    mem2 = (struct mem *)&ram[ptr2];
  8073f0:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  8073f3:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  8073f7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8073fa:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  8073fc:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8073ff:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  807402:	89 1f                	mov    %ebx,(%edi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  807404:	8b 12                	mov    (%edx),%edx
  807406:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80740c:	74 44                	je     807452 <mem_realloc+0x147>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80740e:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
  807412:	eb 3e                	jmp    807452 <mem_realloc+0x147>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  807414:	8d 53 18             	lea    0x18(%ebx),%edx
  807417:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80741a:	72 36                	jb     807452 <mem_realloc+0x147>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80741c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80741f:	8d 4c 13 0c          	lea    0xc(%ebx,%edx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  807423:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  807426:	3b 15 64 63 a3 00    	cmp    0xa36364,%edx
  80742c:	73 06                	jae    807434 <mem_realloc+0x129>
      lfree = mem2;
  80742e:	89 15 64 63 a3 00    	mov    %edx,0xa36364
    }
    mem2->used = 0;
  807434:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  807438:	8b 1f                	mov    (%edi),%ebx
  80743a:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  80743c:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80743f:	89 5a 04             	mov    %ebx,0x4(%edx)
    mem->next = ptr2;
  807442:	89 0f                	mov    %ecx,(%edi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  807444:	8b 12                	mov    (%edx),%edx
  807446:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80744c:	74 04                	je     807452 <mem_realloc+0x147>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80744e:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  807452:	a1 68 63 a3 00       	mov    0xa36368,%eax
  807457:	89 04 24             	mov    %eax,(%esp)
  80745a:	e8 f8 66 00 00       	call   80db57 <sys_sem_signal>
  return rmem;
}
  80745f:	89 f0                	mov    %esi,%eax
  807461:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  807464:	8b 75 f8             	mov    -0x8(%ebp),%esi
  807467:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80746a:	89 ec                	mov    %ebp,%esp
  80746c:	5d                   	pop    %ebp
  80746d:	c3                   	ret    

0080746e <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  80746e:	55                   	push   %ebp
  80746f:	89 e5                	mov    %esp,%ebp
  807471:	83 ec 18             	sub    $0x18,%esp
  807474:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  807477:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80747a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  80747d:	85 db                	test   %ebx,%ebx
  80747f:	0f 84 6f 01 00 00    	je     8075f4 <mem_free+0x186>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  807485:	f6 c3 03             	test   $0x3,%bl
  807488:	74 1c                	je     8074a6 <mem_free+0x38>
  80748a:	c7 44 24 08 20 34 81 	movl   $0x813420,0x8(%esp)
  807491:	00 
  807492:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  807499:	00 
  80749a:	c7 04 24 ee 32 81 00 	movl   $0x8132ee,(%esp)
  8074a1:	e8 42 95 ff ff       	call   8009e8 <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8074a6:	3b 1d 5c 63 a3 00    	cmp    0xa3635c,%ebx
  8074ac:	72 08                	jb     8074b6 <mem_free+0x48>
  8074ae:	3b 1d 60 63 a3 00    	cmp    0xa36360,%ebx
  8074b4:	72 1c                	jb     8074d2 <mem_free+0x64>
  8074b6:	c7 44 24 08 1c 33 81 	movl   $0x81331c,0x8(%esp)
  8074bd:	00 
  8074be:	c7 44 24 04 33 01 00 	movl   $0x133,0x4(%esp)
  8074c5:	00 
  8074c6:	c7 04 24 ee 32 81 00 	movl   $0x8132ee,(%esp)
  8074cd:	e8 16 95 ff ff       	call   8009e8 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8074d2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8074d9:	00 
  8074da:	a1 68 63 a3 00       	mov    0xa36368,%eax
  8074df:	89 04 24             	mov    %eax,(%esp)
  8074e2:	e8 7f 63 00 00       	call   80d866 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8074e7:	83 eb 0c             	sub    $0xc,%ebx
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  8074ea:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  8074ee:	75 1c                	jne    80750c <mem_free+0x9e>
  8074f0:	c7 44 24 08 33 33 81 	movl   $0x813333,0x8(%esp)
  8074f7:	00 
  8074f8:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  8074ff:	00 
  807500:	c7 04 24 ee 32 81 00 	movl   $0x8132ee,(%esp)
  807507:	e8 dc 94 ff ff       	call   8009e8 <_panic>
  /* ... and is now unused. */
  mem->used = 0;
  80750c:	c6 43 08 00          	movb   $0x0,0x8(%ebx)

  if (mem < lfree) {
  807510:	3b 1d 64 63 a3 00    	cmp    0xa36364,%ebx
  807516:	73 06                	jae    80751e <mem_free+0xb0>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  807518:	89 1d 64 63 a3 00    	mov    %ebx,0xa36364
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80751e:	a1 5c 63 a3 00       	mov    0xa3635c,%eax
  807523:	39 c3                	cmp    %eax,%ebx
  807525:	73 1c                	jae    807543 <mem_free+0xd5>
  807527:	c7 44 24 08 47 33 81 	movl   $0x813347,0x8(%esp)
  80752e:	00 
  80752f:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  807536:	00 
  807537:	c7 04 24 ee 32 81 00 	movl   $0x8132ee,(%esp)
  80753e:	e8 a5 94 ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  807543:	8b 35 60 63 a3 00    	mov    0xa36360,%esi
  807549:	39 f3                	cmp    %esi,%ebx
  80754b:	72 1c                	jb     807569 <mem_free+0xfb>
  80754d:	c7 44 24 08 5e 33 81 	movl   $0x81335e,0x8(%esp)
  807554:	00 
  807555:	c7 44 24 04 e4 00 00 	movl   $0xe4,0x4(%esp)
  80755c:	00 
  80755d:	c7 04 24 ee 32 81 00 	movl   $0x8132ee,(%esp)
  807564:	e8 7f 94 ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  807569:	8b 13                	mov    (%ebx),%edx
  80756b:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  807571:	76 1c                	jbe    80758f <mem_free+0x121>
  807573:	c7 44 24 08 44 34 81 	movl   $0x813444,0x8(%esp)
  80757a:	00 
  80757b:	c7 44 24 04 e8 00 00 	movl   $0xe8,0x4(%esp)
  807582:	00 
  807583:	c7 04 24 ee 32 81 00 	movl   $0x8132ee,(%esp)
  80758a:	e8 59 94 ff ff       	call   8009e8 <_panic>

  nmem = (struct mem *)&ram[mem->next];
  80758f:	89 c1                	mov    %eax,%ecx
  807591:	8d 14 10             	lea    (%eax,%edx,1),%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  807594:	39 d3                	cmp    %edx,%ebx
  807596:	74 26                	je     8075be <mem_free+0x150>
  807598:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  80759c:	75 20                	jne    8075be <mem_free+0x150>
  80759e:	39 d6                	cmp    %edx,%esi
  8075a0:	74 1c                	je     8075be <mem_free+0x150>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  8075a2:	3b 15 64 63 a3 00    	cmp    0xa36364,%edx
  8075a8:	75 06                	jne    8075b0 <mem_free+0x142>
      lfree = mem;
  8075aa:	89 1d 64 63 a3 00    	mov    %ebx,0xa36364
    }
    mem->next = nmem->next;
  8075b0:	8b 32                	mov    (%edx),%esi
  8075b2:	89 33                	mov    %esi,(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  8075b4:	8b 12                	mov    (%edx),%edx
  8075b6:	89 de                	mov    %ebx,%esi
  8075b8:	29 c6                	sub    %eax,%esi
  8075ba:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  8075be:	89 ca                	mov    %ecx,%edx
  8075c0:	03 53 04             	add    0x4(%ebx),%edx
  if (pmem != mem && pmem->used == 0) {
  8075c3:	39 d3                	cmp    %edx,%ebx
  8075c5:	74 20                	je     8075e7 <mem_free+0x179>
  8075c7:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8075cb:	75 1a                	jne    8075e7 <mem_free+0x179>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  8075cd:	3b 1d 64 63 a3 00    	cmp    0xa36364,%ebx
  8075d3:	75 06                	jne    8075db <mem_free+0x16d>
      lfree = pmem;
  8075d5:	89 15 64 63 a3 00    	mov    %edx,0xa36364
    }
    pmem->next = mem->next;
  8075db:	8b 33                	mov    (%ebx),%esi
  8075dd:	89 32                	mov    %esi,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8075df:	8b 1b                	mov    (%ebx),%ebx
  8075e1:	29 c2                	sub    %eax,%edx
  8075e3:	89 54 19 04          	mov    %edx,0x4(%ecx,%ebx,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8075e7:	a1 68 63 a3 00       	mov    0xa36368,%eax
  8075ec:	89 04 24             	mov    %eax,(%esp)
  8075ef:	e8 63 65 00 00       	call   80db57 <sys_sem_signal>
}
  8075f4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8075f7:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8075fa:	89 ec                	mov    %ebp,%esp
  8075fc:	5d                   	pop    %ebp
  8075fd:	c3                   	ret    

008075fe <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  8075fe:	55                   	push   %ebp
  8075ff:	89 e5                	mov    %esp,%ebp
  807601:	83 ec 18             	sub    $0x18,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  807604:	b8 43 63 81 00       	mov    $0x816343,%eax
  807609:	83 e0 fc             	and    $0xfffffffc,%eax
  80760c:	a3 5c 63 a3 00       	mov    %eax,0xa3635c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  807611:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  807617:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  80761e:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  807622:	05 00 00 22 00       	add    $0x220000,%eax
  807627:	a3 60 63 a3 00       	mov    %eax,0xa36360
  ram_end->used = 1;
  80762c:	c6 40 08 01          	movb   $0x1,0x8(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  807630:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  807636:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%eax)

  mem_sem = sys_sem_new(1);
  80763d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  807644:	e8 6c 63 00 00       	call   80d9b5 <sys_sem_new>
  807649:	a3 68 63 a3 00       	mov    %eax,0xa36368

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  80764e:	a1 5c 63 a3 00       	mov    0xa3635c,%eax
  807653:	a3 64 63 a3 00       	mov    %eax,0xa36364

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  807658:	c9                   	leave  
  807659:	c3                   	ret    
	...

0080765c <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80765c:	55                   	push   %ebp
  80765d:	89 e5                	mov    %esp,%ebp
  80765f:	57                   	push   %edi
  807660:	56                   	push   %esi
  807661:	53                   	push   %ebx
  807662:	83 ec 04             	sub    $0x4,%esp
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  807665:	b8 c3 63 a3 00       	mov    $0xa363c3,%eax
  80766a:	83 e0 fc             	and    $0xfffffffc,%eax
  80766d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  807670:	bf 00 00 00 00       	mov    $0x0,%edi
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  807675:	c7 84 3f 80 63 a3 00 	movl   $0x0,0xa36380(%edi,%edi,1)
  80767c:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  807680:	0f b7 9f 02 35 81 00 	movzwl 0x813502(%edi),%ebx
  807687:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80768a:	66 85 db             	test   %bx,%bx
  80768d:	74 3c                	je     8076cb <memp_init+0x6f>
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80768f:	0f b7 b7 e6 34 81 00 	movzwl 0x8134e6(%edi),%esi
  807696:	b9 00 00 00 00       	mov    $0x0,%ecx
  80769b:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
  8076a0:	89 08                	mov    %ecx,(%eax)
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  8076a2:	83 c2 01             	add    $0x1,%edx
  8076a5:	89 c1                	mov    %eax,%ecx
  8076a7:	8d 04 30             	lea    (%eax,%esi,1),%eax
  8076aa:	66 39 da             	cmp    %bx,%dx
  8076ad:	72 f1                	jb     8076a0 <memp_init+0x44>
 * Initialize this module.
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
  8076af:	83 eb 01             	sub    $0x1,%ebx
  8076b2:	0f b7 db             	movzwl %bx,%ebx
  8076b5:	8d 43 01             	lea    0x1(%ebx),%eax
  8076b8:	0f af c6             	imul   %esi,%eax
  8076bb:	03 45 f0             	add    -0x10(%ebp),%eax
  8076be:	0f af de             	imul   %esi,%ebx
  8076c1:	03 5d f0             	add    -0x10(%ebp),%ebx
  8076c4:	89 9c 3f 80 63 a3 00 	mov    %ebx,0xa36380(%edi,%edi,1)
  8076cb:	83 c7 02             	add    $0x2,%edi
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  8076ce:	83 ff 1c             	cmp    $0x1c,%edi
  8076d1:	74 05                	je     8076d8 <memp_init+0x7c>
  8076d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  8076d6:	eb 9d                	jmp    807675 <memp_init+0x19>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  8076d8:	83 c4 04             	add    $0x4,%esp
  8076db:	5b                   	pop    %ebx
  8076dc:	5e                   	pop    %esi
  8076dd:	5f                   	pop    %edi
  8076de:	5d                   	pop    %ebp
  8076df:	c3                   	ret    

008076e0 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8076e0:	55                   	push   %ebp
  8076e1:	89 e5                	mov    %esp,%ebp
  8076e3:	53                   	push   %ebx
  8076e4:	83 ec 14             	sub    $0x14,%esp
  8076e7:	8b 55 08             	mov    0x8(%ebp),%edx
  8076ea:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8076ed:	85 c0                	test   %eax,%eax
  8076ef:	74 2d                	je     80771e <memp_free+0x3e>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8076f1:	a8 03                	test   $0x3,%al
  8076f3:	74 1c                	je     807711 <memp_free+0x31>
  8076f5:	c7 44 24 08 70 34 81 	movl   $0x813470,0x8(%esp)
  8076fc:	00 
  8076fd:	c7 44 24 04 5b 01 00 	movl   $0x15b,0x4(%esp)
  807704:	00 
  807705:	c7 04 24 b3 34 81 00 	movl   $0x8134b3,(%esp)
  80770c:	e8 d7 92 ff ff       	call   8009e8 <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  807711:	b9 80 63 a3 00       	mov    $0xa36380,%ecx
  807716:	8b 1c 91             	mov    (%ecx,%edx,4),%ebx
  807719:	89 18                	mov    %ebx,(%eax)
  memp_tab[type] = memp;
  80771b:	89 04 91             	mov    %eax,(%ecx,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  80771e:	83 c4 14             	add    $0x14,%esp
  807721:	5b                   	pop    %ebx
  807722:	5d                   	pop    %ebp
  807723:	c3                   	ret    

00807724 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  807724:	55                   	push   %ebp
  807725:	89 e5                	mov    %esp,%ebp
  807727:	83 ec 18             	sub    $0x18,%esp
  80772a:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80772d:	83 fa 0d             	cmp    $0xd,%edx
  807730:	76 1c                	jbe    80774e <memp_malloc+0x2a>
  807732:	c7 44 24 08 c8 34 81 	movl   $0x8134c8,0x8(%esp)
  807739:	00 
  80773a:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  807741:	00 
  807742:	c7 04 24 b3 34 81 00 	movl   $0x8134b3,(%esp)
  807749:	e8 9a 92 ff ff       	call   8009e8 <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80774e:	8b 04 95 80 63 a3 00 	mov    0xa36380(,%edx,4),%eax
  
  if (memp != NULL) {    
  807755:	85 c0                	test   %eax,%eax
  807757:	74 29                	je     807782 <memp_malloc+0x5e>
    memp_tab[type] = memp->next;    
  807759:	8b 08                	mov    (%eax),%ecx
  80775b:	89 0c 95 80 63 a3 00 	mov    %ecx,0xa36380(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  807762:	a8 03                	test   $0x3,%al
  807764:	74 1c                	je     807782 <memp_malloc+0x5e>
  807766:	c7 44 24 08 90 34 81 	movl   $0x813490,0x8(%esp)
  80776d:	00 
  80776e:	c7 44 24 04 3f 01 00 	movl   $0x13f,0x4(%esp)
  807775:	00 
  807776:	c7 04 24 b3 34 81 00 	movl   $0x8134b3,(%esp)
  80777d:	e8 66 92 ff ff       	call   8009e8 <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  807782:	c9                   	leave  
  807783:	c3                   	ret    
	...

00807790 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  807790:	55                   	push   %ebp
  807791:	89 e5                	mov    %esp,%ebp
  807793:	53                   	push   %ebx
  807794:	8b 55 08             	mov    0x8(%ebp),%edx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  807797:	b8 00 00 00 00       	mov    $0x0,%eax
  80779c:	85 d2                	test   %edx,%edx
  80779e:	74 2c                	je     8077cc <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';
  8077a0:	0f b6 5a 02          	movzbl 0x2(%edx),%ebx
  8077a4:	83 eb 30             	sub    $0x30,%ebx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8077a7:	a1 04 f0 b3 00       	mov    0xb3f004,%eax
  8077ac:	85 c0                	test   %eax,%eax
  8077ae:	74 1c                	je     8077cc <netif_find+0x3c>
    if (num == netif->num &&
  8077b0:	38 58 31             	cmp    %bl,0x31(%eax)
  8077b3:	75 11                	jne    8077c6 <netif_find+0x36>
       name[0] == netif->name[0] &&
  8077b5:	0f b6 0a             	movzbl (%edx),%ecx
  8077b8:	3a 48 2f             	cmp    0x2f(%eax),%cl
  8077bb:	75 09                	jne    8077c6 <netif_find+0x36>
       name[1] == netif->name[1]) {
  8077bd:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
  8077c1:	3a 48 30             	cmp    0x30(%eax),%cl
  8077c4:	74 06                	je     8077cc <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8077c6:	8b 00                	mov    (%eax),%eax
  8077c8:	85 c0                	test   %eax,%eax
  8077ca:	75 e4                	jne    8077b0 <netif_find+0x20>
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  8077cc:	5b                   	pop    %ebx
  8077cd:	5d                   	pop    %ebp
  8077ce:	c3                   	ret    

008077cf <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  8077cf:	55                   	push   %ebp
  8077d0:	89 e5                	mov    %esp,%ebp
  8077d2:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  8077d5:	b8 00 00 00 00       	mov    $0x0,%eax
  8077da:	85 d2                	test   %edx,%edx
  8077dc:	74 02                	je     8077e0 <netif_set_gw+0x11>
  8077de:	8b 02                	mov    (%edx),%eax
  8077e0:	8b 55 08             	mov    0x8(%ebp),%edx
  8077e3:	89 42 0c             	mov    %eax,0xc(%edx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  8077e6:	5d                   	pop    %ebp
  8077e7:	c3                   	ret    

008077e8 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  8077e8:	55                   	push   %ebp
  8077e9:	89 e5                	mov    %esp,%ebp
  8077eb:	8b 55 0c             	mov    0xc(%ebp),%edx
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  8077ee:	b8 00 00 00 00       	mov    $0x0,%eax
  8077f3:	85 d2                	test   %edx,%edx
  8077f5:	74 02                	je     8077f9 <netif_set_netmask+0x11>
  8077f7:	8b 02                	mov    (%edx),%eax
  8077f9:	8b 55 08             	mov    0x8(%ebp),%edx
  8077fc:	89 42 08             	mov    %eax,0x8(%edx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  8077ff:	5d                   	pop    %ebp
  807800:	c3                   	ret    

00807801 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  807801:	55                   	push   %ebp
  807802:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  807804:	8b 45 08             	mov    0x8(%ebp),%eax
  807807:	a3 08 f0 b3 00       	mov    %eax,0xb3f008
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80780c:	5d                   	pop    %ebp
  80780d:	c3                   	ret    

0080780e <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  80780e:	55                   	push   %ebp
  80780f:	89 e5                	mov    %esp,%ebp
  807811:	83 ec 04             	sub    $0x4,%esp
  807814:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  807817:	85 c9                	test   %ecx,%ecx
  807819:	74 4b                	je     807866 <netif_remove+0x58>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  80781b:	a1 04 f0 b3 00       	mov    0xb3f004,%eax
  807820:	39 c8                	cmp    %ecx,%eax
  807822:	75 1e                	jne    807842 <netif_remove+0x34>
    netif_list = netif->next;
  807824:	8b 00                	mov    (%eax),%eax
  807826:	a3 04 f0 b3 00       	mov    %eax,0xb3f004
  80782b:	eb 25                	jmp    807852 <netif_remove+0x44>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  80782d:	8b 10                	mov    (%eax),%edx
  80782f:	39 ca                	cmp    %ecx,%edx
  807831:	74 08                	je     80783b <netif_remove+0x2d>
  807833:	89 d0                	mov    %edx,%eax
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  807835:	85 c0                	test   %eax,%eax
  807837:	75 f4                	jne    80782d <netif_remove+0x1f>
  807839:	eb 2b                	jmp    807866 <netif_remove+0x58>
      if (tmpNetif->next == netif) {
        tmpNetif->next = netif->next;
  80783b:	8b 11                	mov    (%ecx),%edx
  80783d:	89 10                	mov    %edx,(%eax)
  80783f:	90                   	nop
  807840:	eb 10                	jmp    807852 <netif_remove+0x44>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  807842:	85 c0                	test   %eax,%eax
  807844:	74 20                	je     807866 <netif_remove+0x58>
      if (tmpNetif->next == netif) {
  807846:	8b 10                	mov    (%eax),%edx
  807848:	39 ca                	cmp    %ecx,%edx
  80784a:	74 ef                	je     80783b <netif_remove+0x2d>
  80784c:	89 d0                	mov    %edx,%eax
  80784e:	66 90                	xchg   %ax,%ax
  807850:	eb e3                	jmp    807835 <netif_remove+0x27>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  807852:	39 0d 08 f0 b3 00    	cmp    %ecx,0xb3f008
  807858:	75 0c                	jne    807866 <netif_remove+0x58>
    /* reset default netif */
    netif_set_default(NULL);
  80785a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  807861:	e8 9b ff ff ff       	call   807801 <netif_set_default>
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  807866:	c9                   	leave  
  807867:	c3                   	ret    

00807868 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  807868:	55                   	push   %ebp
  807869:	89 e5                	mov    %esp,%ebp
  80786b:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( netif->flags & NETIF_FLAG_UP )
  80786e:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  807872:	f6 c2 01             	test   $0x1,%dl
  807875:	74 06                	je     80787d <netif_set_down+0x15>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  807877:	83 e2 fe             	and    $0xfffffffe,%edx
  80787a:	88 50 2e             	mov    %dl,0x2e(%eax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80787d:	5d                   	pop    %ebp
  80787e:	c3                   	ret    

0080787f <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80787f:	55                   	push   %ebp
  807880:	89 e5                	mov    %esp,%ebp
  807882:	8b 45 08             	mov    0x8(%ebp),%eax
  807885:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  807889:	83 e0 01             	and    $0x1,%eax
  return (netif->flags & NETIF_FLAG_UP)?1:0;
}
  80788c:	5d                   	pop    %ebp
  80788d:	c3                   	ret    

0080788e <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  80788e:	55                   	push   %ebp
  80788f:	89 e5                	mov    %esp,%ebp
  807891:	83 ec 18             	sub    $0x18,%esp
  807894:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  807897:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  80789b:	f6 c2 01             	test   $0x1,%dl
  80789e:	75 22                	jne    8078c2 <netif_set_up+0x34>
    netif->flags |= NETIF_FLAG_UP;
  8078a0:	83 ca 01             	or     $0x1,%edx
  8078a3:	88 50 2e             	mov    %dl,0x2e(%eax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  8078a6:	f6 c2 20             	test   $0x20,%dl
  8078a9:	74 17                	je     8078c2 <netif_set_up+0x34>
      etharp_query(netif, &(netif->ip_addr), NULL);
  8078ab:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8078b2:	00 
  8078b3:	8d 50 04             	lea    0x4(%eax),%edx
  8078b6:	89 54 24 04          	mov    %edx,0x4(%esp)
  8078ba:	89 04 24             	mov    %eax,(%esp)
  8078bd:	e8 75 53 00 00       	call   80cc37 <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
  8078c2:	c9                   	leave  
  8078c3:	c3                   	ret    

008078c4 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  8078c4:	55                   	push   %ebp
  8078c5:	89 e5                	mov    %esp,%ebp
  8078c7:	57                   	push   %edi
  8078c8:	56                   	push   %esi
  8078c9:	53                   	push   %ebx
  8078ca:	83 ec 1c             	sub    $0x1c,%esp
  8078cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8078d0:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  8078d3:	8b 06                	mov    (%esi),%eax
  8078d5:	3b 43 04             	cmp    0x4(%ebx),%eax
  8078d8:	74 54                	je     80792e <netif_set_ipaddr+0x6a>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  8078da:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
    while (pcb != NULL) {
  8078df:	85 c0                	test   %eax,%eax
  8078e1:	74 1d                	je     807900 <netif_set_ipaddr+0x3c>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8078e3:	8b 10                	mov    (%eax),%edx
  8078e5:	3b 53 04             	cmp    0x4(%ebx),%edx
  8078e8:	75 0f                	jne    8078f9 <netif_set_ipaddr+0x35>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  8078ea:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  8078ed:	89 04 24             	mov    %eax,(%esp)
  8078f0:	e8 a9 16 00 00       	call   808f9e <tcp_abort>
  8078f5:	89 f8                	mov    %edi,%eax
  8078f7:	eb 03                	jmp    8078fc <netif_set_ipaddr+0x38>
        pcb = next;
      } else {
        pcb = pcb->next;
  8078f9:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  8078fc:	85 c0                	test   %eax,%eax
  8078fe:	75 e3                	jne    8078e3 <netif_set_ipaddr+0x1f>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  807900:	a1 14 f0 b3 00       	mov    0xb3f014,%eax
  807905:	85 c0                	test   %eax,%eax
  807907:	74 25                	je     80792e <netif_set_ipaddr+0x6a>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  807909:	b9 00 00 00 00       	mov    $0x0,%ecx
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80790e:	85 c0                	test   %eax,%eax
  807910:	74 15                	je     807927 <netif_set_ipaddr+0x63>
  807912:	8b 10                	mov    (%eax),%edx
  807914:	85 d2                	test   %edx,%edx
  807916:	74 0f                	je     807927 <netif_set_ipaddr+0x63>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
  807918:	3b 53 04             	cmp    0x4(%ebx),%edx
  80791b:	75 0a                	jne    807927 <netif_set_ipaddr+0x63>
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  80791d:	89 ca                	mov    %ecx,%edx
  80791f:	85 f6                	test   %esi,%esi
  807921:	74 02                	je     807925 <netif_set_ipaddr+0x61>
  807923:	8b 16                	mov    (%esi),%edx
  807925:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  807927:	8b 40 0c             	mov    0xc(%eax),%eax
  80792a:	85 c0                	test   %eax,%eax
  80792c:	75 e0                	jne    80790e <netif_set_ipaddr+0x4a>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80792e:	b8 00 00 00 00       	mov    $0x0,%eax
  807933:	85 f6                	test   %esi,%esi
  807935:	74 02                	je     807939 <netif_set_ipaddr+0x75>
  807937:	8b 06                	mov    (%esi),%eax
  807939:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  80793c:	83 c4 1c             	add    $0x1c,%esp
  80793f:	5b                   	pop    %ebx
  807940:	5e                   	pop    %esi
  807941:	5f                   	pop    %edi
  807942:	5d                   	pop    %ebp
  807943:	c3                   	ret    

00807944 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  807944:	55                   	push   %ebp
  807945:	89 e5                	mov    %esp,%ebp
  807947:	53                   	push   %ebx
  807948:	83 ec 14             	sub    $0x14,%esp
  80794b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif_set_ipaddr(netif, ipaddr);
  80794e:	8b 45 0c             	mov    0xc(%ebp),%eax
  807951:	89 44 24 04          	mov    %eax,0x4(%esp)
  807955:	89 1c 24             	mov    %ebx,(%esp)
  807958:	e8 67 ff ff ff       	call   8078c4 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
  80795d:	8b 45 10             	mov    0x10(%ebp),%eax
  807960:	89 44 24 04          	mov    %eax,0x4(%esp)
  807964:	89 1c 24             	mov    %ebx,(%esp)
  807967:	e8 7c fe ff ff       	call   8077e8 <netif_set_netmask>
  netif_set_gw(netif, gw);
  80796c:	8b 45 14             	mov    0x14(%ebp),%eax
  80796f:	89 44 24 04          	mov    %eax,0x4(%esp)
  807973:	89 1c 24             	mov    %ebx,(%esp)
  807976:	e8 54 fe ff ff       	call   8077cf <netif_set_gw>
}
  80797b:	83 c4 14             	add    $0x14,%esp
  80797e:	5b                   	pop    %ebx
  80797f:	5d                   	pop    %ebp
  807980:	c3                   	ret    

00807981 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  807981:	55                   	push   %ebp
  807982:	89 e5                	mov    %esp,%ebp
  807984:	53                   	push   %ebx
  807985:	83 ec 14             	sub    $0x14,%esp
  807988:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  80798b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  807992:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  807999:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  8079a0:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  8079a4:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  8079ab:	8b 45 18             	mov    0x18(%ebp),%eax
  8079ae:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  8079b1:	0f b6 05 24 54 b3 00 	movzbl 0xb35424,%eax
  8079b8:	88 43 31             	mov    %al,0x31(%ebx)
  8079bb:	83 c0 01             	add    $0x1,%eax
  8079be:	a2 24 54 b3 00       	mov    %al,0xb35424
  netif->input = input;
  8079c3:	8b 45 20             	mov    0x20(%ebp),%eax
  8079c6:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  8079c9:	8b 45 14             	mov    0x14(%ebp),%eax
  8079cc:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8079d0:	8b 45 10             	mov    0x10(%ebp),%eax
  8079d3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8079d7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8079da:	89 44 24 04          	mov    %eax,0x4(%esp)
  8079de:	89 1c 24             	mov    %ebx,(%esp)
  8079e1:	e8 5e ff ff ff       	call   807944 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  8079e6:	89 1c 24             	mov    %ebx,(%esp)
  8079e9:	ff 55 1c             	call   *0x1c(%ebp)
  8079ec:	84 c0                	test   %al,%al
  8079ee:	74 07                	je     8079f7 <netif_add+0x76>
  8079f0:	bb 00 00 00 00       	mov    $0x0,%ebx
  8079f5:	eb 0d                	jmp    807a04 <netif_add+0x83>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  8079f7:	a1 04 f0 b3 00       	mov    0xb3f004,%eax
  8079fc:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  8079fe:	89 1d 04 f0 b3 00    	mov    %ebx,0xb3f004
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  807a04:	89 d8                	mov    %ebx,%eax
  807a06:	83 c4 14             	add    $0x14,%esp
  807a09:	5b                   	pop    %ebx
  807a0a:	5d                   	pop    %ebp
  807a0b:	c3                   	ret    
  807a0c:	00 00                	add    %al,(%eax)
	...

00807a10 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  807a10:	55                   	push   %ebp
  807a11:	89 e5                	mov    %esp,%ebp
  807a13:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  while (p != NULL) {
  807a16:	b8 00 00 00 00       	mov    $0x0,%eax
  807a1b:	85 d2                	test   %edx,%edx
  807a1d:	74 09                	je     807a28 <pbuf_clen+0x18>
    ++len;
  807a1f:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  807a22:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  807a24:	85 d2                	test   %edx,%edx
  807a26:	75 f7                	jne    807a1f <pbuf_clen+0xf>
    ++len;
    p = p->next;
  }
  return len;
}
  807a28:	5d                   	pop    %ebp
  807a29:	c3                   	ret    

00807a2a <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  807a2a:	55                   	push   %ebp
  807a2b:	89 e5                	mov    %esp,%ebp
  807a2d:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  807a30:	85 c0                	test   %eax,%eax
  807a32:	74 05                	je     807a39 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  807a34:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  807a39:	5d                   	pop    %ebp
  807a3a:	c3                   	ret    

00807a3b <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  807a3b:	55                   	push   %ebp
  807a3c:	89 e5                	mov    %esp,%ebp
  807a3e:	53                   	push   %ebx
  807a3f:	83 ec 14             	sub    $0x14,%esp
  807a42:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807a45:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807a48:	85 db                	test   %ebx,%ebx
  807a4a:	74 0e                	je     807a5a <pbuf_cat+0x1f>
  807a4c:	85 c9                	test   %ecx,%ecx
  807a4e:	74 0a                	je     807a5a <pbuf_cat+0x1f>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807a50:	8b 13                	mov    (%ebx),%edx
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807a52:	89 d8                	mov    %ebx,%eax
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807a54:	85 d2                	test   %edx,%edx
  807a56:	75 1e                	jne    807a76 <pbuf_cat+0x3b>
  807a58:	eb 2c                	jmp    807a86 <pbuf_cat+0x4b>
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807a5a:	c7 44 24 08 20 35 81 	movl   $0x813520,0x8(%esp)
  807a61:	00 
  807a62:	c7 44 24 04 42 02 00 	movl   $0x242,0x4(%esp)
  807a69:	00 
  807a6a:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807a71:	e8 72 8f ff ff       	call   8009e8 <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  807a76:	0f b7 51 08          	movzwl 0x8(%ecx),%edx
  807a7a:	66 01 50 08          	add    %dx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807a7e:	8b 00                	mov    (%eax),%eax
  807a80:	8b 10                	mov    (%eax),%edx
  807a82:	85 d2                	test   %edx,%edx
  807a84:	75 f0                	jne    807a76 <pbuf_cat+0x3b>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  807a86:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  807a8a:	66 3b 58 0a          	cmp    0xa(%eax),%bx
  807a8e:	74 1c                	je     807aac <pbuf_cat+0x71>
  807a90:	c7 44 24 08 58 35 81 	movl   $0x813558,0x8(%esp)
  807a97:	00 
  807a98:	c7 44 24 04 4a 02 00 	movl   $0x24a,0x4(%esp)
  807a9f:	00 
  807aa0:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807aa7:	e8 3c 8f ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  807aac:	85 d2                	test   %edx,%edx
  807aae:	74 1c                	je     807acc <pbuf_cat+0x91>
  807ab0:	c7 44 24 08 ca 36 81 	movl   $0x8136ca,0x8(%esp)
  807ab7:	00 
  807ab8:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  807abf:	00 
  807ac0:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807ac7:	e8 1c 8f ff ff       	call   8009e8 <_panic>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  807acc:	66 03 59 08          	add    0x8(%ecx),%bx
  807ad0:	66 89 58 08          	mov    %bx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  807ad4:	89 08                	mov    %ecx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  807ad6:	83 c4 14             	add    $0x14,%esp
  807ad9:	5b                   	pop    %ebx
  807ada:	5d                   	pop    %ebp
  807adb:	c3                   	ret    

00807adc <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  807adc:	55                   	push   %ebp
  807add:	89 e5                	mov    %esp,%ebp
  807adf:	53                   	push   %ebx
  807ae0:	83 ec 14             	sub    $0x14,%esp
  807ae3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  807ae6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  807aea:	8b 45 08             	mov    0x8(%ebp),%eax
  807aed:	89 04 24             	mov    %eax,(%esp)
  807af0:	e8 46 ff ff ff       	call   807a3b <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  807af5:	89 1c 24             	mov    %ebx,(%esp)
  807af8:	e8 2d ff ff ff       	call   807a2a <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  807afd:	83 c4 14             	add    $0x14,%esp
  807b00:	5b                   	pop    %ebx
  807b01:	5d                   	pop    %ebp
  807b02:	c3                   	ret    

00807b03 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  807b03:	55                   	push   %ebp
  807b04:	89 e5                	mov    %esp,%ebp
  807b06:	83 ec 18             	sub    $0x18,%esp
  807b09:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  807b0c:	89 75 fc             	mov    %esi,-0x4(%ebp)
  807b0f:	8b 55 08             	mov    0x8(%ebp),%edx
  807b12:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  807b16:	85 d2                	test   %edx,%edx
  807b18:	75 1c                	jne    807b36 <pbuf_header+0x33>
  807b1a:	c7 44 24 08 93 37 81 	movl   $0x813793,0x8(%esp)
  807b21:	00 
  807b22:	c7 44 24 04 64 01 00 	movl   $0x164,0x4(%esp)
  807b29:	00 
  807b2a:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807b31:	e8 b2 8e ff ff       	call   8009e8 <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  807b36:	b8 00 00 00 00       	mov    $0x0,%eax
  807b3b:	66 85 c9             	test   %cx,%cx
  807b3e:	0f 84 a8 00 00 00    	je     807bec <pbuf_header+0xe9>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  807b44:	89 ce                	mov    %ecx,%esi

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  807b46:	66 85 c9             	test   %cx,%cx
  807b49:	79 24                	jns    807b6f <pbuf_header+0x6c>
    increment_magnitude = -header_size_increment;
  807b4b:	f7 de                	neg    %esi
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  807b4d:	66 3b 72 0a          	cmp    0xa(%edx),%si
  807b51:	76 1c                	jbe    807b6f <pbuf_header+0x6c>
  807b53:	c7 44 24 08 da 36 81 	movl   $0x8136da,0x8(%esp)
  807b5a:	00 
  807b5b:	c7 44 24 04 6b 01 00 	movl   $0x16b,0x4(%esp)
  807b62:	00 
  807b63:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807b6a:	e8 79 8e ff ff       	call   8009e8 <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  807b6f:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  807b73:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  807b76:	66 85 c0             	test   %ax,%ax
  807b79:	74 06                	je     807b81 <pbuf_header+0x7e>
  807b7b:	66 83 f8 03          	cmp    $0x3,%ax
  807b7f:	75 1d                	jne    807b9e <pbuf_header+0x9b>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  807b81:	0f bf c1             	movswl %cx,%eax
  807b84:	89 de                	mov    %ebx,%esi
  807b86:	29 c6                	sub    %eax,%esi
  807b88:	89 f0                	mov    %esi,%eax
  807b8a:	89 72 04             	mov    %esi,0x4(%edx)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  807b8d:	8d 72 10             	lea    0x10(%edx),%esi
  807b90:	39 f0                	cmp    %esi,%eax
  807b92:	73 44                	jae    807bd8 <pbuf_header+0xd5>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  807b94:	89 5a 04             	mov    %ebx,0x4(%edx)
  807b97:	b8 01 00 00 00       	mov    $0x1,%eax
      /* bail out unsuccesfully */
      return 1;
  807b9c:	eb 4e                	jmp    807bec <pbuf_header+0xe9>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  807b9e:	83 e8 01             	sub    $0x1,%eax
  807ba1:	66 83 f8 01          	cmp    $0x1,%ax
  807ba5:	77 15                	ja     807bbc <pbuf_header+0xb9>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  807ba7:	66 85 c9             	test   %cx,%cx
  807baa:	79 3b                	jns    807be7 <pbuf_header+0xe4>
  807bac:	66 3b 72 0a          	cmp    0xa(%edx),%si
  807bb0:	77 35                	ja     807be7 <pbuf_header+0xe4>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  807bb2:	0f bf c1             	movswl %cx,%eax
  807bb5:	29 c3                	sub    %eax,%ebx
  807bb7:	89 5a 04             	mov    %ebx,0x4(%edx)
  807bba:	eb 1c                	jmp    807bd8 <pbuf_header+0xd5>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  807bbc:	c7 44 24 08 f8 36 81 	movl   $0x8136f8,0x8(%esp)
  807bc3:	00 
  807bc4:	c7 44 24 04 9a 01 00 	movl   $0x19a,0x4(%esp)
  807bcb:	00 
  807bcc:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807bd3:	e8 10 8e ff ff       	call   8009e8 <_panic>
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  807bd8:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  807bdc:	66 01 4a 08          	add    %cx,0x8(%edx)
  807be0:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  807be5:	eb 05                	jmp    807bec <pbuf_header+0xe9>
  807be7:	b8 01 00 00 00       	mov    $0x1,%eax
}
  807bec:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  807bef:	8b 75 fc             	mov    -0x4(%ebp),%esi
  807bf2:	89 ec                	mov    %ebp,%esp
  807bf4:	5d                   	pop    %ebp
  807bf5:	c3                   	ret    

00807bf6 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  807bf6:	55                   	push   %ebp
  807bf7:	89 e5                	mov    %esp,%ebp
  807bf9:	57                   	push   %edi
  807bfa:	56                   	push   %esi
  807bfb:	53                   	push   %ebx
  807bfc:	83 ec 2c             	sub    $0x2c,%esp
  807bff:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807c02:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  807c06:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  807c0a:	85 db                	test   %ebx,%ebx
  807c0c:	75 1c                	jne    807c2a <pbuf_copy_partial+0x34>
  807c0e:	c7 44 24 08 88 35 81 	movl   $0x813588,0x8(%esp)
  807c15:	00 
  807c16:	c7 44 24 04 ef 02 00 	movl   $0x2ef,0x4(%esp)
  807c1d:	00 
  807c1e:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807c25:	e8 be 8d ff ff       	call   8009e8 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  807c2a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807c2e:	75 1c                	jne    807c4c <pbuf_copy_partial+0x56>
  807c30:	c7 44 24 08 ac 35 81 	movl   $0x8135ac,0x8(%esp)
  807c37:	00 
  807c38:	c7 44 24 04 f0 02 00 	movl   $0x2f0,0x4(%esp)
  807c3f:	00 
  807c40:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807c47:	e8 9c 8d ff ff       	call   8009e8 <_panic>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  807c4c:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  807c52:	66 85 ff             	test   %di,%di
  807c55:	74 62                	je     807cb9 <pbuf_copy_partial+0xc3>
  807c57:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
    if ((offset != 0) && (offset >= p->len)) {
  807c5d:	66 85 c0             	test   %ax,%ax
  807c60:	74 0e                	je     807c70 <pbuf_copy_partial+0x7a>
  807c62:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807c66:	66 39 c2             	cmp    %ax,%dx
  807c69:	77 05                	ja     807c70 <pbuf_copy_partial+0x7a>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  807c6b:	66 29 d0             	sub    %dx,%ax
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  807c6e:	eb 3e                	jmp    807cae <pbuf_copy_partial+0xb8>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  807c70:	0f b7 73 0a          	movzwl 0xa(%ebx),%esi
  807c74:	66 29 c6             	sub    %ax,%si
  807c77:	66 39 fe             	cmp    %di,%si
  807c7a:	76 02                	jbe    807c7e <pbuf_copy_partial+0x88>
  807c7c:	89 fe                	mov    %edi,%esi
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  807c7e:	0f b7 d6             	movzwl %si,%edx
  807c81:	89 54 24 08          	mov    %edx,0x8(%esp)
  807c85:	0f b7 c0             	movzwl %ax,%eax
  807c88:	03 43 04             	add    0x4(%ebx),%eax
  807c8b:	89 44 24 04          	mov    %eax,0x4(%esp)
  807c8f:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807c93:	03 45 0c             	add    0xc(%ebp),%eax
  807c96:	89 04 24             	mov    %eax,(%esp)
  807c99:	e8 93 99 ff ff       	call   801631 <memcpy>
      copied_total += buf_copy_len;
  807c9e:	66 01 75 e4          	add    %si,-0x1c(%ebp)
      left += buf_copy_len;
  807ca2:	66 01 75 e6          	add    %si,-0x1a(%ebp)
      len -= buf_copy_len;
  807ca6:	66 29 f7             	sub    %si,%di
  807ca9:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  807cae:	8b 1b                	mov    (%ebx),%ebx
  807cb0:	66 85 ff             	test   %di,%di
  807cb3:	74 04                	je     807cb9 <pbuf_copy_partial+0xc3>
  807cb5:	85 db                	test   %ebx,%ebx
  807cb7:	75 a4                	jne    807c5d <pbuf_copy_partial+0x67>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  807cb9:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807cbd:	83 c4 2c             	add    $0x2c,%esp
  807cc0:	5b                   	pop    %ebx
  807cc1:	5e                   	pop    %esi
  807cc2:	5f                   	pop    %edi
  807cc3:	5d                   	pop    %ebp
  807cc4:	c3                   	ret    

00807cc5 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  807cc5:	55                   	push   %ebp
  807cc6:	89 e5                	mov    %esp,%ebp
  807cc8:	57                   	push   %edi
  807cc9:	56                   	push   %esi
  807cca:	53                   	push   %ebx
  807ccb:	83 ec 2c             	sub    $0x2c,%esp
  807cce:	8b 75 08             	mov    0x8(%ebp),%esi
  807cd1:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  807cd4:	85 f6                	test   %esi,%esi
  807cd6:	0f 94 c0             	sete   %al
  807cd9:	74 0e                	je     807ce9 <pbuf_copy+0x24>
  807cdb:	85 db                	test   %ebx,%ebx
  807cdd:	74 0a                	je     807ce9 <pbuf_copy+0x24>
  807cdf:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  807ce3:	66 3b 53 08          	cmp    0x8(%ebx),%dx
  807ce7:	73 1c                	jae    807d05 <pbuf_copy+0x40>
  807ce9:	c7 44 24 08 d4 35 81 	movl   $0x8135d4,0x8(%esp)
  807cf0:	00 
  807cf1:	c7 44 24 04 b1 02 00 	movl   $0x2b1,0x4(%esp)
  807cf8:	00 
  807cf9:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807d00:	e8 e3 8c ff ff       	call   8009e8 <_panic>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  807d05:	84 c0                	test   %al,%al
  807d07:	74 25                	je     807d2e <pbuf_copy+0x69>
  807d09:	eb 07                	jmp    807d12 <pbuf_copy+0x4d>
  807d0b:	85 f6                	test   %esi,%esi
  807d0d:	8d 76 00             	lea    0x0(%esi),%esi
  807d10:	75 27                	jne    807d39 <pbuf_copy+0x74>
  807d12:	c7 44 24 08 06 37 81 	movl   $0x813706,0x8(%esp)
  807d19:	00 
  807d1a:	c7 44 24 04 b6 02 00 	movl   $0x2b6,0x4(%esp)
  807d21:	00 
  807d22:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807d29:	e8 ba 8c ff ff       	call   8009e8 <_panic>
  807d2e:	bf 00 00 00 00       	mov    $0x0,%edi
  807d33:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  807d39:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807d3d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  807d41:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  807d45:	0f b7 d0             	movzwl %ax,%edx
  807d48:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807d4c:	29 c2                	sub    %eax,%edx
  807d4e:	89 55 e0             	mov    %edx,-0x20(%ebp)
  807d51:	0f b7 d1             	movzwl %cx,%edx
  807d54:	0f b7 c7             	movzwl %di,%eax
  807d57:	29 c2                	sub    %eax,%edx
  807d59:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  807d5c:	7c 09                	jl     807d67 <pbuf_copy+0xa2>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  807d5e:	66 29 f9             	sub    %di,%cx
  807d61:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
  807d65:	eb 0c                	jmp    807d73 <pbuf_copy+0xae>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  807d67:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807d6b:	66 2b 45 e6          	sub    -0x1a(%ebp),%ax
  807d6f:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  807d73:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807d77:	89 44 24 08          	mov    %eax,0x8(%esp)
  807d7b:	0f b7 c7             	movzwl %di,%eax
  807d7e:	03 43 04             	add    0x4(%ebx),%eax
  807d81:	89 44 24 04          	mov    %eax,0x4(%esp)
  807d85:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807d89:	03 46 04             	add    0x4(%esi),%eax
  807d8c:	89 04 24             	mov    %eax,(%esp)
  807d8f:	e8 9d 98 ff ff       	call   801631 <memcpy>
    offset_to += len;
  807d94:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807d98:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  807d9c:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807da0:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  807da4:	76 1c                	jbe    807dc2 <pbuf_copy+0xfd>
  807da6:	c7 44 24 08 13 37 81 	movl   $0x813713,0x8(%esp)
  807dad:	00 
  807dae:	c7 44 24 04 c2 02 00 	movl   $0x2c2,0x4(%esp)
  807db5:	00 
  807db6:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807dbd:	e8 26 8c ff ff       	call   8009e8 <_panic>
    if (offset_to == p_to->len) {
  807dc2:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  807dc6:	75 08                	jne    807dd0 <pbuf_copy+0x10b>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  807dc8:	8b 36                	mov    (%esi),%esi
  807dca:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
  807dd0:	66 03 7d e4          	add    -0x1c(%ebp),%di
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  807dd4:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807dd8:	66 39 c7             	cmp    %ax,%di
  807ddb:	76 1c                	jbe    807df9 <pbuf_copy+0x134>
  807ddd:	c7 44 24 08 2a 37 81 	movl   $0x81372a,0x8(%esp)
  807de4:	00 
  807de5:	c7 44 24 04 c8 02 00 	movl   $0x2c8,0x4(%esp)
  807dec:	00 
  807ded:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807df4:	e8 ef 8b ff ff       	call   8009e8 <_panic>
    if (offset_from >= p_from->len) {
  807df9:	66 39 c7             	cmp    %ax,%di
  807dfc:	72 07                	jb     807e05 <pbuf_copy+0x140>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  807dfe:	8b 1b                	mov    (%ebx),%ebx
  807e00:	bf 00 00 00 00       	mov    $0x0,%edi
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  807e05:	85 db                	test   %ebx,%ebx
  807e07:	74 2b                	je     807e34 <pbuf_copy+0x16f>
  807e09:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807e0d:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  807e11:	75 21                	jne    807e34 <pbuf_copy+0x16f>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  807e13:	83 3b 00             	cmpl   $0x0,(%ebx)
  807e16:	74 1c                	je     807e34 <pbuf_copy+0x16f>
  807e18:	c7 44 24 08 04 36 81 	movl   $0x813604,0x8(%esp)
  807e1f:	00 
  807e20:	c7 44 24 04 d2 02 00 	movl   $0x2d2,0x4(%esp)
  807e27:	00 
  807e28:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807e2f:	e8 b4 8b ff ff       	call   8009e8 <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  807e34:	85 f6                	test   %esi,%esi
  807e36:	74 2b                	je     807e63 <pbuf_copy+0x19e>
  807e38:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807e3c:	66 3b 46 08          	cmp    0x8(%esi),%ax
  807e40:	75 21                	jne    807e63 <pbuf_copy+0x19e>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  807e42:	83 3e 00             	cmpl   $0x0,(%esi)
  807e45:	74 1c                	je     807e63 <pbuf_copy+0x19e>
  807e47:	c7 44 24 08 04 36 81 	movl   $0x813604,0x8(%esp)
  807e4e:	00 
  807e4f:	c7 44 24 04 d7 02 00 	movl   $0x2d7,0x4(%esp)
  807e56:	00 
  807e57:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807e5e:	e8 85 8b ff ff       	call   8009e8 <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  807e63:	85 db                	test   %ebx,%ebx
  807e65:	0f 85 a0 fe ff ff    	jne    807d0b <pbuf_copy+0x46>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  807e6b:	b8 00 00 00 00       	mov    $0x0,%eax
  807e70:	83 c4 2c             	add    $0x2c,%esp
  807e73:	5b                   	pop    %ebx
  807e74:	5e                   	pop    %esi
  807e75:	5f                   	pop    %edi
  807e76:	5d                   	pop    %ebp
  807e77:	c3                   	ret    

00807e78 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  807e78:	55                   	push   %ebp
  807e79:	89 e5                	mov    %esp,%ebp
  807e7b:	56                   	push   %esi
  807e7c:	53                   	push   %ebx
  807e7d:	83 ec 10             	sub    $0x10,%esp
  807e80:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  807e83:	85 c0                	test   %eax,%eax
  807e85:	75 1c                	jne    807ea3 <pbuf_free+0x2b>
    LWIP_ASSERT("p != NULL", p != NULL);
  807e87:	c7 44 24 08 93 37 81 	movl   $0x813793,0x8(%esp)
  807e8e:	00 
  807e8f:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp)
  807e96:	00 
  807e97:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807e9e:	e8 45 8b ff ff       	call   8009e8 <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  807ea3:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  807ea7:	77 0a                	ja     807eb3 <pbuf_free+0x3b>
  807ea9:	be 00 00 00 00       	mov    $0x0,%esi
  807eae:	e9 82 00 00 00       	jmp    807f35 <pbuf_free+0xbd>
  807eb3:	c7 44 24 08 45 37 81 	movl   $0x813745,0x8(%esp)
  807eba:	00 
  807ebb:	c7 44 24 04 db 01 00 	movl   $0x1db,0x4(%esp)
  807ec2:	00 
  807ec3:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807eca:	e8 19 8b ff ff       	call   8009e8 <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  807ecf:	c7 44 24 08 5a 37 81 	movl   $0x81375a,0x8(%esp)
  807ed6:	00 
  807ed7:	c7 44 24 04 e8 01 00 	movl   $0x1e8,0x4(%esp)
  807ede:	00 
  807edf:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807ee6:	e8 fd 8a ff ff       	call   8009e8 <_panic>
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  807eeb:	8b 18                	mov    (%eax),%ebx
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  807eed:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  807ef1:	66 83 fa 03          	cmp    $0x3,%dx
  807ef5:	75 12                	jne    807f09 <pbuf_free+0x91>
        memp_free(MEMP_PBUF_POOL, p);
  807ef7:	89 44 24 04          	mov    %eax,0x4(%esp)
  807efb:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  807f02:	e8 d9 f7 ff ff       	call   8076e0 <memp_free>
  807f07:	eb 23                	jmp    807f2c <pbuf_free+0xb4>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  807f09:	83 ea 01             	sub    $0x1,%edx
  807f0c:	66 83 fa 01          	cmp    $0x1,%dx
  807f10:	77 12                	ja     807f24 <pbuf_free+0xac>
        memp_free(MEMP_PBUF, p);
  807f12:	89 44 24 04          	mov    %eax,0x4(%esp)
  807f16:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  807f1d:	e8 be f7 ff ff       	call   8076e0 <memp_free>
  807f22:	eb 08                	jmp    807f2c <pbuf_free+0xb4>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  807f24:	89 04 24             	mov    %eax,(%esp)
  807f27:	e8 42 f5 ff ff       	call   80746e <mem_free>
      }
      count++;
  807f2c:	83 c6 01             	add    $0x1,%esi
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  807f2f:	85 db                	test   %ebx,%ebx
  807f31:	74 17                	je     807f4a <pbuf_free+0xd2>
  807f33:	89 d8                	mov    %ebx,%eax
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  807f35:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  807f39:	66 85 d2             	test   %dx,%dx
  807f3c:	74 91                	je     807ecf <pbuf_free+0x57>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  807f3e:	83 ea 01             	sub    $0x1,%edx
  807f41:	66 89 50 0e          	mov    %dx,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  807f45:	66 85 d2             	test   %dx,%dx
  807f48:	74 a1                	je     807eeb <pbuf_free+0x73>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  807f4a:	89 f0                	mov    %esi,%eax
  807f4c:	83 c4 10             	add    $0x10,%esp
  807f4f:	5b                   	pop    %ebx
  807f50:	5e                   	pop    %esi
  807f51:	5d                   	pop    %ebp
  807f52:	c3                   	ret    

00807f53 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  807f53:	55                   	push   %ebp
  807f54:	89 e5                	mov    %esp,%ebp
  807f56:	83 ec 38             	sub    $0x38,%esp
  807f59:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  807f5c:	89 75 f8             	mov    %esi,-0x8(%ebp)
  807f5f:	89 7d fc             	mov    %edi,-0x4(%ebp)
  807f62:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  807f65:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  807f67:	b8 01 00 00 00       	mov    $0x1,%eax
  807f6c:	85 f6                	test   %esi,%esi
  807f6e:	74 55                	je     807fc5 <pbuf_dechain+0x72>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  807f70:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  807f74:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807f78:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  807f7c:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  807f7f:	0f b7 fa             	movzwl %dx,%edi
  807f82:	0f b7 c8             	movzwl %ax,%ecx
  807f85:	29 cf                	sub    %ecx,%edi
  807f87:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  807f8a:	74 1c                	je     807fa8 <pbuf_dechain+0x55>
  807f8c:	c7 44 24 08 30 36 81 	movl   $0x813630,0x8(%esp)
  807f93:	00 
  807f94:	c7 44 24 04 80 02 00 	movl   $0x280,0x4(%esp)
  807f9b:	00 
  807f9c:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807fa3:	e8 40 8a ff ff       	call   8009e8 <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  807fa8:	66 29 c2             	sub    %ax,%dx
  807fab:	66 89 56 08          	mov    %dx,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  807faf:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  807fb5:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807fb9:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  807fbd:	89 34 24             	mov    %esi,(%esp)
  807fc0:	e8 b3 fe ff ff       	call   807e78 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  807fc5:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  807fc9:	66 3b 53 0a          	cmp    0xa(%ebx),%dx
  807fcd:	74 1c                	je     807feb <pbuf_dechain+0x98>
  807fcf:	c7 44 24 08 70 37 81 	movl   $0x813770,0x8(%esp)
  807fd6:	00 
  807fd7:	c7 44 24 04 91 02 00 	movl   $0x291,0x4(%esp)
  807fde:	00 
  807fdf:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  807fe6:	e8 fd 89 ff ff       	call   8009e8 <_panic>
  return ((tail_gone > 0) ? NULL : q);
  807feb:	3c 01                	cmp    $0x1,%al
  807fed:	19 c0                	sbb    %eax,%eax
  807fef:	21 c6                	and    %eax,%esi
}
  807ff1:	89 f0                	mov    %esi,%eax
  807ff3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  807ff6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  807ff9:	8b 7d fc             	mov    -0x4(%ebp),%edi
  807ffc:	89 ec                	mov    %ebp,%esp
  807ffe:	5d                   	pop    %ebp
  807fff:	c3                   	ret    

00808000 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  808000:	55                   	push   %ebp
  808001:	89 e5                	mov    %esp,%ebp
  808003:	56                   	push   %esi
  808004:	53                   	push   %ebx
  808005:	83 ec 10             	sub    $0x10,%esp
  808008:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80800b:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  80800f:	85 db                	test   %ebx,%ebx
  808011:	75 1c                	jne    80802f <pbuf_realloc+0x2f>
  808013:	c7 44 24 08 85 37 81 	movl   $0x813785,0x8(%esp)
  80801a:	00 
  80801b:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp)
  808022:	00 
  808023:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  80802a:	e8 b9 89 ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  80802f:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  808033:	3c 03                	cmp    $0x3,%al
  808035:	74 2b                	je     808062 <pbuf_realloc+0x62>
  808037:	3c 01                	cmp    $0x1,%al
  808039:	74 27                	je     808062 <pbuf_realloc+0x62>
  80803b:	84 c0                	test   %al,%al
  80803d:	8d 76 00             	lea    0x0(%esi),%esi
  808040:	74 20                	je     808062 <pbuf_realloc+0x62>
  808042:	3c 02                	cmp    $0x2,%al
  808044:	74 1c                	je     808062 <pbuf_realloc+0x62>
  808046:	c7 44 24 08 9d 37 81 	movl   $0x81379d,0x8(%esp)
  80804d:	00 
  80804e:	c7 44 24 04 17 01 00 	movl   $0x117,0x4(%esp)
  808055:	00 
  808056:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  80805d:	e8 86 89 ff ff       	call   8009e8 <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  808062:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808066:	66 39 f0             	cmp    %si,%ax
  808069:	0f 86 bd 00 00 00    	jbe    80812c <pbuf_realloc+0x12c>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  80806f:	0f b7 d6             	movzwl %si,%edx
  808072:	0f b7 c0             	movzwl %ax,%eax
  808075:	29 c2                	sub    %eax,%edx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  808077:	eb 4d                	jmp    8080c6 <pbuf_realloc+0xc6>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  808079:	81 fa fe ff 00 00    	cmp    $0xfffe,%edx
  80807f:	7e 1c                	jle    80809d <pbuf_realloc+0x9d>
  808081:	c7 44 24 08 b8 37 81 	movl   $0x8137b8,0x8(%esp)
  808088:	00 
  808089:	c7 44 24 04 2b 01 00 	movl   $0x12b,0x4(%esp)
  808090:	00 
  808091:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  808098:	e8 4b 89 ff ff       	call   8009e8 <_panic>
    q->tot_len += (u16_t)grow;
  80809d:	66 01 53 08          	add    %dx,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  8080a1:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  8080a3:	85 db                	test   %ebx,%ebx
  8080a5:	75 1c                	jne    8080c3 <pbuf_realloc+0xc3>
  8080a7:	c7 44 24 08 c9 37 81 	movl   $0x8137c9,0x8(%esp)
  8080ae:	00 
  8080af:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp)
  8080b6:	00 
  8080b7:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  8080be:	e8 25 89 ff ff       	call   8009e8 <_panic>
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  8080c3:	66 29 c6             	sub    %ax,%si

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  8080c6:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8080ca:	66 39 c6             	cmp    %ax,%si
  8080cd:	77 aa                	ja     808079 <pbuf_realloc+0x79>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  8080cf:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  8080d3:	75 3b                	jne    808110 <pbuf_realloc+0x110>
  8080d5:	66 39 f0             	cmp    %si,%ax
  8080d8:	74 36                	je     808110 <pbuf_realloc+0x110>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  8080da:	0f b7 c6             	movzwl %si,%eax
  8080dd:	03 43 04             	add    0x4(%ebx),%eax
  8080e0:	29 d8                	sub    %ebx,%eax
  8080e2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8080e6:	89 1c 24             	mov    %ebx,(%esp)
  8080e9:	e8 1d f2 ff ff       	call   80730b <mem_realloc>
  8080ee:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  8080f0:	85 c0                	test   %eax,%eax
  8080f2:	75 1c                	jne    808110 <pbuf_realloc+0x110>
  8080f4:	c7 44 24 08 e1 37 81 	movl   $0x8137e1,0x8(%esp)
  8080fb:	00 
  8080fc:	c7 44 24 04 39 01 00 	movl   $0x139,0x4(%esp)
  808103:	00 
  808104:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  80810b:	e8 d8 88 ff ff       	call   8009e8 <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  808110:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  808114:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  808118:	8b 03                	mov    (%ebx),%eax
  80811a:	85 c0                	test   %eax,%eax
  80811c:	74 08                	je     808126 <pbuf_realloc+0x126>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  80811e:	89 04 24             	mov    %eax,(%esp)
  808121:	e8 52 fd ff ff       	call   807e78 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  808126:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  80812c:	83 c4 10             	add    $0x10,%esp
  80812f:	5b                   	pop    %ebx
  808130:	5e                   	pop    %esi
  808131:	5d                   	pop    %ebp
  808132:	c3                   	ret    

00808133 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  808133:	55                   	push   %ebp
  808134:	89 e5                	mov    %esp,%ebp
  808136:	57                   	push   %edi
  808137:	56                   	push   %esi
  808138:	53                   	push   %ebx
  808139:	83 ec 2c             	sub    $0x2c,%esp
  80813c:	8b 45 08             	mov    0x8(%ebp),%eax
  80813f:	8b 7d 10             	mov    0x10(%ebp),%edi
  808142:	0f b7 5d 0c          	movzwl 0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  808146:	83 f8 01             	cmp    $0x1,%eax
  808149:	74 27                	je     808172 <pbuf_alloc+0x3f>
  80814b:	ba 14 00 00 00       	mov    $0x14,%edx
  808150:	83 f8 01             	cmp    $0x1,%eax
  808153:	72 22                	jb     808177 <pbuf_alloc+0x44>
  808155:	83 f8 02             	cmp    $0x2,%eax
  808158:	74 10                	je     80816a <pbuf_alloc+0x37>
  80815a:	83 f8 03             	cmp    $0x3,%eax
  80815d:	8d 76 00             	lea    0x0(%esi),%esi
  808160:	75 21                	jne    808183 <pbuf_alloc+0x50>
  808162:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  808168:	eb 35                	jmp    80819f <pbuf_alloc+0x6c>
  80816a:	ba 00 00 00 00       	mov    $0x0,%edx
  80816f:	90                   	nop
  808170:	eb 08                	jmp    80817a <pbuf_alloc+0x47>
  808172:	ba 00 00 00 00       	mov    $0x0,%edx
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  808177:	83 c2 14             	add    $0x14,%edx
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  80817a:	83 c2 0e             	add    $0xe,%edx
  80817d:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    break;
  808181:	eb 22                	jmp    8081a5 <pbuf_alloc+0x72>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  808183:	c7 44 24 08 fc 37 81 	movl   $0x8137fc,0x8(%esp)
  80818a:	00 
  80818b:	c7 44 24 04 8a 00 00 	movl   $0x8a,0x4(%esp)
  808192:	00 
  808193:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  80819a:	e8 49 88 ff ff       	call   8009e8 <_panic>
  80819f:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
    return NULL;
  }

  switch (type) {
  8081a5:	83 ff 02             	cmp    $0x2,%edi
  8081a8:	77 0e                	ja     8081b8 <pbuf_alloc+0x85>
  8081aa:	83 ff 01             	cmp    $0x1,%edi
  8081ad:	0f 83 c1 01 00 00    	jae    808374 <pbuf_alloc+0x241>
  8081b3:	e9 7a 01 00 00       	jmp    808332 <pbuf_alloc+0x1ff>
  8081b8:	83 ff 03             	cmp    $0x3,%edi
  8081bb:	90                   	nop
  8081bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8081c0:	0f 85 dc 01 00 00    	jne    8083a2 <pbuf_alloc+0x26f>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  8081c6:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  8081cd:	8d 76 00             	lea    0x0(%esi),%esi
  8081d0:	e8 4f f5 ff ff       	call   807724 <memp_malloc>
  8081d5:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  8081d7:	85 c0                	test   %eax,%eax
  8081d9:	0f 84 e9 01 00 00    	je     8083c8 <pbuf_alloc+0x295>
      return NULL;
    }
    p->type = type;
  8081df:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  8081e3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  8081e9:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8081ed:	8d 54 06 13          	lea    0x13(%esi,%eax,1),%edx
  8081f1:	83 e2 fc             	and    $0xfffffffc,%edx
  8081f4:	89 56 04             	mov    %edx,0x4(%esi)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  8081f7:	66 89 5e 08          	mov    %bx,0x8(%esi)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  8081fb:	0f b7 db             	movzwl %bx,%ebx
  8081fe:	83 c0 03             	add    $0x3,%eax
  808201:	89 c1                	mov    %eax,%ecx
  808203:	83 e1 fc             	and    $0xfffffffc,%ecx
  808206:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  80820b:	29 c8                	sub    %ecx,%eax
  80820d:	39 d8                	cmp    %ebx,%eax
  80820f:	7e 02                	jle    808213 <pbuf_alloc+0xe0>
  808211:	89 d8                	mov    %ebx,%eax
  808213:	89 c1                	mov    %eax,%ecx
  808215:	66 89 46 0a          	mov    %ax,0xa(%esi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  808219:	8d 86 e0 07 00 00    	lea    0x7e0(%esi),%eax
  80821f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808222:	0f b7 c1             	movzwl %cx,%eax
  808225:	01 c2                	add    %eax,%edx
  808227:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80822a:	73 1c                	jae    808248 <pbuf_alloc+0x115>
  80822c:	c7 44 24 08 54 36 81 	movl   $0x813654,0x8(%esp)
  808233:	00 
  808234:	c7 44 24 04 a3 00 00 	movl   $0xa3,0x4(%esp)
  80823b:	00 
  80823c:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  808243:	e8 a0 87 ff ff       	call   8009e8 <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  808248:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  80824e:	0f b7 c9             	movzwl %cx,%ecx
  808251:	29 cb                	sub    %ecx,%ebx
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  808253:	85 db                	test   %ebx,%ebx
  808255:	0f 8e 63 01 00 00    	jle    8083be <pbuf_alloc+0x28b>
  80825b:	89 f7                	mov    %esi,%edi
      q = memp_malloc(MEMP_PBUF_POOL);
  80825d:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  808264:	e8 bb f4 ff ff       	call   807724 <memp_malloc>
      if (q == NULL) {
  808269:	85 c0                	test   %eax,%eax
  80826b:	75 12                	jne    80827f <pbuf_alloc+0x14c>
        /* free chain so far allocated */
        pbuf_free(p);
  80826d:	89 34 24             	mov    %esi,(%esp)
  808270:	e8 03 fc ff ff       	call   807e78 <pbuf_free>
  808275:	be 00 00 00 00       	mov    $0x0,%esi
        /* bail out unsuccesfully */
        return NULL;
  80827a:	e9 49 01 00 00       	jmp    8083c8 <pbuf_alloc+0x295>
      }
      q->type = type;
  80827f:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  808283:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  808287:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  80828d:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  80828f:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  808295:	7e 1c                	jle    8082b3 <pbuf_alloc+0x180>
  808297:	c7 44 24 08 17 38 81 	movl   $0x813817,0x8(%esp)
  80829e:	00 
  80829f:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  8082a6:	00 
  8082a7:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  8082ae:	e8 35 87 ff ff       	call   8009e8 <_panic>
      q->tot_len = (u16_t)rem_len;
  8082b3:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  8082b7:	89 da                	mov    %ebx,%edx
  8082b9:	66 81 fb cf 07       	cmp    $0x7cf,%bx
  8082be:	76 05                	jbe    8082c5 <pbuf_alloc+0x192>
  8082c0:	ba d0 07 00 00       	mov    $0x7d0,%edx
  8082c5:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  8082c9:	8d 48 10             	lea    0x10(%eax),%ecx
  8082cc:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  8082cf:	f6 c1 03             	test   $0x3,%cl
  8082d2:	74 1c                	je     8082f0 <pbuf_alloc+0x1bd>
  8082d4:	c7 44 24 08 88 36 81 	movl   $0x813688,0x8(%esp)
  8082db:	00 
  8082dc:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  8082e3:	00 
  8082e4:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  8082eb:	e8 f8 86 ff ff       	call   8009e8 <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  8082f0:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  8082f4:	03 4e 04             	add    0x4(%esi),%ecx
  8082f7:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  8082fa:	73 1c                	jae    808318 <pbuf_alloc+0x1e5>
  8082fc:	c7 44 24 08 54 36 81 	movl   $0x813654,0x8(%esp)
  808303:	00 
  808304:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
  80830b:	00 
  80830c:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  808313:	e8 d0 86 ff ff       	call   8009e8 <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  808318:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  80831e:	0f b7 d2             	movzwl %dx,%edx
  808321:	29 d3                	sub    %edx,%ebx
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  808323:	85 db                	test   %ebx,%ebx
  808325:	0f 8e 93 00 00 00    	jle    8083be <pbuf_alloc+0x28b>
  80832b:	89 c7                	mov    %eax,%edi
  80832d:	e9 2b ff ff ff       	jmp    80825d <pbuf_alloc+0x12a>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  808332:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  808336:	8d 57 13             	lea    0x13(%edi),%edx
  808339:	83 e2 fc             	and    $0xfffffffc,%edx
  80833c:	0f b7 c3             	movzwl %bx,%eax
  80833f:	83 c0 03             	add    $0x3,%eax
  808342:	83 e0 fc             	and    $0xfffffffc,%eax
  808345:	8d 04 02             	lea    (%edx,%eax,1),%eax
  808348:	89 04 24             	mov    %eax,(%esp)
  80834b:	e8 90 ed ff ff       	call   8070e0 <mem_malloc>
  808350:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  808352:	85 c0                	test   %eax,%eax
  808354:	74 72                	je     8083c8 <pbuf_alloc+0x295>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  808356:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  80835a:	83 e0 fc             	and    $0xfffffffc,%eax
  80835d:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  808360:	66 89 5e 08          	mov    %bx,0x8(%esi)
  808364:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  808368:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  80836e:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  808372:	eb 4a                	jmp    8083be <pbuf_alloc+0x28b>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  808374:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  80837b:	e8 a4 f3 ff ff       	call   807724 <memp_malloc>
  808380:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  808382:	85 c0                	test   %eax,%eax
  808384:	74 42                	je     8083c8 <pbuf_alloc+0x295>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  808386:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  80838d:	66 89 58 08          	mov    %bx,0x8(%eax)
  808391:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  808395:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  80839b:	89 f8                	mov    %edi,%eax
  80839d:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  8083a0:	eb 1c                	jmp    8083be <pbuf_alloc+0x28b>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  8083a2:	c7 44 24 08 2b 38 81 	movl   $0x81382b,0x8(%esp)
  8083a9:	00 
  8083aa:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
  8083b1:	00 
  8083b2:	c7 04 24 b5 36 81 00 	movl   $0x8136b5,(%esp)
  8083b9:	e8 2a 86 ff ff       	call   8009e8 <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  8083be:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  8083c4:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  8083c8:	89 f0                	mov    %esi,%eax
  8083ca:	83 c4 2c             	add    $0x2c,%esp
  8083cd:	5b                   	pop    %ebx
  8083ce:	5e                   	pop    %esi
  8083cf:	5f                   	pop    %edi
  8083d0:	5d                   	pop    %ebp
  8083d1:	c3                   	ret    
	...

008083e0 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  8083e0:	55                   	push   %ebp
  8083e1:	89 e5                	mov    %esp,%ebp
  8083e3:	83 ec 18             	sub    $0x18,%esp
  8083e6:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  8083e9:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  8083ee:	8b 40 04             	mov    0x4(%eax),%eax
  8083f1:	8b 00                	mov    (%eax),%eax
  8083f3:	89 04 24             	mov    %eax,(%esp)
  8083f6:	e8 5c 57 00 00       	call   80db57 <sys_sem_signal>
}
  8083fb:	c9                   	leave  
  8083fc:	c3                   	ret    

008083fd <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  8083fd:	55                   	push   %ebp
  8083fe:	89 e5                	mov    %esp,%ebp
  808400:	57                   	push   %edi
  808401:	56                   	push   %esi
  808402:	53                   	push   %ebx
  808403:	83 ec 1c             	sub    $0x1c,%esp
  808406:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808409:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80840c:	e8 1c 52 00 00       	call   80d62d <sys_arch_timeouts>

  if (timeouts == NULL) {
  808411:	85 c0                	test   %eax,%eax
  808413:	75 1c                	jne    808431 <sys_untimeout+0x34>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  808415:	c7 44 24 08 48 38 81 	movl   $0x813848,0x8(%esp)
  80841c:	00 
  80841d:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  808424:	00 
  808425:	c7 04 24 68 38 81 00 	movl   $0x813868,(%esp)
  80842c:	e8 b7 85 ff ff       	call   8009e8 <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  808431:	8b 10                	mov    (%eax),%edx
  808433:	85 d2                	test   %edx,%edx
  808435:	74 4b                	je     808482 <sys_untimeout+0x85>
  808437:	bf 00 00 00 00       	mov    $0x0,%edi
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    if ((t->h == h) && (t->arg == arg)) {
  80843c:	39 5a 08             	cmp    %ebx,0x8(%edx)
  80843f:	75 33                	jne    808474 <sys_untimeout+0x77>
  808441:	39 72 0c             	cmp    %esi,0xc(%edx)
  808444:	75 2e                	jne    808474 <sys_untimeout+0x77>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  808446:	85 ff                	test   %edi,%edi
  808448:	75 08                	jne    808452 <sys_untimeout+0x55>
        timeouts->next = t->next;
  80844a:	8b 0a                	mov    (%edx),%ecx
  80844c:	89 08                	mov    %ecx,(%eax)
  80844e:	66 90                	xchg   %ax,%ax
  808450:	eb 04                	jmp    808456 <sys_untimeout+0x59>
      else
        prev_t->next = t->next;
  808452:	8b 02                	mov    (%edx),%eax
  808454:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  808456:	8b 02                	mov    (%edx),%eax
  808458:	85 c0                	test   %eax,%eax
  80845a:	74 06                	je     808462 <sys_untimeout+0x65>
        t->next->time += t->time;
  80845c:	8b 4a 04             	mov    0x4(%edx),%ecx
  80845f:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  808462:	89 54 24 04          	mov    %edx,0x4(%esp)
  808466:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  80846d:	e8 6e f2 ff ff       	call   8076e0 <memp_free>
      return;
  808472:	eb 0e                	jmp    808482 <sys_untimeout+0x85>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  808474:	8b 0a                	mov    (%edx),%ecx
  808476:	85 c9                	test   %ecx,%ecx
  808478:	74 08                	je     808482 <sys_untimeout+0x85>
  80847a:	89 d7                	mov    %edx,%edi
  80847c:	89 ca                	mov    %ecx,%edx
  80847e:	66 90                	xchg   %ax,%ax
  808480:	eb ba                	jmp    80843c <sys_untimeout+0x3f>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  808482:	83 c4 1c             	add    $0x1c,%esp
  808485:	5b                   	pop    %ebx
  808486:	5e                   	pop    %esi
  808487:	5f                   	pop    %edi
  808488:	5d                   	pop    %ebp
  808489:	c3                   	ret    

0080848a <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80848a:	55                   	push   %ebp
  80848b:	89 e5                	mov    %esp,%ebp
  80848d:	56                   	push   %esi
  80848e:	53                   	push   %ebx
  80848f:	83 ec 10             	sub    $0x10,%esp
  808492:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  808495:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  80849c:	e8 83 f2 ff ff       	call   807724 <memp_malloc>
  8084a1:	89 c3                	mov    %eax,%ebx
  if (timeout == NULL) {
  8084a3:	85 c0                	test   %eax,%eax
  8084a5:	75 1c                	jne    8084c3 <sys_timeout+0x39>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  8084a7:	c7 44 24 08 7c 38 81 	movl   $0x81387c,0x8(%esp)
  8084ae:	00 
  8084af:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
  8084b6:	00 
  8084b7:	c7 04 24 68 38 81 00 	movl   $0x813868,(%esp)
  8084be:	e8 25 85 ff ff       	call   8009e8 <_panic>
    return;
  }
  timeout->next = NULL;
  8084c3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  8084c9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8084cc:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  8084cf:	8b 45 10             	mov    0x10(%ebp),%eax
  8084d2:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  8084d5:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  8084d8:	e8 50 51 00 00       	call   80d62d <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  8084dd:	85 c0                	test   %eax,%eax
  8084df:	75 1c                	jne    8084fd <sys_timeout+0x73>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  8084e1:	c7 44 24 08 99 38 81 	movl   $0x813899,0x8(%esp)
  8084e8:	00 
  8084e9:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
  8084f0:	00 
  8084f1:	c7 04 24 68 38 81 00 	movl   $0x813868,(%esp)
  8084f8:	e8 eb 84 ff ff       	call   8009e8 <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  8084fd:	8b 10                	mov    (%eax),%edx
  8084ff:	85 d2                	test   %edx,%edx
  808501:	75 04                	jne    808507 <sys_timeout+0x7d>
    timeouts->next = timeout;
  808503:	89 18                	mov    %ebx,(%eax)
    return;
  808505:	eb 4c                	jmp    808553 <sys_timeout+0xc9>
  }

  if (timeouts->next->time > msecs) {
  808507:	8b 4a 04             	mov    0x4(%edx),%ecx
  80850a:	39 ce                	cmp    %ecx,%esi
  80850c:	73 2d                	jae    80853b <sys_timeout+0xb1>
    timeouts->next->time -= msecs;
  80850e:	29 f1                	sub    %esi,%ecx
  808510:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  808513:	8b 10                	mov    (%eax),%edx
  808515:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  808517:	89 18                	mov    %ebx,(%eax)
  808519:	eb 38                	jmp    808553 <sys_timeout+0xc9>
  80851b:	89 c2                	mov    %eax,%edx
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  80851d:	8b 73 04             	mov    0x4(%ebx),%esi
  808520:	2b 70 04             	sub    0x4(%eax),%esi
  808523:	89 73 04             	mov    %esi,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  808526:	8b 00                	mov    (%eax),%eax
  808528:	85 c0                	test   %eax,%eax
  80852a:	74 07                	je     808533 <sys_timeout+0xa9>
  80852c:	3b 70 04             	cmp    0x4(%eax),%esi
  80852f:	73 ea                	jae    80851b <sys_timeout+0x91>
  808531:	eb 1b                	jmp    80854e <sys_timeout+0xc4>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
        }
        timeout->next = t->next;
  808533:	8b 02                	mov    (%edx),%eax
  808535:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  808537:	89 1a                	mov    %ebx,(%edx)
  808539:	eb 18                	jmp    808553 <sys_timeout+0xc9>
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  80853b:	8b 73 04             	mov    0x4(%ebx),%esi
  80853e:	29 ce                	sub    %ecx,%esi
  808540:	89 73 04             	mov    %esi,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  808543:	8b 02                	mov    (%edx),%eax
  808545:	85 c0                	test   %eax,%eax
  808547:	74 ea                	je     808533 <sys_timeout+0xa9>
  808549:	3b 70 04             	cmp    0x4(%eax),%esi
  80854c:	73 cd                	jae    80851b <sys_timeout+0x91>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  80854e:	29 70 04             	sub    %esi,0x4(%eax)
  808551:	eb e0                	jmp    808533 <sys_timeout+0xa9>
        t->next = timeout;
        break;
      }
    }
  }
}
  808553:	83 c4 10             	add    $0x10,%esp
  808556:	5b                   	pop    %ebx
  808557:	5e                   	pop    %esi
  808558:	5d                   	pop    %ebp
  808559:	c3                   	ret    

0080855a <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  80855a:	55                   	push   %ebp
  80855b:	89 e5                	mov    %esp,%ebp
  80855d:	57                   	push   %edi
  80855e:	56                   	push   %esi
  80855f:	53                   	push   %ebx
  808560:	83 ec 1c             	sub    $0x1c,%esp
  808563:	8b 7d 08             	mov    0x8(%ebp),%edi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  808566:	e8 c2 50 00 00       	call   80d62d <sys_arch_timeouts>
  80856b:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  80856d:	85 c0                	test   %eax,%eax
  80856f:	74 06                	je     808577 <sys_sem_wait+0x1d>
  808571:	8b 00                	mov    (%eax),%eax
  808573:	85 c0                	test   %eax,%eax
  808575:	75 12                	jne    808589 <sys_sem_wait+0x2f>
    sys_arch_sem_wait(sem, 0);
  808577:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80857e:	00 
  80857f:	89 3c 24             	mov    %edi,(%esp)
  808582:	e8 df 52 00 00       	call   80d866 <sys_arch_sem_wait>

 again:

  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
  808587:	eb 58                	jmp    8085e1 <sys_sem_wait+0x87>
    sys_arch_sem_wait(sem, 0);
  } else {
    if (timeouts->next->time > 0) {
  808589:	8b 40 04             	mov    0x4(%eax),%eax
  80858c:	85 c0                	test   %eax,%eax
  80858e:	74 11                	je     8085a1 <sys_sem_wait+0x47>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  808590:	89 44 24 04          	mov    %eax,0x4(%esp)
  808594:	89 3c 24             	mov    %edi,(%esp)
  808597:	e8 ca 52 00 00       	call   80d866 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80859c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80859f:	75 29                	jne    8085ca <sys_sem_wait+0x70>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  8085a1:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8085a3:	8b 10                	mov    (%eax),%edx
  8085a5:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  8085a7:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8085aa:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8085ad:	89 44 24 04          	mov    %eax,0x4(%esp)
  8085b1:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8085b8:	e8 23 f1 ff ff       	call   8076e0 <memp_free>
      if (h != NULL) {
  8085bd:	85 db                	test   %ebx,%ebx
  8085bf:	74 a5                	je     808566 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  8085c1:	89 34 24             	mov    %esi,(%esp)
  8085c4:	ff d3                	call   *%ebx
  8085c6:	66 90                	xchg   %ax,%ax
  8085c8:	eb 9c                	jmp    808566 <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8085ca:	8b 13                	mov    (%ebx),%edx
  8085cc:	8b 4a 04             	mov    0x4(%edx),%ecx
  8085cf:	39 c8                	cmp    %ecx,%eax
  8085d1:	73 07                	jae    8085da <sys_sem_wait+0x80>
        timeouts->next->time -= time_needed;
  8085d3:	29 c1                	sub    %eax,%ecx
  8085d5:	89 4a 04             	mov    %ecx,0x4(%edx)
  8085d8:	eb 07                	jmp    8085e1 <sys_sem_wait+0x87>
      } else {
        timeouts->next->time = 0;
  8085da:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  8085e1:	83 c4 1c             	add    $0x1c,%esp
  8085e4:	5b                   	pop    %ebx
  8085e5:	5e                   	pop    %esi
  8085e6:	5f                   	pop    %edi
  8085e7:	5d                   	pop    %ebp
  8085e8:	c3                   	ret    

008085e9 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8085e9:	55                   	push   %ebp
  8085ea:	89 e5                	mov    %esp,%ebp
  8085ec:	83 ec 28             	sub    $0x28,%esp
  8085ef:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  8085f2:	8d 55 08             	lea    0x8(%ebp),%edx
  8085f5:	89 55 f4             	mov    %edx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  8085f8:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  8085fe:	85 c0                	test   %eax,%eax
  808600:	74 17                	je     808619 <sys_sem_wait_timeout+0x30>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  808602:	8d 55 f0             	lea    -0x10(%ebp),%edx
  808605:	89 54 24 08          	mov    %edx,0x8(%esp)
  808609:	c7 44 24 04 e0 83 80 	movl   $0x8083e0,0x4(%esp)
  808610:	00 
  808611:	89 04 24             	mov    %eax,(%esp)
  808614:	e8 71 fe ff ff       	call   80848a <sys_timeout>
  }
  sys_sem_wait(sem);
  808619:	8b 45 08             	mov    0x8(%ebp),%eax
  80861c:	89 04 24             	mov    %eax,(%esp)
  80861f:	e8 36 ff ff ff       	call   80855a <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  808624:	b8 00 00 00 00       	mov    $0x0,%eax
  808629:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  80862e:	75 18                	jne    808648 <sys_sem_wait_timeout+0x5f>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  808630:	8d 45 f0             	lea    -0x10(%ebp),%eax
  808633:	89 44 24 04          	mov    %eax,0x4(%esp)
  808637:	c7 04 24 e0 83 80 00 	movl   $0x8083e0,(%esp)
  80863e:	e8 ba fd ff ff       	call   8083fd <sys_untimeout>
  808643:	b8 01 00 00 00       	mov    $0x1,%eax
    return 1;
  }
}
  808648:	c9                   	leave  
  808649:	c3                   	ret    

0080864a <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80864a:	55                   	push   %ebp
  80864b:	89 e5                	mov    %esp,%ebp
  80864d:	53                   	push   %ebx
  80864e:	83 ec 14             	sub    $0x14,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  808651:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  808658:	e8 58 53 00 00       	call   80d9b5 <sys_sem_new>
  80865d:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  80865f:	8b 45 08             	mov    0x8(%ebp),%eax
  808662:	89 44 24 04          	mov    %eax,0x4(%esp)
  808666:	89 1c 24             	mov    %ebx,(%esp)
  808669:	e8 7b ff ff ff       	call   8085e9 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  80866e:	89 1c 24             	mov    %ebx,(%esp)
  808671:	e8 8d 4e 00 00       	call   80d503 <sys_sem_free>
}
  808676:	83 c4 14             	add    $0x14,%esp
  808679:	5b                   	pop    %ebx
  80867a:	5d                   	pop    %ebp
  80867b:	c3                   	ret    

0080867c <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80867c:	55                   	push   %ebp
  80867d:	89 e5                	mov    %esp,%ebp
  80867f:	57                   	push   %edi
  808680:	56                   	push   %esi
  808681:	53                   	push   %ebx
  808682:	83 ec 1c             	sub    $0x1c,%esp
  808685:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  808688:	e8 a0 4f 00 00       	call   80d62d <sys_arch_timeouts>
  80868d:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  80868f:	85 c0                	test   %eax,%eax
  808691:	74 06                	je     808699 <sys_mbox_fetch+0x1d>
  808693:	8b 00                	mov    (%eax),%eax
  808695:	85 c0                	test   %eax,%eax
  808697:	75 19                	jne    8086b2 <sys_mbox_fetch+0x36>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  808699:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8086a0:	00 
  8086a1:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8086a5:	8b 45 08             	mov    0x8(%ebp),%eax
  8086a8:	89 04 24             	mov    %eax,(%esp)
  8086ab:	e8 1e 55 00 00       	call   80dbce <sys_arch_mbox_fetch>
  void *arg;

 again:
  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
  8086b0:	eb 5f                	jmp    808711 <sys_mbox_fetch+0x95>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  8086b2:	8b 40 04             	mov    0x4(%eax),%eax
  8086b5:	85 c0                	test   %eax,%eax
  8086b7:	74 18                	je     8086d1 <sys_mbox_fetch+0x55>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  8086b9:	89 44 24 08          	mov    %eax,0x8(%esp)
  8086bd:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8086c1:	8b 45 08             	mov    0x8(%ebp),%eax
  8086c4:	89 04 24             	mov    %eax,(%esp)
  8086c7:	e8 02 55 00 00       	call   80dbce <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  8086cc:	83 f8 ff             	cmp    $0xffffffff,%eax
  8086cf:	75 29                	jne    8086fa <sys_mbox_fetch+0x7e>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  8086d1:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8086d3:	8b 10                	mov    (%eax),%edx
  8086d5:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  8086d7:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8086da:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8086dd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8086e1:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8086e8:	e8 f3 ef ff ff       	call   8076e0 <memp_free>
      if (h != NULL) {
  8086ed:	85 db                	test   %ebx,%ebx
  8086ef:	74 97                	je     808688 <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  8086f1:	89 34 24             	mov    %esi,(%esp)
  8086f4:	ff d3                	call   *%ebx
  8086f6:	66 90                	xchg   %ax,%ax
  8086f8:	eb 8e                	jmp    808688 <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8086fa:	8b 13                	mov    (%ebx),%edx
  8086fc:	8b 4a 04             	mov    0x4(%edx),%ecx
  8086ff:	39 c8                	cmp    %ecx,%eax
  808701:	73 07                	jae    80870a <sys_mbox_fetch+0x8e>
        timeouts->next->time -= time_needed;
  808703:	29 c1                	sub    %eax,%ecx
  808705:	89 4a 04             	mov    %ecx,0x4(%edx)
  808708:	eb 07                	jmp    808711 <sys_mbox_fetch+0x95>
      } else {
        timeouts->next->time = 0;
  80870a:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  808711:	83 c4 1c             	add    $0x1c,%esp
  808714:	5b                   	pop    %ebx
  808715:	5e                   	pop    %esi
  808716:	5f                   	pop    %edi
  808717:	5d                   	pop    %ebp
  808718:	c3                   	ret    
  808719:	00 00                	add    %al,(%eax)
  80871b:	00 00                	add    %al,(%eax)
  80871d:	00 00                	add    %al,(%eax)
	...

00808720 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  808720:	55                   	push   %ebp
  808721:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  808723:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  808728:	5d                   	pop    %ebp
  808729:	c3                   	ret    

0080872a <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80872a:	55                   	push   %ebp
  80872b:	89 e5                	mov    %esp,%ebp
  80872d:	57                   	push   %edi
  80872e:	56                   	push   %esi
  80872f:	53                   	push   %ebx
  808730:	83 ec 04             	sub    $0x4,%esp
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808733:	8b 0d 0c f0 b3 00    	mov    0xb3f00c,%ecx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808739:	8b 1d 20 f0 b3 00    	mov    0xb3f020,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80873f:	8b 35 14 f0 b3 00    	mov    0xb3f014,%esi
  808745:	0f b7 15 48 50 81 00 	movzwl 0x815048,%edx
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80874c:	bf 00 10 00 00       	mov    $0x1000,%edi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  808751:	89 75 f0             	mov    %esi,-0x10(%ebp)
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  808754:	66 83 c2 01          	add    $0x1,%dx
  808758:	79 02                	jns    80875c <tcp_new_port+0x32>
  80875a:	89 fa                	mov    %edi,%edx
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80875c:	85 c9                	test   %ecx,%ecx
  80875e:	74 19                	je     808779 <tcp_new_port+0x4f>
    if (pcb->local_port == port) {
  808760:	89 c8                	mov    %ecx,%eax
  808762:	66 3b 51 1c          	cmp    0x1c(%ecx),%dx
  808766:	75 0a                	jne    808772 <tcp_new_port+0x48>
  808768:	eb ea                	jmp    808754 <tcp_new_port+0x2a>
  80876a:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  80876e:	66 90                	xchg   %ax,%ax
  808770:	74 e2                	je     808754 <tcp_new_port+0x2a>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808772:	8b 40 0c             	mov    0xc(%eax),%eax
  808775:	85 c0                	test   %eax,%eax
  808777:	75 f1                	jne    80876a <tcp_new_port+0x40>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808779:	85 db                	test   %ebx,%ebx
  80877b:	74 1c                	je     808799 <tcp_new_port+0x6f>
    if (pcb->local_port == port) {
  80877d:	89 d8                	mov    %ebx,%eax
  80877f:	66 3b 53 1c          	cmp    0x1c(%ebx),%dx
  808783:	75 0d                	jne    808792 <tcp_new_port+0x68>
  808785:	eb cd                	jmp    808754 <tcp_new_port+0x2a>
  808787:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  80878b:	90                   	nop
  80878c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  808790:	74 c2                	je     808754 <tcp_new_port+0x2a>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808792:	8b 40 0c             	mov    0xc(%eax),%eax
  808795:	85 c0                	test   %eax,%eax
  808797:	75 ee                	jne    808787 <tcp_new_port+0x5d>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  808799:	85 f6                	test   %esi,%esi
  80879b:	75 09                	jne    8087a6 <tcp_new_port+0x7c>
  80879d:	66 89 15 48 50 81 00 	mov    %dx,0x815048
  8087a4:	eb 23                	jmp    8087c9 <tcp_new_port+0x9f>
    if (pcb->local_port == port) {
  8087a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8087a9:	66 3b 56 1c          	cmp    0x1c(%esi),%dx
  8087ad:	75 09                	jne    8087b8 <tcp_new_port+0x8e>
  8087af:	90                   	nop
  8087b0:	eb a2                	jmp    808754 <tcp_new_port+0x2a>
  8087b2:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  8087b6:	74 9c                	je     808754 <tcp_new_port+0x2a>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8087b8:	8b 40 0c             	mov    0xc(%eax),%eax
  8087bb:	85 c0                	test   %eax,%eax
  8087bd:	8d 76 00             	lea    0x0(%esi),%esi
  8087c0:	75 f0                	jne    8087b2 <tcp_new_port+0x88>
  8087c2:	66 89 15 48 50 81 00 	mov    %dx,0x815048
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  8087c9:	0f b7 05 48 50 81 00 	movzwl 0x815048,%eax
  8087d0:	83 c4 04             	add    $0x4,%esp
  8087d3:	5b                   	pop    %ebx
  8087d4:	5e                   	pop    %esi
  8087d5:	5f                   	pop    %edi
  8087d6:	5d                   	pop    %ebp
  8087d7:	c3                   	ret    

008087d8 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8087d8:	55                   	push   %ebp
  8087d9:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  8087db:	8b 55 0c             	mov    0xc(%ebp),%edx
  8087de:	8b 45 08             	mov    0x8(%ebp),%eax
  8087e1:	88 50 14             	mov    %dl,0x14(%eax)
}
  8087e4:	5d                   	pop    %ebp
  8087e5:	c3                   	ret    

008087e6 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8087e6:	55                   	push   %ebp
  8087e7:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  8087e9:	8b 55 0c             	mov    0xc(%ebp),%edx
  8087ec:	8b 45 08             	mov    0x8(%ebp),%eax
  8087ef:	89 50 18             	mov    %edx,0x18(%eax)
}
  8087f2:	5d                   	pop    %ebp
  8087f3:	c3                   	ret    

008087f4 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  8087f4:	55                   	push   %ebp
  8087f5:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  8087f7:	8b 55 0c             	mov    0xc(%ebp),%edx
  8087fa:	8b 45 08             	mov    0x8(%ebp),%eax
  8087fd:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  808803:	5d                   	pop    %ebp
  808804:	c3                   	ret    

00808805 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  808805:	55                   	push   %ebp
  808806:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  808808:	8b 55 0c             	mov    0xc(%ebp),%edx
  80880b:	8b 45 08             	mov    0x8(%ebp),%eax
  80880e:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  808814:	5d                   	pop    %ebp
  808815:	c3                   	ret    

00808816 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  808816:	55                   	push   %ebp
  808817:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  808819:	8b 55 0c             	mov    0xc(%ebp),%edx
  80881c:	8b 45 08             	mov    0x8(%ebp),%eax
  80881f:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  808825:	5d                   	pop    %ebp
  808826:	c3                   	ret    

00808827 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  808827:	55                   	push   %ebp
  808828:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  80882a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80882d:	8b 45 08             	mov    0x8(%ebp),%eax
  808830:	89 50 20             	mov    %edx,0x20(%eax)
}
  808833:	5d                   	pop    %ebp
  808834:	c3                   	ret    

00808835 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  808835:	55                   	push   %ebp
  808836:	89 e5                	mov    %esp,%ebp
  808838:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  80883b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80883e:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  808844:	8b 55 10             	mov    0x10(%ebp),%edx
  808847:	88 50 31             	mov    %dl,0x31(%eax)
}
  80884a:	5d                   	pop    %ebp
  80884b:	c3                   	ret    

0080884c <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  80884c:	55                   	push   %ebp
  80884d:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  80884f:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  808854:	03 05 44 50 81 00    	add    0x815044,%eax
  80885a:	a3 44 50 81 00       	mov    %eax,0x815044
  return iss;
}
  80885f:	5d                   	pop    %ebp
  808860:	c3                   	ret    

00808861 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  808861:	55                   	push   %ebp
  808862:	89 e5                	mov    %esp,%ebp
  808864:	53                   	push   %ebx
  808865:	83 ec 14             	sub    $0x14,%esp
  808868:	0f b7 5d 08          	movzwl 0x8(%ebp),%ebx
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  80886c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80886f:	89 04 24             	mov    %eax,(%esp)
  808872:	e8 ea 11 00 00       	call   809a61 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  808877:	85 c0                	test   %eax,%eax
  808879:	74 13                	je     80888e <tcp_eff_send_mss+0x2d>
  80887b:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  80887f:	66 85 c0             	test   %ax,%ax
  808882:	74 0a                	je     80888e <tcp_eff_send_mss+0x2d>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  808884:	83 e8 28             	sub    $0x28,%eax
  808887:	66 39 c3             	cmp    %ax,%bx
  80888a:	76 02                	jbe    80888e <tcp_eff_send_mss+0x2d>
  80888c:	89 c3                	mov    %eax,%ebx
  }
  return sendmss;
}
  80888e:	89 d8                	mov    %ebx,%eax
  808890:	83 c4 14             	add    $0x14,%esp
  808893:	5b                   	pop    %ebx
  808894:	5d                   	pop    %ebp
  808895:	c3                   	ret    

00808896 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  808896:	55                   	push   %ebp
  808897:	89 e5                	mov    %esp,%ebp
  808899:	83 ec 18             	sub    $0x18,%esp
  80889c:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80889f:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8088a2:	8b 45 08             	mov    0x8(%ebp),%eax
  8088a5:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  8088a9:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  8088ad:	0f b7 f1             	movzwl %cx,%esi
  8088b0:	0f b7 da             	movzwl %dx,%ebx
  8088b3:	8d 1c 1e             	lea    (%esi,%ebx,1),%ebx
  8088b6:	81 fb c0 5d 00 00    	cmp    $0x5dc0,%ebx
  8088bc:	76 0e                	jbe    8088cc <tcp_recved+0x36>
    pcb->rcv_wnd = TCP_WND;
  8088be:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  8088c4:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  8088ca:	eb 11                	jmp    8088dd <tcp_recved+0x47>
  } else {
    pcb->rcv_wnd += len;
  8088cc:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  8088cf:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  8088d3:	66 3b 50 34          	cmp    0x34(%eax),%dx
  8088d7:	72 04                	jb     8088dd <tcp_recved+0x47>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  8088d9:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  8088dd:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  8088e1:	f6 c2 03             	test   $0x3,%dl
  8088e4:	75 20                	jne    808906 <tcp_recved+0x70>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  8088e6:	f6 c2 01             	test   $0x1,%dl
  8088e9:	74 13                	je     8088fe <tcp_recved+0x68>
  8088eb:	83 e2 fe             	and    $0xfffffffe,%edx
  8088ee:	83 ca 02             	or     $0x2,%edx
  8088f1:	88 50 20             	mov    %dl,0x20(%eax)
  8088f4:	89 04 24             	mov    %eax,(%esp)
  8088f7:	e8 ff 29 00 00       	call   80b2fb <tcp_output>
  8088fc:	eb 23                	jmp    808921 <tcp_recved+0x8b>
  8088fe:	83 ca 01             	or     $0x1,%edx
  808901:	88 50 20             	mov    %dl,0x20(%eax)
  808904:	eb 1b                	jmp    808921 <tcp_recved+0x8b>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  808906:	f6 c2 01             	test   $0x1,%dl
  808909:	74 16                	je     808921 <tcp_recved+0x8b>
  80890b:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  808911:	76 0e                	jbe    808921 <tcp_recved+0x8b>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  808913:	83 ca 02             	or     $0x2,%edx
  808916:	88 50 20             	mov    %dl,0x20(%eax)
  808919:	89 04 24             	mov    %eax,(%esp)
  80891c:	e8 da 29 00 00       	call   80b2fb <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  808921:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  808924:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808927:	89 ec                	mov    %ebp,%esp
  808929:	5d                   	pop    %ebp
  80892a:	c3                   	ret    

0080892b <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  80892b:	55                   	push   %ebp
  80892c:	89 e5                	mov    %esp,%ebp
  80892e:	53                   	push   %ebx
  80892f:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808932:	8b 1d 0c f0 b3 00    	mov    0xb3f00c,%ebx
  808938:	85 db                	test   %ebx,%ebx
  80893a:	74 6c                	je     8089a8 <tcp_fasttmr+0x7d>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80893c:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  808942:	85 c0                	test   %eax,%eax
  808944:	74 41                	je     808987 <tcp_fasttmr+0x5c>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  808946:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80894c:	85 d2                	test   %edx,%edx
  80894e:	74 1e                	je     80896e <tcp_fasttmr+0x43>
  808950:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  808957:	00 
  808958:	89 44 24 08          	mov    %eax,0x8(%esp)
  80895c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808960:	8b 43 18             	mov    0x18(%ebx),%eax
  808963:	89 04 24             	mov    %eax,(%esp)
  808966:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  808968:	84 c0                	test   %al,%al
  80896a:	75 1b                	jne    808987 <tcp_fasttmr+0x5c>
  80896c:	eb 0f                	jmp    80897d <tcp_fasttmr+0x52>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80896e:	89 04 24             	mov    %eax,(%esp)
  808971:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  808978:	e8 fb f4 ff ff       	call   807e78 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80897d:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  808984:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  808987:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  80898b:	a8 01                	test   $0x1,%al
  80898d:	74 12                	je     8089a1 <tcp_fasttmr+0x76>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  80898f:	83 c8 02             	or     $0x2,%eax
  808992:	88 43 20             	mov    %al,0x20(%ebx)
  808995:	89 1c 24             	mov    %ebx,(%esp)
  808998:	e8 5e 29 00 00       	call   80b2fb <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80899d:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8089a1:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  8089a4:	85 db                	test   %ebx,%ebx
  8089a6:	75 94                	jne    80893c <tcp_fasttmr+0x11>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  8089a8:	83 c4 14             	add    $0x14,%esp
  8089ab:	5b                   	pop    %ebx
  8089ac:	5d                   	pop    %ebp
  8089ad:	c3                   	ret    

008089ae <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  8089ae:	55                   	push   %ebp
  8089af:	89 e5                	mov    %esp,%ebp
  8089b1:	53                   	push   %ebx
  8089b2:	83 ec 14             	sub    $0x14,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  8089b5:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  8089bc:	e8 63 ed ff ff       	call   807724 <memp_malloc>
  8089c1:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  8089c3:	85 c0                	test   %eax,%eax
  8089c5:	74 22                	je     8089e9 <tcp_seg_copy+0x3b>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  8089c7:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8089ce:	00 
  8089cf:	8b 45 08             	mov    0x8(%ebp),%eax
  8089d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8089d6:	89 1c 24             	mov    %ebx,(%esp)
  8089d9:	e8 53 8c ff ff       	call   801631 <memcpy>
  pbuf_ref(cseg->p);
  8089de:	8b 43 04             	mov    0x4(%ebx),%eax
  8089e1:	89 04 24             	mov    %eax,(%esp)
  8089e4:	e8 41 f0 ff ff       	call   807a2a <pbuf_ref>
  return cseg;
}
  8089e9:	89 d8                	mov    %ebx,%eax
  8089eb:	83 c4 14             	add    $0x14,%esp
  8089ee:	5b                   	pop    %ebx
  8089ef:	5d                   	pop    %ebp
  8089f0:	c3                   	ret    

008089f1 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  8089f1:	55                   	push   %ebp
  8089f2:	89 e5                	mov    %esp,%ebp
  8089f4:	83 ec 18             	sub    $0x18,%esp
  8089f7:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8089fa:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8089fd:	8b 75 08             	mov    0x8(%ebp),%esi
  u8_t count = 0;
  
  if (seg != NULL) {
  808a00:	bb 00 00 00 00       	mov    $0x0,%ebx
  808a05:	85 f6                	test   %esi,%esi
  808a07:	74 21                	je     808a2a <tcp_seg_free+0x39>
    if (seg->p != NULL) {
  808a09:	8b 46 04             	mov    0x4(%esi),%eax
  808a0c:	85 c0                	test   %eax,%eax
  808a0e:	74 0a                	je     808a1a <tcp_seg_free+0x29>
      count = pbuf_free(seg->p);
  808a10:	89 04 24             	mov    %eax,(%esp)
  808a13:	e8 60 f4 ff ff       	call   807e78 <pbuf_free>
  808a18:	89 c3                	mov    %eax,%ebx
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  808a1a:	89 74 24 04          	mov    %esi,0x4(%esp)
  808a1e:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808a25:	e8 b6 ec ff ff       	call   8076e0 <memp_free>
  }
  return count;
}
  808a2a:	89 d8                	mov    %ebx,%eax
  808a2c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  808a2f:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808a32:	89 ec                	mov    %ebp,%esp
  808a34:	5d                   	pop    %ebp
  808a35:	c3                   	ret    

00808a36 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  808a36:	55                   	push   %ebp
  808a37:	89 e5                	mov    %esp,%ebp
  808a39:	56                   	push   %esi
  808a3a:	53                   	push   %ebx
  808a3b:	83 ec 10             	sub    $0x10,%esp
  808a3e:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  808a41:	be 00 00 00 00       	mov    $0x0,%esi
  808a46:	85 c0                	test   %eax,%eax
  808a48:	74 14                	je     808a5e <tcp_segs_free+0x28>
    next = seg->next;
  808a4a:	8b 18                	mov    (%eax),%ebx
    count += tcp_seg_free(seg);
  808a4c:	89 04 24             	mov    %eax,(%esp)
  808a4f:	e8 9d ff ff ff       	call   8089f1 <tcp_seg_free>
  808a54:	01 c6                	add    %eax,%esi
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  808a56:	85 db                	test   %ebx,%ebx
  808a58:	74 04                	je     808a5e <tcp_segs_free+0x28>
  808a5a:	89 d8                	mov    %ebx,%eax
  808a5c:	eb ec                	jmp    808a4a <tcp_segs_free+0x14>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  808a5e:	89 f0                	mov    %esi,%eax
  808a60:	83 c4 10             	add    $0x10,%esp
  808a63:	5b                   	pop    %ebx
  808a64:	5e                   	pop    %esi
  808a65:	5d                   	pop    %ebp
  808a66:	c3                   	ret    

00808a67 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  808a67:	55                   	push   %ebp
  808a68:	89 e5                	mov    %esp,%ebp
  808a6a:	53                   	push   %ebx
  808a6b:	83 ec 14             	sub    $0x14,%esp
  808a6e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
  808a71:	8b 43 10             	mov    0x10(%ebx),%eax
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
  808a74:	85 c0                	test   %eax,%eax
  808a76:	74 62                	je     808ada <tcp_pcb_purge+0x73>
  808a78:	83 f8 0a             	cmp    $0xa,%eax
  808a7b:	74 5d                	je     808ada <tcp_pcb_purge+0x73>
  808a7d:	83 f8 01             	cmp    $0x1,%eax
  808a80:	74 58                	je     808ada <tcp_pcb_purge+0x73>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  808a82:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  808a88:	85 c0                	test   %eax,%eax
  808a8a:	74 12                	je     808a9e <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  808a8c:	89 04 24             	mov    %eax,(%esp)
  808a8f:	e8 e4 f3 ff ff       	call   807e78 <pbuf_free>
      pcb->refused_data = NULL;
  808a94:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  808a9b:	00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  808a9e:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  808aa4:	8b 43 7c             	mov    0x7c(%ebx),%eax
  808aa7:	89 04 24             	mov    %eax,(%esp)
  808aaa:	e8 87 ff ff ff       	call   808a36 <tcp_segs_free>
    pcb->ooseq = NULL;
  808aaf:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  808ab6:	8b 43 74             	mov    0x74(%ebx),%eax
  808ab9:	89 04 24             	mov    %eax,(%esp)
  808abc:	e8 75 ff ff ff       	call   808a36 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  808ac1:	8b 43 78             	mov    0x78(%ebx),%eax
  808ac4:	89 04 24             	mov    %eax,(%esp)
  808ac7:	e8 6a ff ff ff       	call   808a36 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  808acc:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  808ad3:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  }
}
  808ada:	83 c4 14             	add    $0x14,%esp
  808add:	5b                   	pop    %ebx
  808ade:	5d                   	pop    %ebp
  808adf:	c3                   	ret    

00808ae0 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  808ae0:	55                   	push   %ebp
  808ae1:	89 e5                	mov    %esp,%ebp
  808ae3:	53                   	push   %ebx
  808ae4:	83 ec 14             	sub    $0x14,%esp
  808ae7:	8b 45 08             	mov    0x8(%ebp),%eax
  808aea:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  808aed:	8b 10                	mov    (%eax),%edx
  808aef:	39 da                	cmp    %ebx,%edx
  808af1:	75 07                	jne    808afa <tcp_pcb_remove+0x1a>
  808af3:	8b 52 0c             	mov    0xc(%edx),%edx
  808af6:	89 10                	mov    %edx,(%eax)
  808af8:	eb 2a                	jmp    808b24 <tcp_pcb_remove+0x44>
  808afa:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  808b00:	85 d2                	test   %edx,%edx
  808b02:	74 20                	je     808b24 <tcp_pcb_remove+0x44>
  808b04:	8b 42 0c             	mov    0xc(%edx),%eax
  808b07:	85 c0                	test   %eax,%eax
  808b09:	0f 84 c0 00 00 00    	je     808bcf <tcp_pcb_remove+0xef>
  808b0f:	39 c3                	cmp    %eax,%ebx
  808b11:	75 08                	jne    808b1b <tcp_pcb_remove+0x3b>
  808b13:	8b 43 0c             	mov    0xc(%ebx),%eax
  808b16:	89 42 0c             	mov    %eax,0xc(%edx)
  808b19:	eb 09                	jmp    808b24 <tcp_pcb_remove+0x44>
  808b1b:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  808b20:	89 c2                	mov    %eax,%edx
  808b22:	eb e0                	jmp    808b04 <tcp_pcb_remove+0x24>
  808b24:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  808b2b:	89 1c 24             	mov    %ebx,(%esp)
  808b2e:	e8 34 ff ff ff       	call   808a67 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  808b33:	8b 43 10             	mov    0x10(%ebx),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  808b36:	83 f8 0a             	cmp    $0xa,%eax
  808b39:	74 1b                	je     808b56 <tcp_pcb_remove+0x76>
  808b3b:	83 f8 01             	cmp    $0x1,%eax
  808b3e:	74 16                	je     808b56 <tcp_pcb_remove+0x76>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  808b40:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  808b44:	a8 01                	test   $0x1,%al
  808b46:	74 0e                	je     808b56 <tcp_pcb_remove+0x76>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  808b48:	83 c8 02             	or     $0x2,%eax
  808b4b:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  808b4e:	89 1c 24             	mov    %ebx,(%esp)
  808b51:	e8 a5 27 00 00       	call   80b2fb <tcp_output>
  }

  if (pcb->state != LISTEN) {
  808b56:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  808b5a:	74 66                	je     808bc2 <tcp_pcb_remove+0xe2>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  808b5c:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  808b60:	74 1c                	je     808b7e <tcp_pcb_remove+0x9e>
  808b62:	c7 44 24 08 b7 38 81 	movl   $0x8138b7,0x8(%esp)
  808b69:	00 
  808b6a:	c7 44 24 04 b4 04 00 	movl   $0x4b4,0x4(%esp)
  808b71:	00 
  808b72:	c7 04 24 cf 38 81 00 	movl   $0x8138cf,(%esp)
  808b79:	e8 6a 7e ff ff       	call   8009e8 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  808b7e:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  808b82:	74 1c                	je     808ba0 <tcp_pcb_remove+0xc0>
  808b84:	c7 44 24 08 e3 38 81 	movl   $0x8138e3,0x8(%esp)
  808b8b:	00 
  808b8c:	c7 44 24 04 b5 04 00 	movl   $0x4b5,0x4(%esp)
  808b93:	00 
  808b94:	c7 04 24 cf 38 81 00 	movl   $0x8138cf,(%esp)
  808b9b:	e8 48 7e ff ff       	call   8009e8 <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  808ba0:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  808ba4:	74 1c                	je     808bc2 <tcp_pcb_remove+0xe2>
  808ba6:	c7 44 24 08 fc 38 81 	movl   $0x8138fc,0x8(%esp)
  808bad:	00 
  808bae:	c7 44 24 04 b7 04 00 	movl   $0x4b7,0x4(%esp)
  808bb5:	00 
  808bb6:	c7 04 24 cf 38 81 00 	movl   $0x8138cf,(%esp)
  808bbd:	e8 26 7e ff ff       	call   8009e8 <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  808bc2:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  808bc9:	83 c4 14             	add    $0x14,%esp
  808bcc:	5b                   	pop    %ebx
  808bcd:	5d                   	pop    %ebp
  808bce:	c3                   	ret    
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
  808bcf:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  808bd4:	e9 4b ff ff ff       	jmp    808b24 <tcp_pcb_remove+0x44>

00808bd9 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  808bd9:	55                   	push   %ebp
  808bda:	89 e5                	mov    %esp,%ebp
  808bdc:	83 ec 18             	sub    $0x18,%esp
  808bdf:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  808be2:	89 75 fc             	mov    %esi,-0x4(%ebp)
  808be5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  808be8:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  808bec:	74 1c                	je     808c0a <tcp_listen_with_backlog+0x31>
  808bee:	c7 44 24 08 14 39 81 	movl   $0x813914,0x8(%esp)
  808bf5:	00 
  808bf6:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  808bfd:	00 
  808bfe:	c7 04 24 cf 38 81 00 	movl   $0x8138cf,(%esp)
  808c05:	e8 de 7d ff ff       	call   8009e8 <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  808c0a:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  808c11:	e8 0e eb ff ff       	call   807724 <memp_malloc>
  808c16:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  808c18:	b8 00 00 00 00       	mov    $0x0,%eax
  808c1d:	85 f6                	test   %esi,%esi
  808c1f:	0f 84 a8 00 00 00    	je     808ccd <tcp_listen_with_backlog+0xf4>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  808c25:	8b 43 18             	mov    0x18(%ebx),%eax
  808c28:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  808c2b:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  808c2f:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  808c33:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  808c3a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808c3e:	83 c8 02             	or     $0x2,%eax
  808c41:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  808c45:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  808c49:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  808c4c:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  808c50:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  808c53:	b8 00 00 00 00       	mov    $0x0,%eax
  808c58:	85 db                	test   %ebx,%ebx
  808c5a:	74 02                	je     808c5e <tcp_listen_with_backlog+0x85>
  808c5c:	8b 03                	mov    (%ebx),%eax
  808c5e:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808c60:	8b 15 1c f0 b3 00    	mov    0xb3f01c,%edx
  808c66:	39 da                	cmp    %ebx,%edx
  808c68:	75 0a                	jne    808c74 <tcp_listen_with_backlog+0x9b>
  808c6a:	8b 42 0c             	mov    0xc(%edx),%eax
  808c6d:	a3 1c f0 b3 00       	mov    %eax,0xb3f01c
  808c72:	eb 26                	jmp    808c9a <tcp_listen_with_backlog+0xc1>
  808c74:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  808c7a:	85 d2                	test   %edx,%edx
  808c7c:	74 1c                	je     808c9a <tcp_listen_with_backlog+0xc1>
  808c7e:	8b 42 0c             	mov    0xc(%edx),%eax
  808c81:	85 c0                	test   %eax,%eax
  808c83:	74 52                	je     808cd7 <tcp_listen_with_backlog+0xfe>
  808c85:	39 c3                	cmp    %eax,%ebx
  808c87:	75 08                	jne    808c91 <tcp_listen_with_backlog+0xb8>
  808c89:	8b 43 0c             	mov    0xc(%ebx),%eax
  808c8c:	89 42 0c             	mov    %eax,0xc(%edx)
  808c8f:	eb 09                	jmp    808c9a <tcp_listen_with_backlog+0xc1>
  808c91:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  808c96:	89 c2                	mov    %eax,%edx
  808c98:	eb e4                	jmp    808c7e <tcp_listen_with_backlog+0xa5>
  808c9a:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  808ca1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808ca5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808cac:	e8 2f ea ff ff       	call   8076e0 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  808cb1:	c7 46 20 20 87 80 00 	movl   $0x808720,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  808cb8:	a1 14 f0 b3 00       	mov    0xb3f014,%eax
  808cbd:	89 46 0c             	mov    %eax,0xc(%esi)
  808cc0:	89 35 14 f0 b3 00    	mov    %esi,0xb3f014
  808cc6:	e8 52 c2 ff ff       	call   804f1d <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  808ccb:	89 f0                	mov    %esi,%eax
}
  808ccd:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  808cd0:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808cd3:	89 ec                	mov    %ebp,%esp
  808cd5:	5d                   	pop    %ebp
  808cd6:	c3                   	ret    
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808cd7:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  808cdc:	eb bc                	jmp    808c9a <tcp_listen_with_backlog+0xc1>

00808cde <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808cde:	55                   	push   %ebp
  808cdf:	89 e5                	mov    %esp,%ebp
  808ce1:	57                   	push   %edi
  808ce2:	56                   	push   %esi
  808ce3:	53                   	push   %ebx
  808ce4:	83 ec 1c             	sub    $0x1c,%esp
  808ce7:	8b 75 08             	mov    0x8(%ebp),%esi
  808cea:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  808ced:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  808cf1:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  808cf5:	74 1c                	je     808d13 <tcp_bind+0x35>
  808cf7:	c7 44 24 08 38 39 81 	movl   $0x813938,0x8(%esp)
  808cfe:	00 
  808cff:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
  808d06:	00 
  808d07:	c7 04 24 cf 38 81 00 	movl   $0x8138cf,(%esp)
  808d0e:	e8 d5 7c ff ff       	call   8009e8 <_panic>

  if (port == 0) {
  808d13:	66 85 c0             	test   %ax,%ax
  808d16:	75 05                	jne    808d1d <tcp_bind+0x3f>
    port = tcp_new_port();
  808d18:	e8 0d fa ff ff       	call   80872a <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  808d1d:	8b 15 14 f0 b3 00    	mov    0xb3f014,%edx
  808d23:	85 d2                	test   %edx,%edx
  808d25:	74 39                	je     808d60 <tcp_bind+0x82>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  808d27:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  808d2b:	75 2c                	jne    808d59 <tcp_bind+0x7b>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808d2d:	85 d2                	test   %edx,%edx
  808d2f:	0f 84 e1 00 00 00    	je     808e16 <tcp_bind+0x138>
  808d35:	8b 0a                	mov    (%edx),%ecx
  808d37:	85 c9                	test   %ecx,%ecx
  808d39:	0f 84 d7 00 00 00    	je     808e16 <tcp_bind+0x138>
  808d3f:	85 db                	test   %ebx,%ebx
  808d41:	0f 84 cf 00 00 00    	je     808e16 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  808d47:	8b 3b                	mov    (%ebx),%edi
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808d49:	85 ff                	test   %edi,%edi
  808d4b:	0f 84 c5 00 00 00    	je     808e16 <tcp_bind+0x138>
  808d51:	39 f9                	cmp    %edi,%ecx
  808d53:	0f 84 bd 00 00 00    	je     808e16 <tcp_bind+0x138>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  808d59:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  808d5c:	85 d2                	test   %edx,%edx
  808d5e:	75 c7                	jne    808d27 <tcp_bind+0x49>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  808d60:	8b 15 0c f0 b3 00    	mov    0xb3f00c,%edx
  808d66:	85 d2                	test   %edx,%edx
  808d68:	74 35                	je     808d9f <tcp_bind+0xc1>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  808d6a:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  808d6e:	75 28                	jne    808d98 <tcp_bind+0xba>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808d70:	85 d2                	test   %edx,%edx
  808d72:	0f 84 9e 00 00 00    	je     808e16 <tcp_bind+0x138>
  808d78:	8b 0a                	mov    (%edx),%ecx
  808d7a:	85 c9                	test   %ecx,%ecx
  808d7c:	0f 84 94 00 00 00    	je     808e16 <tcp_bind+0x138>
  808d82:	85 db                	test   %ebx,%ebx
  808d84:	0f 84 8c 00 00 00    	je     808e16 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  808d8a:	8b 3b                	mov    (%ebx),%edi
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808d8c:	85 ff                	test   %edi,%edi
  808d8e:	0f 84 82 00 00 00    	je     808e16 <tcp_bind+0x138>
  808d94:	39 f9                	cmp    %edi,%ecx
  808d96:	74 7e                	je     808e16 <tcp_bind+0x138>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  808d98:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  808d9b:	85 d2                	test   %edx,%edx
  808d9d:	75 cb                	jne    808d6a <tcp_bind+0x8c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  808d9f:	8b 15 1c f0 b3 00    	mov    0xb3f01c,%edx
  808da5:	85 d2                	test   %edx,%edx
  808da7:	74 25                	je     808dce <tcp_bind+0xf0>
    if (cpcb->local_port == port) {
  808da9:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  808dad:	75 18                	jne    808dc7 <tcp_bind+0xe9>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808daf:	85 d2                	test   %edx,%edx
  808db1:	74 63                	je     808e16 <tcp_bind+0x138>
  808db3:	8b 0a                	mov    (%edx),%ecx
  808db5:	85 c9                	test   %ecx,%ecx
  808db7:	74 5d                	je     808e16 <tcp_bind+0x138>
  808db9:	85 db                	test   %ebx,%ebx
  808dbb:	74 59                	je     808e16 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  808dbd:	8b 3b                	mov    (%ebx),%edi
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808dbf:	85 ff                	test   %edi,%edi
  808dc1:	74 53                	je     808e16 <tcp_bind+0x138>
  808dc3:	39 f9                	cmp    %edi,%ecx
  808dc5:	74 4f                	je     808e16 <tcp_bind+0x138>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  808dc7:	8b 52 0c             	mov    0xc(%edx),%edx
  808dca:	85 d2                	test   %edx,%edx
  808dcc:	75 db                	jne    808da9 <tcp_bind+0xcb>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  808dce:	8b 15 20 f0 b3 00    	mov    0xb3f020,%edx
  808dd4:	85 d2                	test   %edx,%edx
  808dd6:	74 13                	je     808deb <tcp_bind+0x10d>
    if (cpcb->local_port == port) {
  808dd8:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  808ddc:	75 06                	jne    808de4 <tcp_bind+0x106>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  808dde:	8b 0a                	mov    (%edx),%ecx
  808de0:	3b 0b                	cmp    (%ebx),%ecx
  808de2:	74 32                	je     808e16 <tcp_bind+0x138>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  808de4:	8b 52 0c             	mov    0xc(%edx),%edx
  808de7:	85 d2                	test   %edx,%edx
  808de9:	75 ed                	jne    808dd8 <tcp_bind+0xfa>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  808deb:	85 db                	test   %ebx,%ebx
  808ded:	74 09                	je     808df8 <tcp_bind+0x11a>
  808def:	83 3b 00             	cmpl   $0x0,(%ebx)
  808df2:	74 04                	je     808df8 <tcp_bind+0x11a>
    pcb->local_ip = *ipaddr;
  808df4:	8b 13                	mov    (%ebx),%edx
  808df6:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  808df8:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  808dfc:	a1 1c f0 b3 00       	mov    0xb3f01c,%eax
  808e01:	89 46 0c             	mov    %eax,0xc(%esi)
  808e04:	89 35 1c f0 b3 00    	mov    %esi,0xb3f01c
  808e0a:	e8 0e c1 ff ff       	call   804f1d <tcp_timer_needed>
  808e0f:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  808e14:	eb 05                	jmp    808e1b <tcp_bind+0x13d>
  808e16:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  808e1b:	83 c4 1c             	add    $0x1c,%esp
  808e1e:	5b                   	pop    %ebx
  808e1f:	5e                   	pop    %esi
  808e20:	5f                   	pop    %edi
  808e21:	5d                   	pop    %ebp
  808e22:	c3                   	ret    

00808e23 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  808e23:	55                   	push   %ebp
  808e24:	89 e5                	mov    %esp,%ebp
  808e26:	57                   	push   %edi
  808e27:	56                   	push   %esi
  808e28:	53                   	push   %ebx
  808e29:	83 ec 3c             	sub    $0x3c,%esp
  808e2c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808e2f:	8b 7d 0c             	mov    0xc(%ebp),%edi
  808e32:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  808e36:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  808e3a:	74 1c                	je     808e58 <tcp_connect+0x35>
  808e3c:	c7 44 24 08 64 39 81 	movl   $0x813964,0x8(%esp)
  808e43:	00 
  808e44:	c7 44 24 04 ec 01 00 	movl   $0x1ec,0x4(%esp)
  808e4b:	00 
  808e4c:	c7 04 24 cf 38 81 00 	movl   $0x8138cf,(%esp)
  808e53:	e8 90 7b ff ff       	call   8009e8 <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  808e58:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  808e5d:	85 ff                	test   %edi,%edi
  808e5f:	0f 84 28 01 00 00    	je     808f8d <tcp_connect+0x16a>
    pcb->remote_ip = *ipaddr;
  808e65:	8b 17                	mov    (%edi),%edx
  808e67:	89 53 04             	mov    %edx,0x4(%ebx)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  808e6a:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  808e6e:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  808e73:	75 09                	jne    808e7e <tcp_connect+0x5b>
    pcb->local_port = tcp_new_port();
  808e75:	e8 b0 f8 ff ff       	call   80872a <tcp_new_port>
  808e7a:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  808e7e:	e8 c9 f9 ff ff       	call   80884c <tcp_next_iss>
  pcb->rcv_nxt = 0;
  808e83:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  808e8a:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  808e8d:	83 e8 01             	sub    $0x1,%eax
  808e90:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  808e93:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  808e96:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  808e9c:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  808ea2:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  808ea8:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  808eae:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808eb2:	c7 04 24 18 02 00 00 	movl   $0x218,(%esp)
  808eb9:	e8 a3 f9 ff ff       	call   808861 <tcp_eff_send_mss>
  808ebe:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  808ec2:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  808ec8:	8d 04 80             	lea    (%eax,%eax,4),%eax
  808ecb:	01 c0                	add    %eax,%eax
  808ecd:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  808ed1:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  808ed8:	8b 45 14             	mov    0x14(%ebp),%eax
  808edb:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808ee1:	8b 15 1c f0 b3 00    	mov    0xb3f01c,%edx
  808ee7:	39 da                	cmp    %ebx,%edx
  808ee9:	75 0a                	jne    808ef5 <tcp_connect+0xd2>
  808eeb:	8b 42 0c             	mov    0xc(%edx),%eax
  808eee:	a3 1c f0 b3 00       	mov    %eax,0xb3f01c
  808ef3:	eb 2a                	jmp    808f1f <tcp_connect+0xfc>
  808ef5:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  808efb:	85 d2                	test   %edx,%edx
  808efd:	74 20                	je     808f1f <tcp_connect+0xfc>
  808eff:	8b 42 0c             	mov    0xc(%edx),%eax
  808f02:	85 c0                	test   %eax,%eax
  808f04:	0f 84 8d 00 00 00    	je     808f97 <tcp_connect+0x174>
  808f0a:	39 c3                	cmp    %eax,%ebx
  808f0c:	75 08                	jne    808f16 <tcp_connect+0xf3>
  808f0e:	8b 43 0c             	mov    0xc(%ebx),%eax
  808f11:	89 42 0c             	mov    %eax,0xc(%edx)
  808f14:	eb 09                	jmp    808f1f <tcp_connect+0xfc>
  808f16:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  808f1b:	89 c2                	mov    %eax,%edx
  808f1d:	eb e0                	jmp    808eff <tcp_connect+0xdc>
  808f1f:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  TCP_REG(&tcp_active_pcbs, pcb);
  808f26:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  808f2b:	89 43 0c             	mov    %eax,0xc(%ebx)
  808f2e:	89 1d 0c f0 b3 00    	mov    %ebx,0xb3f00c
  808f34:	e8 e4 bf ff ff       	call   804f1d <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  808f39:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  808f40:	e8 50 1d 00 00       	call   80ac95 <htonl>
  808f45:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  808f48:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  808f4f:	00 
  808f50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  808f53:	89 44 24 14          	mov    %eax,0x14(%esp)
  808f57:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808f5e:	00 
  808f5f:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  808f66:	00 
  808f67:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808f6e:	00 
  808f6f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808f76:	00 
  808f77:	89 1c 24             	mov    %ebx,(%esp)
  808f7a:	e8 c9 28 00 00       	call   80b848 <tcp_enqueue>
  808f7f:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  808f81:	84 c0                	test   %al,%al
  808f83:	75 08                	jne    808f8d <tcp_connect+0x16a>
    tcp_output(pcb);
  808f85:	89 1c 24             	mov    %ebx,(%esp)
  808f88:	e8 6e 23 00 00       	call   80b2fb <tcp_output>
  }
  return ret;
} 
  808f8d:	89 f0                	mov    %esi,%eax
  808f8f:	83 c4 3c             	add    $0x3c,%esp
  808f92:	5b                   	pop    %ebx
  808f93:	5e                   	pop    %esi
  808f94:	5f                   	pop    %edi
  808f95:	5d                   	pop    %ebp
  808f96:	c3                   	ret    
  pcb->ssthresh = pcb->mss * 10;
  pcb->state = SYN_SENT;
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808f97:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  808f9c:	eb 81                	jmp    808f1f <tcp_connect+0xfc>

00808f9e <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  808f9e:	55                   	push   %ebp
  808f9f:	89 e5                	mov    %esp,%ebp
  808fa1:	57                   	push   %edi
  808fa2:	56                   	push   %esi
  808fa3:	53                   	push   %ebx
  808fa4:	83 ec 4c             	sub    $0x4c,%esp
  808fa7:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  808faa:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  808fae:	75 25                	jne    808fd5 <tcp_abort+0x37>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  808fb0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808fb4:	c7 04 24 20 f0 b3 00 	movl   $0xb3f020,(%esp)
  808fbb:	e8 20 fb ff ff       	call   808ae0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  808fc0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808fc4:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808fcb:	e8 10 e7 ff ff       	call   8076e0 <memp_free>
  808fd0:	e9 d1 00 00 00       	jmp    8090a6 <tcp_abort+0x108>
  } else {
    seqno = pcb->snd_nxt;
  808fd5:	8b 43 54             	mov    0x54(%ebx),%eax
  808fd8:	89 45 d0             	mov    %eax,-0x30(%ebp)
    ackno = pcb->rcv_nxt;
  808fdb:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  808fde:	b8 00 00 00 00       	mov    $0x0,%eax
  808fe3:	85 db                	test   %ebx,%ebx
  808fe5:	74 02                	je     808fe9 <tcp_abort+0x4b>
  808fe7:	8b 03                	mov    (%ebx),%eax
  808fe9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  808fec:	b8 00 00 00 00       	mov    $0x0,%eax
  808ff1:	83 fb fc             	cmp    $0xfffffffc,%ebx
  808ff4:	74 03                	je     808ff9 <tcp_abort+0x5b>
  808ff6:	8b 43 04             	mov    0x4(%ebx),%eax
  808ff9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  808ffc:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  809000:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    remote_port = pcb->remote_port;
  809004:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  809008:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80900c:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  809012:	8b 43 18             	mov    0x18(%ebx),%eax
  809015:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  809018:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80901c:	c7 04 24 0c f0 b3 00 	movl   $0xb3f00c,(%esp)
  809023:	e8 b8 fa ff ff       	call   808ae0 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  809028:	8b 43 78             	mov    0x78(%ebx),%eax
  80902b:	85 c0                	test   %eax,%eax
  80902d:	74 08                	je     809037 <tcp_abort+0x99>
      tcp_segs_free(pcb->unacked);
  80902f:	89 04 24             	mov    %eax,(%esp)
  809032:	e8 ff f9 ff ff       	call   808a36 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  809037:	8b 43 74             	mov    0x74(%ebx),%eax
  80903a:	85 c0                	test   %eax,%eax
  80903c:	74 08                	je     809046 <tcp_abort+0xa8>
      tcp_segs_free(pcb->unsent);
  80903e:	89 04 24             	mov    %eax,(%esp)
  809041:	e8 f0 f9 ff ff       	call   808a36 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  809046:	8b 43 7c             	mov    0x7c(%ebx),%eax
  809049:	85 c0                	test   %eax,%eax
  80904b:	74 08                	je     809055 <tcp_abort+0xb7>
      tcp_segs_free(pcb->ooseq);
  80904d:	89 04 24             	mov    %eax,(%esp)
  809050:	e8 e1 f9 ff ff       	call   808a36 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  809055:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809059:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809060:	e8 7b e6 ff ff       	call   8076e0 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  809065:	85 f6                	test   %esi,%esi
  809067:	74 10                	je     809079 <tcp_abort+0xdb>
  809069:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  809070:	ff 
  809071:	8b 45 cc             	mov    -0x34(%ebp),%eax
  809074:	89 04 24             	mov    %eax,(%esp)
  809077:	ff d6                	call   *%esi
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  809079:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80907d:	89 44 24 14          	mov    %eax,0x14(%esp)
  809081:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  809085:	89 44 24 10          	mov    %eax,0x10(%esp)
  809089:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80908c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809090:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809093:	89 44 24 08          	mov    %eax,0x8(%esp)
  809097:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80909b:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80909e:	89 04 24             	mov    %eax,(%esp)
  8090a1:	e8 f6 20 00 00       	call   80b19c <tcp_rst>
  }
}
  8090a6:	83 c4 4c             	add    $0x4c,%esp
  8090a9:	5b                   	pop    %ebx
  8090aa:	5e                   	pop    %esi
  8090ab:	5f                   	pop    %edi
  8090ac:	5d                   	pop    %ebp
  8090ad:	c3                   	ret    

008090ae <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  8090ae:	55                   	push   %ebp
  8090af:	89 e5                	mov    %esp,%ebp
  8090b1:	83 ec 38             	sub    $0x38,%esp
  8090b4:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8090b7:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8090ba:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8090bd:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  8090c1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8090c8:	e8 57 e6 ff ff       	call   807724 <memp_malloc>
  8090cd:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  8090cf:	85 c0                	test   %eax,%eax
  8090d1:	0f 85 c9 00 00 00    	jne    8091a0 <tcp_alloc+0xf2>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8090d7:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  8090dc:	85 c0                	test   %eax,%eax
  8090de:	74 36                	je     809116 <tcp_alloc+0x68>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8090e0:	8b 1d 10 f0 b3 00    	mov    0xb3f010,%ebx
  8090e6:	bf 00 00 00 00       	mov    $0x0,%edi
  8090eb:	b9 00 00 00 00       	mov    $0x0,%ecx
  8090f0:	89 da                	mov    %ebx,%edx
  8090f2:	2b 50 2c             	sub    0x2c(%eax),%edx
  8090f5:	39 ca                	cmp    %ecx,%edx
  8090f7:	72 04                	jb     8090fd <tcp_alloc+0x4f>
  8090f9:	89 c7                	mov    %eax,%edi
  8090fb:	eb 02                	jmp    8090ff <tcp_alloc+0x51>
  8090fd:	89 ca                	mov    %ecx,%edx
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8090ff:	8b 40 0c             	mov    0xc(%eax),%eax
  809102:	85 c0                	test   %eax,%eax
  809104:	74 04                	je     80910a <tcp_alloc+0x5c>
  809106:	89 d1                	mov    %edx,%ecx
  809108:	eb e6                	jmp    8090f0 <tcp_alloc+0x42>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  80910a:	85 ff                	test   %edi,%edi
  80910c:	74 08                	je     809116 <tcp_alloc+0x68>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  80910e:	89 3c 24             	mov    %edi,(%esp)
  809111:	e8 88 fe ff ff       	call   808f9e <tcp_abort>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  809116:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80911d:	e8 02 e6 ff ff       	call   807724 <memp_malloc>
  809122:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  809124:	85 c0                	test   %eax,%eax
  809126:	75 78                	jne    8091a0 <tcp_alloc+0xf2>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  809128:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  80912d:	85 c0                	test   %eax,%eax
  80912f:	74 59                	je     80918a <tcp_alloc+0xdc>
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  809131:	8b 15 10 f0 b3 00    	mov    0xb3f010,%edx
  809137:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80913a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  809141:	bf 00 00 00 00       	mov    $0x0,%edi
  809146:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  80914b:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  80914f:	89 f3                	mov    %esi,%ebx
  809151:	38 d3                	cmp    %dl,%bl
  809153:	72 13                	jb     809168 <tcp_alloc+0xba>
  809155:	38 ca                	cmp    %cl,%dl
  809157:	77 0f                	ja     809168 <tcp_alloc+0xba>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  809159:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80915c:	2b 58 2c             	sub    0x2c(%eax),%ebx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  80915f:	39 df                	cmp    %ebx,%edi
  809161:	77 05                	ja     809168 <tcp_alloc+0xba>
  809163:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809166:	eb 04                	jmp    80916c <tcp_alloc+0xbe>
  809168:	89 ca                	mov    %ecx,%edx
  80916a:	89 fb                	mov    %edi,%ebx
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80916c:	8b 40 0c             	mov    0xc(%eax),%eax
  80916f:	85 c0                	test   %eax,%eax
  809171:	74 06                	je     809179 <tcp_alloc+0xcb>
  809173:	89 df                	mov    %ebx,%edi
  809175:	89 d1                	mov    %edx,%ecx
  809177:	eb d2                	jmp    80914b <tcp_alloc+0x9d>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  809179:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80917d:	74 0b                	je     80918a <tcp_alloc+0xdc>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  80917f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809182:	89 04 24             	mov    %eax,(%esp)
  809185:	e8 14 fe ff ff       	call   808f9e <tcp_abort>
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  80918a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809191:	e8 8e e5 ff ff       	call   807724 <memp_malloc>
  809196:	89 c3                	mov    %eax,%ebx
    }
  }
  if (pcb != NULL) {
  809198:	85 c0                	test   %eax,%eax
  80919a:	0f 84 9b 00 00 00    	je     80923b <tcp_alloc+0x18d>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  8091a0:	c7 44 24 08 a8 00 00 	movl   $0xa8,0x8(%esp)
  8091a7:	00 
  8091a8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8091af:	00 
  8091b0:	89 1c 24             	mov    %ebx,(%esp)
  8091b3:	e8 9e 83 ff ff       	call   801556 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  8091b8:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  8091bc:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  8091c2:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  8091c8:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  8091ce:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  8091d4:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  8091d8:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8091dc:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  8091e2:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  8091e8:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  8091ee:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  8091f4:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  8091fa:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  809200:	e8 47 f6 ff ff       	call   80884c <tcp_next_iss>
    pcb->snd_wl2 = iss;
  809205:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  809208:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  80920b:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  80920e:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  809211:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  809214:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  809219:	89 43 2c             	mov    %eax,0x2c(%ebx)

    pcb->polltmr = 0;
  80921c:	c6 43 30 00          	movb   $0x0,0x30(%ebx)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  809220:	c7 83 88 00 00 00 2f 	movl   $0x80982f,0x88(%ebx)
  809227:	98 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  80922a:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  809231:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  809234:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  }
  return pcb;
}
  80923b:	89 d8                	mov    %ebx,%eax
  80923d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809240:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809243:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809246:	89 ec                	mov    %ebp,%esp
  809248:	5d                   	pop    %ebp
  809249:	c3                   	ret    

0080924a <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  80924a:	55                   	push   %ebp
  80924b:	89 e5                	mov    %esp,%ebp
  80924d:	83 ec 18             	sub    $0x18,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  809250:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  809257:	e8 52 fe ff ff       	call   8090ae <tcp_alloc>
}
  80925c:	c9                   	leave  
  80925d:	c3                   	ret    

0080925e <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  80925e:	55                   	push   %ebp
  80925f:	89 e5                	mov    %esp,%ebp
  809261:	57                   	push   %edi
  809262:	56                   	push   %esi
  809263:	53                   	push   %ebx
  809264:	83 ec 2c             	sub    $0x2c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  809267:	83 05 10 f0 b3 00 01 	addl   $0x1,0xb3f010

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  80926e:	8b 1d 0c f0 b3 00    	mov    0xb3f00c,%ebx
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  809274:	85 db                	test   %ebx,%ebx
  809276:	0f 84 5f 03 00 00    	je     8095db <tcp_slowtmr+0x37d>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80927c:	8b 43 10             	mov    0x10(%ebx),%eax
  80927f:	85 c0                	test   %eax,%eax
  809281:	74 1c                	je     80929f <tcp_slowtmr+0x41>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  809283:	83 f8 01             	cmp    $0x1,%eax
  809286:	74 38                	je     8092c0 <tcp_slowtmr+0x62>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  809288:	83 f8 0a             	cmp    $0xa,%eax
  80928b:	74 54                	je     8092e1 <tcp_slowtmr+0x83>
  80928d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  809291:	bf 00 00 00 00       	mov    $0x0,%edi
  809296:	eb 67                	jmp    8092ff <tcp_slowtmr+0xa1>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  809298:	8b 46 10             	mov    0x10(%esi),%eax
  80929b:	85 c0                	test   %eax,%eax
  80929d:	75 1c                	jne    8092bb <tcp_slowtmr+0x5d>
  80929f:	c7 44 24 08 98 39 81 	movl   $0x813998,0x8(%esp)
  8092a6:	00 
  8092a7:	c7 44 24 04 36 02 00 	movl   $0x236,0x4(%esp)
  8092ae:	00 
  8092af:	c7 04 24 cf 38 81 00 	movl   $0x8138cf,(%esp)
  8092b6:	e8 2d 77 ff ff       	call   8009e8 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  8092bb:	83 f8 01             	cmp    $0x1,%eax
  8092be:	75 1c                	jne    8092dc <tcp_slowtmr+0x7e>
  8092c0:	c7 44 24 08 c4 39 81 	movl   $0x8139c4,0x8(%esp)
  8092c7:	00 
  8092c8:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
  8092cf:	00 
  8092d0:	c7 04 24 cf 38 81 00 	movl   $0x8138cf,(%esp)
  8092d7:	e8 0c 77 ff ff       	call   8009e8 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  8092dc:	83 f8 0a             	cmp    $0xa,%eax
  8092df:	75 1c                	jne    8092fd <tcp_slowtmr+0x9f>
  8092e1:	c7 44 24 08 f0 39 81 	movl   $0x8139f0,0x8(%esp)
  8092e8:	00 
  8092e9:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  8092f0:	00 
  8092f1:	c7 04 24 cf 38 81 00 	movl   $0x8138cf,(%esp)
  8092f8:	e8 eb 76 ff ff       	call   8009e8 <_panic>
  8092fd:	89 f3                	mov    %esi,%ebx

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  8092ff:	83 f8 02             	cmp    $0x2,%eax
  809302:	75 0a                	jne    80930e <tcp_slowtmr+0xb0>
  809304:	80 7b 46 06          	cmpb   $0x6,0x46(%ebx)
  809308:	0f 84 f1 00 00 00    	je     8093ff <tcp_slowtmr+0x1a1>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80930e:	80 7b 46 0c          	cmpb   $0xc,0x46(%ebx)
  809312:	0f 84 e7 00 00 00    	je     8093ff <tcp_slowtmr+0x1a1>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  809318:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  80931f:	90                   	nop
  809320:	74 55                	je     809377 <tcp_slowtmr+0x119>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  809322:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  809328:	83 c0 01             	add    $0x1,%eax
  80932b:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  809331:	0f b6 93 a4 00 00 00 	movzbl 0xa4(%ebx),%edx
  809338:	0f b6 92 24 3b 81 00 	movzbl 0x813b24(%edx),%edx
  80933f:	39 d0                	cmp    %edx,%eax
  809341:	0f 82 bf 00 00 00    	jb     809406 <tcp_slowtmr+0x1a8>
          pcb->persist_cnt = 0;
  809347:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  80934e:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  809351:	0f b6 83 a4 00 00 00 	movzbl 0xa4(%ebx),%eax
  809358:	3c 06                	cmp    $0x6,%al
  80935a:	77 09                	ja     809365 <tcp_slowtmr+0x107>
            pcb->persist_backoff++;
  80935c:	83 c0 01             	add    $0x1,%eax
  80935f:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  809365:	89 1c 24             	mov    %ebx,(%esp)
  809368:	e8 63 1b 00 00       	call   80aed0 <tcp_zero_window_probe>
  80936d:	be 00 00 00 00       	mov    $0x0,%esi
  809372:	e9 94 00 00 00       	jmp    80940b <tcp_slowtmr+0x1ad>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  809377:	0f b7 43 32          	movzwl 0x32(%ebx),%eax
  80937b:	66 85 c0             	test   %ax,%ax
  80937e:	78 07                	js     809387 <tcp_slowtmr+0x129>
          ++pcb->rtime;
  809380:	83 c0 01             	add    $0x1,%eax
  809383:	66 89 43 32          	mov    %ax,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  809387:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80938b:	74 79                	je     809406 <tcp_slowtmr+0x1a8>
  80938d:	0f b7 43 32          	movzwl 0x32(%ebx),%eax
  809391:	66 3b 43 44          	cmp    0x44(%ebx),%ax
  809395:	7c 6f                	jl     809406 <tcp_slowtmr+0x1a8>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  809397:	83 7b 10 02          	cmpl   $0x2,0x10(%ebx)
  80939b:	74 20                	je     8093bd <tcp_slowtmr+0x15f>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  80939d:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  8093a1:	66 c1 f8 03          	sar    $0x3,%ax
  8093a5:	98                   	cwtl   
  8093a6:	0f bf 53 42          	movswl 0x42(%ebx),%edx
  8093aa:	01 d0                	add    %edx,%eax
  8093ac:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  8093b0:	0f b6 8a 18 3b 81 00 	movzbl 0x813b18(%edx),%ecx
  8093b7:	d3 e0                	shl    %cl,%eax
  8093b9:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  8093bd:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  8093c3:	0f b7 53 5c          	movzwl 0x5c(%ebx),%edx
  8093c7:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  8093cb:	66 39 d0             	cmp    %dx,%ax
  8093ce:	76 02                	jbe    8093d2 <tcp_slowtmr+0x174>
  8093d0:	89 d0                	mov    %edx,%eax
  8093d2:	66 d1 e8             	shr    %ax
  8093d5:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  8093d9:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  8093dd:	66 39 d0             	cmp    %dx,%ax
  8093e0:	73 06                	jae    8093e8 <tcp_slowtmr+0x18a>
            pcb->ssthresh = pcb->mss * 2;
  8093e2:	01 d2                	add    %edx,%edx
  8093e4:	66 89 53 50          	mov    %dx,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  8093e8:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  8093ec:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  8093f0:	89 1c 24             	mov    %ebx,(%esp)
  8093f3:	e8 fb 23 00 00       	call   80b7f3 <tcp_rexmit_rto>
  8093f8:	be 00 00 00 00       	mov    $0x0,%esi
  8093fd:	eb 0c                	jmp    80940b <tcp_slowtmr+0x1ad>
  8093ff:	be 01 00 00 00       	mov    $0x1,%esi
  809404:	eb 05                	jmp    80940b <tcp_slowtmr+0x1ad>
  809406:	be 00 00 00 00       	mov    $0x0,%esi
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  80940b:	8b 43 10             	mov    0x10(%ebx),%eax
  80940e:	83 f8 06             	cmp    $0x6,%eax
  809411:	75 13                	jne    809426 <tcp_slowtmr+0x1c8>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  809413:	8b 15 10 f0 b3 00    	mov    0xb3f010,%edx
  809419:	2b 53 2c             	sub    0x2c(%ebx),%edx
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80941c:	83 fa 29             	cmp    $0x29,%edx
  80941f:	89 f2                	mov    %esi,%edx
  809421:	80 da ff             	sbb    $0xff,%dl
  809424:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  809426:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  80942a:	74 6a                	je     809496 <tcp_slowtmr+0x238>
  80942c:	83 f8 04             	cmp    $0x4,%eax
  80942f:	74 05                	je     809436 <tcp_slowtmr+0x1d8>
  809431:	83 f8 07             	cmp    $0x7,%eax
  809434:	75 60                	jne    809496 <tcp_slowtmr+0x238>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  809436:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  80943b:	2b 43 2c             	sub    0x2c(%ebx),%eax
  80943e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  809441:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  809447:	8d 81 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%eax
  80944d:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  809452:	f7 e2                	mul    %edx
  809454:	c1 ea 05             	shr    $0x5,%edx
  809457:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80945a:	76 0a                	jbe    809466 <tcp_slowtmr+0x208>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  80945c:	89 1c 24             	mov    %ebx,(%esp)
  80945f:	e8 3a fb ff ff       	call   808f9e <tcp_abort>
  809464:	eb 30                	jmp    809496 <tcp_slowtmr+0x238>
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  809466:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  80946d:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  809473:	8d 0c 0a             	lea    (%edx,%ecx,1),%ecx
  809476:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80947b:	89 c8                	mov    %ecx,%eax
  80947d:	f7 e2                	mul    %edx
  80947f:	c1 ea 05             	shr    $0x5,%edx
  809482:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  809485:	76 0f                	jbe    809496 <tcp_slowtmr+0x238>
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  809487:	89 1c 24             	mov    %ebx,(%esp)
  80948a:	e8 b8 1b 00 00       	call   80b047 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  80948f:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  809496:	8b 53 7c             	mov    0x7c(%ebx),%edx
  809499:	85 d2                	test   %edx,%edx
  80949b:	74 25                	je     8094c2 <tcp_slowtmr+0x264>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  80949d:	8b 0d 10 f0 b3 00    	mov    0xb3f010,%ecx
  8094a3:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
  8094a6:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  8094aa:	8d 04 40             	lea    (%eax,%eax,2),%eax
  8094ad:	01 c0                	add    %eax,%eax
  8094af:	39 c1                	cmp    %eax,%ecx
  8094b1:	72 0f                	jb     8094c2 <tcp_slowtmr+0x264>
      tcp_segs_free(pcb->ooseq);
  8094b3:	89 14 24             	mov    %edx,(%esp)
  8094b6:	e8 7b f5 ff ff       	call   808a36 <tcp_segs_free>
      pcb->ooseq = NULL;
  8094bb:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  8094c2:	8b 43 10             	mov    0x10(%ebx),%eax
  8094c5:	83 f8 03             	cmp    $0x3,%eax
  8094c8:	75 13                	jne    8094dd <tcp_slowtmr+0x27f>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  8094ca:	8b 15 10 f0 b3 00    	mov    0xb3f010,%edx
  8094d0:	2b 53 2c             	sub    0x2c(%ebx),%edx
  8094d3:	83 fa 28             	cmp    $0x28,%edx
  8094d6:	76 05                	jbe    8094dd <tcp_slowtmr+0x27f>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  8094d8:	83 c6 01             	add    $0x1,%esi
  8094db:	eb 19                	jmp    8094f6 <tcp_slowtmr+0x298>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  8094dd:	83 f8 09             	cmp    $0x9,%eax
  8094e0:	75 14                	jne    8094f6 <tcp_slowtmr+0x298>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8094e2:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  8094e7:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  8094ea:	3d f1 00 00 00       	cmp    $0xf1,%eax
  8094ef:	89 f2                	mov    %esi,%edx
  8094f1:	80 da ff             	sbb    $0xff,%dl
  8094f4:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  8094f6:	89 f0                	mov    %esi,%eax
  8094f8:	84 c0                	test   %al,%al
  8094fa:	0f 84 94 00 00 00    	je     809594 <tcp_slowtmr+0x336>
      tcp_pcb_purge(pcb);      
  809500:	89 1c 24             	mov    %ebx,(%esp)
  809503:	e8 5f f5 ff ff       	call   808a67 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  809508:	85 ff                	test   %edi,%edi
  80950a:	74 2c                	je     809538 <tcp_slowtmr+0x2da>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80950c:	3b 1d 0c f0 b3 00    	cmp    0xb3f00c,%ebx
  809512:	75 1c                	jne    809530 <tcp_slowtmr+0x2d2>
  809514:	c7 44 24 08 20 3a 81 	movl   $0x813a20,0x8(%esp)
  80951b:	00 
  80951c:	c7 44 24 04 c1 02 00 	movl   $0x2c1,0x4(%esp)
  809523:	00 
  809524:	c7 04 24 cf 38 81 00 	movl   $0x8138cf,(%esp)
  80952b:	e8 b8 74 ff ff       	call   8009e8 <_panic>
        prev->next = pcb->next;
  809530:	8b 43 0c             	mov    0xc(%ebx),%eax
  809533:	89 47 0c             	mov    %eax,0xc(%edi)
  809536:	eb 2d                	jmp    809565 <tcp_slowtmr+0x307>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  809538:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  80953d:	39 d8                	cmp    %ebx,%eax
  80953f:	74 1c                	je     80955d <tcp_slowtmr+0x2ff>
  809541:	c7 44 24 08 4c 3a 81 	movl   $0x813a4c,0x8(%esp)
  809548:	00 
  809549:	c7 44 24 04 c5 02 00 	movl   $0x2c5,0x4(%esp)
  809550:	00 
  809551:	c7 04 24 cf 38 81 00 	movl   $0x8138cf,(%esp)
  809558:	e8 8b 74 ff ff       	call   8009e8 <_panic>
        tcp_active_pcbs = pcb->next;
  80955d:	8b 40 0c             	mov    0xc(%eax),%eax
  809560:	a3 0c f0 b3 00       	mov    %eax,0xb3f00c
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  809565:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80956b:	85 c0                	test   %eax,%eax
  80956d:	74 10                	je     80957f <tcp_slowtmr+0x321>
  80956f:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  809576:	ff 
  809577:	8b 53 18             	mov    0x18(%ebx),%edx
  80957a:	89 14 24             	mov    %edx,(%esp)
  80957d:	ff d0                	call   *%eax

      pcb2 = pcb->next;
  80957f:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  809582:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809586:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80958d:	e8 4e e1 ff ff       	call   8076e0 <memp_free>
  809592:	eb 3f                	jmp    8095d3 <tcp_slowtmr+0x375>
      pcb = pcb2;
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  809594:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  809598:	83 c0 01             	add    $0x1,%eax
  80959b:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  80959e:	3a 43 31             	cmp    0x31(%ebx),%al
  8095a1:	72 2b                	jb     8095ce <tcp_slowtmr+0x370>
        pcb->polltmr = 0;
  8095a3:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  8095a7:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  8095ad:	85 c0                	test   %eax,%eax
  8095af:	74 0f                	je     8095c0 <tcp_slowtmr+0x362>
  8095b1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8095b5:	8b 53 18             	mov    0x18(%ebx),%edx
  8095b8:	89 14 24             	mov    %edx,(%esp)
  8095bb:	ff d0                	call   *%eax
  8095bd:	88 45 e3             	mov    %al,-0x1d(%ebp)
        if (err == ERR_OK) {
  8095c0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  8095c4:	75 08                	jne    8095ce <tcp_slowtmr+0x370>
          tcp_output(pcb);
  8095c6:	89 1c 24             	mov    %ebx,(%esp)
  8095c9:	e8 2d 1d 00 00       	call   80b2fb <tcp_output>
        }
      }
      
      prev = pcb;
      pcb = pcb->next;
  8095ce:	8b 73 0c             	mov    0xc(%ebx),%esi
  8095d1:	89 df                	mov    %ebx,%edi
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  8095d3:	85 f6                	test   %esi,%esi
  8095d5:	0f 85 bd fc ff ff    	jne    809298 <tcp_slowtmr+0x3a>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  8095db:	8b 1d 20 f0 b3 00    	mov    0xb3f020,%ebx
  while (pcb != NULL) {
  8095e1:	85 db                	test   %ebx,%ebx
  8095e3:	0f 84 c7 00 00 00    	je     8096b0 <tcp_slowtmr+0x452>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8095e9:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  8095ed:	75 0d                	jne    8095fc <tcp_slowtmr+0x39e>
  8095ef:	be 00 00 00 00       	mov    $0x0,%esi
  8095f4:	eb 24                	jmp    80961a <tcp_slowtmr+0x3bc>
  8095f6:	83 7f 10 0a          	cmpl   $0xa,0x10(%edi)
  8095fa:	74 1c                	je     809618 <tcp_slowtmr+0x3ba>
  8095fc:	c7 44 24 08 78 3a 81 	movl   $0x813a78,0x8(%esp)
  809603:	00 
  809604:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
  80960b:	00 
  80960c:	c7 04 24 cf 38 81 00 	movl   $0x8138cf,(%esp)
  809613:	e8 d0 73 ff ff       	call   8009e8 <_panic>
  809618:	89 fb                	mov    %edi,%ebx
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80961a:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  80961f:	2b 43 2c             	sub    0x2c(%ebx),%eax
  809622:	3d f0 00 00 00       	cmp    $0xf0,%eax
  809627:	76 7a                	jbe    8096a3 <tcp_slowtmr+0x445>
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      tcp_pcb_purge(pcb);      
  809629:	89 1c 24             	mov    %ebx,(%esp)
  80962c:	e8 36 f4 ff ff       	call   808a67 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  809631:	85 f6                	test   %esi,%esi
  809633:	74 2c                	je     809661 <tcp_slowtmr+0x403>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  809635:	3b 1d 20 f0 b3 00    	cmp    0xb3f020,%ebx
  80963b:	75 1c                	jne    809659 <tcp_slowtmr+0x3fb>
  80963d:	c7 44 24 08 a8 3a 81 	movl   $0x813aa8,0x8(%esp)
  809644:	00 
  809645:	c7 44 24 04 f4 02 00 	movl   $0x2f4,0x4(%esp)
  80964c:	00 
  80964d:	c7 04 24 cf 38 81 00 	movl   $0x8138cf,(%esp)
  809654:	e8 8f 73 ff ff       	call   8009e8 <_panic>
        prev->next = pcb->next;
  809659:	8b 43 0c             	mov    0xc(%ebx),%eax
  80965c:	89 46 0c             	mov    %eax,0xc(%esi)
  80965f:	eb 2d                	jmp    80968e <tcp_slowtmr+0x430>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  809661:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  809666:	39 d8                	cmp    %ebx,%eax
  809668:	74 1c                	je     809686 <tcp_slowtmr+0x428>
  80966a:	c7 44 24 08 d0 3a 81 	movl   $0x813ad0,0x8(%esp)
  809671:	00 
  809672:	c7 44 24 04 f8 02 00 	movl   $0x2f8,0x4(%esp)
  809679:	00 
  80967a:	c7 04 24 cf 38 81 00 	movl   $0x8138cf,(%esp)
  809681:	e8 62 73 ff ff       	call   8009e8 <_panic>
        tcp_tw_pcbs = pcb->next;
  809686:	8b 40 0c             	mov    0xc(%eax),%eax
  809689:	a3 20 f0 b3 00       	mov    %eax,0xb3f020
      }
      pcb2 = pcb->next;
  80968e:	8b 7b 0c             	mov    0xc(%ebx),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  809691:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809695:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80969c:	e8 3f e0 ff ff       	call   8076e0 <memp_free>
  8096a1:	eb 05                	jmp    8096a8 <tcp_slowtmr+0x44a>
      pcb = pcb2;
    } else {
      prev = pcb;
      pcb = pcb->next;
  8096a3:	8b 7b 0c             	mov    0xc(%ebx),%edi
  8096a6:	89 de                	mov    %ebx,%esi

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  8096a8:	85 ff                	test   %edi,%edi
  8096aa:	0f 85 46 ff ff ff    	jne    8095f6 <tcp_slowtmr+0x398>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  8096b0:	83 c4 2c             	add    $0x2c,%esp
  8096b3:	5b                   	pop    %ebx
  8096b4:	5e                   	pop    %esi
  8096b5:	5f                   	pop    %edi
  8096b6:	5d                   	pop    %ebp
  8096b7:	c3                   	ret    

008096b8 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  8096b8:	55                   	push   %ebp
  8096b9:	89 e5                	mov    %esp,%ebp
  8096bb:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  8096be:	e8 68 f2 ff ff       	call   80892b <tcp_fasttmr>

  if (++tcp_timer & 1) {
  8096c3:	0f b6 05 28 54 b3 00 	movzbl 0xb35428,%eax
  8096ca:	83 c0 01             	add    $0x1,%eax
  8096cd:	a2 28 54 b3 00       	mov    %al,0xb35428
  8096d2:	a8 01                	test   $0x1,%al
  8096d4:	74 05                	je     8096db <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  8096d6:	e8 83 fb ff ff       	call   80925e <tcp_slowtmr>
  }
}
  8096db:	c9                   	leave  
  8096dc:	c3                   	ret    

008096dd <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  8096dd:	55                   	push   %ebp
  8096de:	89 e5                	mov    %esp,%ebp
  8096e0:	53                   	push   %ebx
  8096e1:	83 ec 14             	sub    $0x14,%esp
  8096e4:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  8096e7:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  8096eb:	77 0a                	ja     8096f7 <tcp_close+0x1a>
  8096ed:	8b 43 10             	mov    0x10(%ebx),%eax
  8096f0:	ff 24 85 f8 3a 81 00 	jmp    *0x813af8(,%eax,4)
  8096f7:	bb 00 00 00 00       	mov    $0x0,%ebx
  8096fc:	e9 05 01 00 00       	jmp    809806 <tcp_close+0x129>
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  809701:	8b 15 1c f0 b3 00    	mov    0xb3f01c,%edx
  809707:	39 da                	cmp    %ebx,%edx
  809709:	75 0a                	jne    809715 <tcp_close+0x38>
  80970b:	8b 42 0c             	mov    0xc(%edx),%eax
  80970e:	a3 1c f0 b3 00       	mov    %eax,0xb3f01c
  809713:	eb 2a                	jmp    80973f <tcp_close+0x62>
  809715:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  80971b:	85 d2                	test   %edx,%edx
  80971d:	74 20                	je     80973f <tcp_close+0x62>
  80971f:	8b 42 0c             	mov    0xc(%edx),%eax
  809722:	85 c0                	test   %eax,%eax
  809724:	0f 84 fb 00 00 00    	je     809825 <tcp_close+0x148>
  80972a:	39 c3                	cmp    %eax,%ebx
  80972c:	75 08                	jne    809736 <tcp_close+0x59>
  80972e:	8b 43 0c             	mov    0xc(%ebx),%eax
  809731:	89 42 0c             	mov    %eax,0xc(%edx)
  809734:	eb 09                	jmp    80973f <tcp_close+0x62>
  809736:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  80973b:	89 c2                	mov    %eax,%edx
  80973d:	eb e0                	jmp    80971f <tcp_close+0x42>
  80973f:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  809746:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80974a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809751:	e8 8a df ff ff       	call   8076e0 <memp_free>
  809756:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    break;
  80975b:	e9 bf 00 00 00       	jmp    80981f <tcp_close+0x142>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  809760:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809764:	c7 04 24 14 f0 b3 00 	movl   $0xb3f014,(%esp)
  80976b:	e8 70 f3 ff ff       	call   808ae0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  809770:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809774:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80977b:	e8 60 df ff ff       	call   8076e0 <memp_free>
  809780:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    break;
  809785:	e9 95 00 00 00       	jmp    80981f <tcp_close+0x142>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80978a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80978e:	c7 04 24 0c f0 b3 00 	movl   $0xb3f00c,(%esp)
  809795:	e8 46 f3 ff ff       	call   808ae0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  80979a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80979e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8097a5:	e8 36 df ff ff       	call   8076e0 <memp_free>
  8097aa:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  8097af:	eb 6e                	jmp    80981f <tcp_close+0x142>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8097b1:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8097b8:	00 
  8097b9:	89 1c 24             	mov    %ebx,(%esp)
  8097bc:	e8 f7 27 00 00       	call   80bfb8 <tcp_send_ctrl>
    if (err == ERR_OK) {
  8097c1:	84 c0                	test   %al,%al
  8097c3:	75 5a                	jne    80981f <tcp_close+0x142>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  8097c5:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  8097cc:	eb 38                	jmp    809806 <tcp_close+0x129>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8097ce:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8097d5:	00 
  8097d6:	89 1c 24             	mov    %ebx,(%esp)
  8097d9:	e8 da 27 00 00       	call   80bfb8 <tcp_send_ctrl>
    if (err == ERR_OK) {
  8097de:	84 c0                	test   %al,%al
  8097e0:	75 3d                	jne    80981f <tcp_close+0x142>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  8097e2:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  8097e9:	eb 1b                	jmp    809806 <tcp_close+0x129>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8097eb:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8097f2:	00 
  8097f3:	89 1c 24             	mov    %ebx,(%esp)
  8097f6:	e8 bd 27 00 00       	call   80bfb8 <tcp_send_ctrl>
    if (err == ERR_OK) {
  8097fb:	84 c0                	test   %al,%al
  8097fd:	75 20                	jne    80981f <tcp_close+0x142>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  8097ff:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  809806:	85 db                	test   %ebx,%ebx
  809808:	75 08                	jne    809812 <tcp_close+0x135>
  80980a:	b8 00 00 00 00       	mov    $0x0,%eax
  80980f:	90                   	nop
  809810:	eb 0d                	jmp    80981f <tcp_close+0x142>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  809812:	89 1c 24             	mov    %ebx,(%esp)
  809815:	e8 e1 1a 00 00       	call   80b2fb <tcp_output>
  80981a:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return err;
}
  80981f:	83 c4 14             	add    $0x14,%esp
  809822:	5b                   	pop    %ebx
  809823:	5d                   	pop    %ebp
  809824:	c3                   	ret    
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  809825:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  80982a:	e9 10 ff ff ff       	jmp    80973f <tcp_close+0x62>

0080982f <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80982f:	55                   	push   %ebp
  809830:	89 e5                	mov    %esp,%ebp
  809832:	83 ec 18             	sub    $0x18,%esp
  809835:	8b 45 10             	mov    0x10(%ebp),%eax
  809838:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  80983c:	85 c0                	test   %eax,%eax
  80983e:	74 0f                	je     80984f <tcp_recv_null+0x20>
    pbuf_free(p);
  809840:	89 04 24             	mov    %eax,(%esp)
  809843:	e8 30 e6 ff ff       	call   807e78 <pbuf_free>
  809848:	b8 00 00 00 00       	mov    $0x0,%eax
  80984d:	eb 14                	jmp    809863 <tcp_recv_null+0x34>
  } else if (err == ERR_OK) {
  80984f:	b8 00 00 00 00       	mov    $0x0,%eax
  809854:	84 d2                	test   %dl,%dl
  809856:	75 0b                	jne    809863 <tcp_recv_null+0x34>
    return tcp_close(pcb);
  809858:	8b 45 0c             	mov    0xc(%ebp),%eax
  80985b:	89 04 24             	mov    %eax,(%esp)
  80985e:	e8 7a fe ff ff       	call   8096dd <tcp_close>
  }
  return ERR_OK;
}
  809863:	c9                   	leave  
  809864:	c3                   	ret    
  809865:	00 00                	add    %al,(%eax)
	...

00809868 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  809868:	55                   	push   %ebp
  809869:	89 e5                	mov    %esp,%ebp
  80986b:	53                   	push   %ebx
  80986c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  80986f:	8b 45 08             	mov    0x8(%ebp),%eax
  809872:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  809874:	8d 5a ff             	lea    -0x1(%edx),%ebx
  809877:	b8 01 00 00 00       	mov    $0x1,%eax
  80987c:	83 fb fd             	cmp    $0xfffffffd,%ebx
  80987f:	77 26                	ja     8098a7 <ip_addr_isbroadcast+0x3f>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  809881:	f6 41 2e 02          	testb  $0x2,0x2e(%ecx)
  809885:	74 1b                	je     8098a2 <ip_addr_isbroadcast+0x3a>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  809887:	8b 41 04             	mov    0x4(%ecx),%eax
  80988a:	39 d0                	cmp    %edx,%eax
  80988c:	74 14                	je     8098a2 <ip_addr_isbroadcast+0x3a>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  80988e:	8b 49 08             	mov    0x8(%ecx),%ecx
  809891:	31 d0                	xor    %edx,%eax
  809893:	85 c8                	test   %ecx,%eax
  809895:	75 0b                	jne    8098a2 <ip_addr_isbroadcast+0x3a>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  809897:	f7 d1                	not    %ecx
  809899:	21 ca                	and    %ecx,%edx
  80989b:	39 d1                	cmp    %edx,%ecx
  80989d:	0f 94 c0             	sete   %al
  8098a0:	eb 05                	jmp    8098a7 <ip_addr_isbroadcast+0x3f>
  8098a2:	b8 00 00 00 00       	mov    $0x0,%eax
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  8098a7:	5b                   	pop    %ebx
  8098a8:	5d                   	pop    %ebp
  8098a9:	c3                   	ret    
  8098aa:	00 00                	add    %al,(%eax)
  8098ac:	00 00                	add    %al,(%eax)
	...

008098b0 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  8098b0:	55                   	push   %ebp
  8098b1:	89 e5                	mov    %esp,%ebp
  8098b3:	83 ec 48             	sub    $0x48,%esp
  8098b6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8098b9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8098bc:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8098bf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8098c2:	8b 7d 10             	mov    0x10(%ebp),%edi
  8098c5:	8b 75 20             	mov    0x20(%ebp),%esi
  8098c8:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  8098cc:	88 45 d8             	mov    %al,-0x28(%ebp)
  8098cf:	0f b6 55 18          	movzbl 0x18(%ebp),%edx
  8098d3:	88 55 d7             	mov    %dl,-0x29(%ebp)
  8098d6:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  8098da:	88 45 d6             	mov    %al,-0x2a(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  8098dd:	85 ff                	test   %edi,%edi
  8098df:	0f 84 3a 01 00 00    	je     809a1f <ip_output_if+0x16f>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  8098e5:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8098ec:	00 
  8098ed:	89 1c 24             	mov    %ebx,(%esp)
  8098f0:	e8 0e e2 ff ff       	call   807b03 <pbuf_header>
  8098f5:	89 c2                	mov    %eax,%edx
  8098f7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8098fc:	84 d2                	test   %dl,%dl
  8098fe:	0f 85 50 01 00 00    	jne    809a54 <ip_output_if+0x1a4>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  809904:	8b 43 04             	mov    0x4(%ebx),%eax
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  809907:	66 83 7b 0a 13       	cmpw   $0x13,0xa(%ebx)
  80990c:	77 1c                	ja     80992a <ip_output_if+0x7a>
  80990e:	c7 44 24 08 34 3b 81 	movl   $0x813b34,0x8(%esp)
  809915:	00 
  809916:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
  80991d:	00 
  80991e:	c7 04 24 61 3b 81 00 	movl   $0x813b61,(%esp)
  809925:	e8 be 70 ff ff       	call   8009e8 <_panic>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  80992a:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  80992d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  809931:	89 04 24             	mov    %eax,(%esp)
  809934:	e8 48 13 00 00       	call   80ac81 <ntohs>
  809939:	0f b6 d0             	movzbl %al,%edx
  80993c:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
  809940:	c1 e0 08             	shl    $0x8,%eax
  809943:	09 d0                	or     %edx,%eax
  809945:	0f b7 c0             	movzwl %ax,%eax
  809948:	89 04 24             	mov    %eax,(%esp)
  80994b:	e8 24 13 00 00       	call   80ac74 <htons>
  809950:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809953:	66 89 42 08          	mov    %ax,0x8(%edx)
    IPH_PROTO_SET(iphdr, proto);
  809957:	0f b7 c0             	movzwl %ax,%eax
  80995a:	89 04 24             	mov    %eax,(%esp)
  80995d:	e8 1f 13 00 00       	call   80ac81 <ntohs>
  809962:	89 c2                	mov    %eax,%edx
  809964:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  80996a:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
  80996e:	09 d0                	or     %edx,%eax
  809970:	0f b7 c0             	movzwl %ax,%eax
  809973:	89 04 24             	mov    %eax,(%esp)
  809976:	e8 f9 12 00 00       	call   80ac74 <htons>
  80997b:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80997e:	66 89 42 08          	mov    %ax,0x8(%edx)

    ip_addr_set(&(iphdr->dest), dest);
  809982:	8b 07                	mov    (%edi),%eax
  809984:	89 42 10             	mov    %eax,0x10(%edx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  809987:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
  80998b:	80 cc 45             	or     $0x45,%ah
  80998e:	89 04 24             	mov    %eax,(%esp)
  809991:	e8 de 12 00 00       	call   80ac74 <htons>
  809996:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809999:	66 89 02             	mov    %ax,(%edx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  80999c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8099a0:	89 04 24             	mov    %eax,(%esp)
  8099a3:	e8 cc 12 00 00       	call   80ac74 <htons>
  8099a8:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8099ab:	66 89 42 02          	mov    %ax,0x2(%edx)
    IPH_OFFSET_SET(iphdr, 0);
  8099af:	66 c7 42 06 00 00    	movw   $0x0,0x6(%edx)
    IPH_ID_SET(iphdr, htons(ip_id));
  8099b5:	0f b7 05 2c 54 b3 00 	movzwl 0xb3542c,%eax
  8099bc:	89 04 24             	mov    %eax,(%esp)
  8099bf:	e8 b0 12 00 00       	call   80ac74 <htons>
  8099c4:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8099c7:	66 89 42 04          	mov    %ax,0x4(%edx)
    ++ip_id;
  8099cb:	66 83 05 2c 54 b3 00 	addw   $0x1,0xb3542c
  8099d2:	01 

    if (ip_addr_isany(src)) {
  8099d3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8099d7:	74 09                	je     8099e2 <ip_output_if+0x132>
  8099d9:	8b 55 0c             	mov    0xc(%ebp),%edx
  8099dc:	8b 02                	mov    (%edx),%eax
  8099de:	85 c0                	test   %eax,%eax
  8099e0:	75 15                	jne    8099f7 <ip_output_if+0x147>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  8099e2:	b8 00 00 00 00       	mov    $0x0,%eax
  8099e7:	83 fe fc             	cmp    $0xfffffffc,%esi
  8099ea:	74 03                	je     8099ef <ip_output_if+0x13f>
  8099ec:	8b 46 04             	mov    0x4(%esi),%eax
  8099ef:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8099f2:	89 42 0c             	mov    %eax,0xc(%edx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
    ++ip_id;

    if (ip_addr_isany(src)) {
  8099f5:	eb 06                	jmp    8099fd <ip_output_if+0x14d>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
    } else {
      ip_addr_set(&(iphdr->src), src);
  8099f7:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8099fa:	89 42 0c             	mov    %eax,0xc(%edx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  8099fd:	8b 45 d0             	mov    -0x30(%ebp),%eax
  809a00:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  809a06:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  809a0d:	00 
  809a0e:	89 04 24             	mov    %eax,(%esp)
  809a11:	e8 44 0f 00 00       	call   80a95a <inet_chksum>
  809a16:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809a19:	66 89 42 0a          	mov    %ax,0xa(%edx)
  809a1d:	eb 06                	jmp    809a25 <ip_output_if+0x175>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  809a1f:	8b 7b 04             	mov    0x4(%ebx),%edi
  809a22:	83 c7 10             	add    $0x10,%edi
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  809a25:	0f b7 46 2c          	movzwl 0x2c(%esi),%eax
  809a29:	66 85 c0             	test   %ax,%ax
  809a2c:	74 18                	je     809a46 <ip_output_if+0x196>
  809a2e:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  809a32:	73 12                	jae    809a46 <ip_output_if+0x196>
    return ip_frag(p,netif,dest);
  809a34:	89 7c 24 08          	mov    %edi,0x8(%esp)
  809a38:	89 74 24 04          	mov    %esi,0x4(%esp)
  809a3c:	89 1c 24             	mov    %ebx,(%esp)
  809a3f:	e8 ac 03 00 00       	call   809df0 <ip_frag>
  809a44:	eb 0e                	jmp    809a54 <ip_output_if+0x1a4>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  809a46:	89 7c 24 08          	mov    %edi,0x8(%esp)
  809a4a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809a4e:	89 34 24             	mov    %esi,(%esp)
  809a51:	ff 56 14             	call   *0x14(%esi)
  }
}
  809a54:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809a57:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809a5a:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809a5d:	89 ec                	mov    %ebp,%esp
  809a5f:	5d                   	pop    %ebp
  809a60:	c3                   	ret    

00809a61 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  809a61:	55                   	push   %ebp
  809a62:	89 e5                	mov    %esp,%ebp
  809a64:	56                   	push   %esi
  809a65:	53                   	push   %ebx
  809a66:	83 ec 10             	sub    $0x10,%esp
  809a69:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  809a6c:	8b 1d 04 f0 b3 00    	mov    0xb3f004,%ebx
  809a72:	85 db                	test   %ebx,%ebx
  809a74:	74 1c                	je     809a92 <ip_route+0x31>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  809a76:	89 1c 24             	mov    %ebx,(%esp)
  809a79:	e8 01 de ff ff       	call   80787f <netif_is_up>
  809a7e:	84 c0                	test   %al,%al
  809a80:	74 0a                	je     809a8c <ip_route+0x2b>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  809a82:	8b 43 04             	mov    0x4(%ebx),%eax
  809a85:	33 06                	xor    (%esi),%eax
  809a87:	85 43 08             	test   %eax,0x8(%ebx)
  809a8a:	74 28                	je     809ab4 <ip_route+0x53>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  809a8c:	8b 1b                	mov    (%ebx),%ebx
  809a8e:	85 db                	test   %ebx,%ebx
  809a90:	75 e4                	jne    809a76 <ip_route+0x15>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  809a92:	a1 08 f0 b3 00       	mov    0xb3f008,%eax
  809a97:	85 c0                	test   %eax,%eax
  809a99:	74 14                	je     809aaf <ip_route+0x4e>
  809a9b:	89 04 24             	mov    %eax,(%esp)
  809a9e:	e8 dc dd ff ff       	call   80787f <netif_is_up>
  809aa3:	84 c0                	test   %al,%al
  809aa5:	74 08                	je     809aaf <ip_route+0x4e>
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  809aa7:	8b 1d 08 f0 b3 00    	mov    0xb3f008,%ebx
  809aad:	eb 05                	jmp    809ab4 <ip_route+0x53>
  809aaf:	bb 00 00 00 00       	mov    $0x0,%ebx
}
  809ab4:	89 d8                	mov    %ebx,%eax
  809ab6:	83 c4 10             	add    $0x10,%esp
  809ab9:	5b                   	pop    %ebx
  809aba:	5e                   	pop    %esi
  809abb:	5d                   	pop    %ebp
  809abc:	c3                   	ret    

00809abd <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  809abd:	55                   	push   %ebp
  809abe:	89 e5                	mov    %esp,%ebp
  809ac0:	83 ec 48             	sub    $0x48,%esp
  809ac3:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  809ac6:	89 75 f8             	mov    %esi,-0x8(%ebp)
  809ac9:	89 7d fc             	mov    %edi,-0x4(%ebp)
  809acc:	8b 5d 10             	mov    0x10(%ebp),%ebx
  809acf:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  809ad3:	88 45 e7             	mov    %al,-0x19(%ebp)
  809ad6:	0f b6 7d 18          	movzbl 0x18(%ebp),%edi
  809ada:	0f b6 75 1c          	movzbl 0x1c(%ebp),%esi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  809ade:	89 1c 24             	mov    %ebx,(%esp)
  809ae1:	e8 7b ff ff ff       	call   809a61 <ip_route>
  809ae6:	89 c2                	mov    %eax,%edx
  809ae8:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809aed:	85 d2                	test   %edx,%edx
  809aef:	74 36                	je     809b27 <ip_output+0x6a>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  809af1:	89 54 24 18          	mov    %edx,0x18(%esp)
  809af5:	81 e6 ff 00 00 00    	and    $0xff,%esi
  809afb:	89 74 24 14          	mov    %esi,0x14(%esp)
  809aff:	81 e7 ff 00 00 00    	and    $0xff,%edi
  809b05:	89 7c 24 10          	mov    %edi,0x10(%esp)
  809b09:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  809b0d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809b11:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  809b15:	8b 45 0c             	mov    0xc(%ebp),%eax
  809b18:	89 44 24 04          	mov    %eax,0x4(%esp)
  809b1c:	8b 45 08             	mov    0x8(%ebp),%eax
  809b1f:	89 04 24             	mov    %eax,(%esp)
  809b22:	e8 89 fd ff ff       	call   8098b0 <ip_output_if>
}
  809b27:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809b2a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809b2d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809b30:	89 ec                	mov    %ebp,%esp
  809b32:	5d                   	pop    %ebp
  809b33:	c3                   	ret    

00809b34 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  809b34:	55                   	push   %ebp
  809b35:	89 e5                	mov    %esp,%ebp
  809b37:	83 ec 48             	sub    $0x48,%esp
  809b3a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  809b3d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  809b40:	89 7d fc             	mov    %edi,-0x4(%ebp)
  809b43:	8b 75 08             	mov    0x8(%ebp),%esi

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  809b46:	8b 5e 04             	mov    0x4(%esi),%ebx
  if (IPH_V(iphdr) != 4) {
  809b49:	0f b7 03             	movzwl (%ebx),%eax
  809b4c:	89 04 24             	mov    %eax,(%esp)
  809b4f:	e8 2d 11 00 00       	call   80ac81 <ntohs>
  809b54:	66 c1 e8 0c          	shr    $0xc,%ax
  809b58:	66 83 f8 04          	cmp    $0x4,%ax
  809b5c:	74 0d                	je     809b6b <ip_input+0x37>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  809b5e:	89 34 24             	mov    %esi,(%esp)
  809b61:	e8 12 e3 ff ff       	call   807e78 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  809b66:	e9 72 02 00 00       	jmp    809ddd <ip_input+0x2a9>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  809b6b:	0f b7 03             	movzwl (%ebx),%eax
  809b6e:	89 04 24             	mov    %eax,(%esp)
  809b71:	e8 0b 11 00 00       	call   80ac81 <ntohs>
  809b76:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  809b7a:	83 e0 3c             	and    $0x3c,%eax
  809b7d:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  809b81:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  809b85:	89 04 24             	mov    %eax,(%esp)
  809b88:	e8 f4 10 00 00       	call   80ac81 <ntohs>
  809b8d:	89 c7                	mov    %eax,%edi

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  809b8f:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809b93:	66 3b 46 0a          	cmp    0xa(%esi),%ax
  809b97:	77 06                	ja     809b9f <ip_input+0x6b>
  809b99:	66 3b 7e 08          	cmp    0x8(%esi),%di
  809b9d:	76 0d                	jbe    809bac <ip_input+0x78>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  809b9f:	89 34 24             	mov    %esi,(%esp)
  809ba2:	e8 d1 e2 ff ff       	call   807e78 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  809ba7:	e9 31 02 00 00       	jmp    809ddd <ip_input+0x2a9>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  809bac:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809bb0:	89 44 24 04          	mov    %eax,0x4(%esp)
  809bb4:	89 1c 24             	mov    %ebx,(%esp)
  809bb7:	e8 9e 0d 00 00       	call   80a95a <inet_chksum>
  809bbc:	66 85 c0             	test   %ax,%ax
  809bbf:	74 0d                	je     809bce <ip_input+0x9a>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  809bc1:	89 34 24             	mov    %esi,(%esp)
  809bc4:	e8 af e2 ff ff       	call   807e78 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  809bc9:	e9 0f 02 00 00       	jmp    809ddd <ip_input+0x2a9>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  809bce:	0f b7 ff             	movzwl %di,%edi
  809bd1:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809bd5:	89 34 24             	mov    %esi,(%esp)
  809bd8:	e8 23 e4 ff ff       	call   808000 <pbuf_realloc>
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  809bdd:	8d 43 10             	lea    0x10(%ebx),%eax
  809be0:	89 45 dc             	mov    %eax,-0x24(%ebp)
  809be3:	8b 7d 0c             	mov    0xc(%ebp),%edi
  809be6:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
        netif = netif->next;
      }
      if (netif == inp) {
        netif = netif->next;
      }
    } while(netif != NULL);
  809bed:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  809bf0:	89 de                	mov    %ebx,%esi
  809bf2:	bb 01 00 00 00       	mov    $0x1,%ebx
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  809bf7:	89 3c 24             	mov    %edi,(%esp)
  809bfa:	e8 80 dc ff ff       	call   80787f <netif_is_up>
  809bff:	84 c0                	test   %al,%al
  809c01:	74 27                	je     809c2a <ip_input+0xf6>
  809c03:	83 ff fc             	cmp    $0xfffffffc,%edi
  809c06:	74 22                	je     809c2a <ip_input+0xf6>
  809c08:	8b 47 04             	mov    0x4(%edi),%eax
  809c0b:	85 c0                	test   %eax,%eax
  809c0d:	8d 76 00             	lea    0x0(%esi),%esi
  809c10:	74 18                	je     809c2a <ip_input+0xf6>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  809c12:	3b 46 10             	cmp    0x10(%esi),%eax
  809c15:	74 36                	je     809c4d <ip_input+0x119>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  809c17:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809c1b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  809c1e:	89 04 24             	mov    %eax,(%esp)
  809c21:	e8 42 fc ff ff       	call   809868 <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  809c26:	84 c0                	test   %al,%al
  809c28:	75 23                	jne    809c4d <ip_input+0x119>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  809c2a:	85 db                	test   %ebx,%ebx
  809c2c:	74 08                	je     809c36 <ip_input+0x102>
        first = 0;
        netif = netif_list;
  809c2e:	8b 3d 04 f0 b3 00    	mov    0xb3f004,%edi
  809c34:	eb 02                	jmp    809c38 <ip_input+0x104>
      } else {
        netif = netif->next;
  809c36:	8b 3f                	mov    (%edi),%edi
      }
      if (netif == inp) {
  809c38:	3b 7d 0c             	cmp    0xc(%ebp),%edi
  809c3b:	75 05                	jne    809c42 <ip_input+0x10e>
        netif = netif->next;
  809c3d:	8b 45 0c             	mov    0xc(%ebp),%eax
  809c40:	8b 38                	mov    (%eax),%edi
      }
    } while(netif != NULL);
  809c42:	85 ff                	test   %edi,%edi
  809c44:	74 12                	je     809c58 <ip_input+0x124>
  809c46:	bb 00 00 00 00       	mov    $0x0,%ebx
  809c4b:	eb aa                	jmp    809bf7 <ip_input+0xc3>
  809c4d:	89 f3                	mov    %esi,%ebx
  809c4f:	8b 75 d4             	mov    -0x2c(%ebp),%esi
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  809c52:	85 ff                	test   %edi,%edi
  809c54:	75 2e                	jne    809c84 <ip_input+0x150>
  809c56:	eb 05                	jmp    809c5d <ip_input+0x129>
  809c58:	89 f3                	mov    %esi,%ebx
  809c5a:	8b 75 d4             	mov    -0x2c(%ebp),%esi
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  809c5d:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809c61:	89 04 24             	mov    %eax,(%esp)
  809c64:	e8 18 10 00 00       	call   80ac81 <ntohs>
  809c69:	3c 11                	cmp    $0x11,%al
  809c6b:	75 17                	jne    809c84 <ip_input+0x150>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  809c6d:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809c71:	0f b7 44 03 02       	movzwl 0x2(%ebx,%eax,1),%eax
  809c76:	89 04 24             	mov    %eax,(%esp)
  809c79:	e8 03 10 00 00       	call   80ac81 <ntohs>
  809c7e:	66 83 f8 44          	cmp    $0x44,%ax
  809c82:	74 4e                	je     809cd2 <ip_input+0x19e>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  809c84:	8b 45 0c             	mov    0xc(%ebp),%eax
  809c87:	89 44 24 04          	mov    %eax,0x4(%esp)
  809c8b:	8d 43 0c             	lea    0xc(%ebx),%eax
  809c8e:	89 04 24             	mov    %eax,(%esp)
  809c91:	e8 d2 fb ff ff       	call   809868 <ip_addr_isbroadcast>
  809c96:	84 c0                	test   %al,%al
  809c98:	75 2b                	jne    809cc5 <ip_input+0x191>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  809c9a:	8b 43 0c             	mov    0xc(%ebx),%eax
  809c9d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  809ca0:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809ca7:	e8 0e 12 00 00       	call   80aeba <ntohl>
  809cac:	89 45 e0             	mov    %eax,-0x20(%ebp)
  809caf:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809cb6:	e8 ff 11 00 00       	call   80aeba <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  809cbb:	8b 55 e0             	mov    -0x20(%ebp),%edx
  809cbe:	23 55 dc             	and    -0x24(%ebp),%edx
  809cc1:	39 c2                	cmp    %eax,%edx
  809cc3:	75 10                	jne    809cd5 <ip_input+0x1a1>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  809cc5:	89 34 24             	mov    %esi,(%esp)
  809cc8:	e8 ab e1 ff ff       	call   807e78 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  809ccd:	e9 0b 01 00 00       	jmp    809ddd <ip_input+0x2a9>
  809cd2:	8b 7d 0c             	mov    0xc(%ebp),%edi
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  809cd5:	85 ff                	test   %edi,%edi
  809cd7:	75 11                	jne    809cea <ip_input+0x1b6>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  809cd9:	89 34 24             	mov    %esi,(%esp)
  809cdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  809ce0:	e8 93 e1 ff ff       	call   807e78 <pbuf_free>
    return ERR_OK;
  809ce5:	e9 f3 00 00 00       	jmp    809ddd <ip_input+0x2a9>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  809cea:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
  809cee:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  809cf5:	e8 7a 0f 00 00       	call   80ac74 <htons>
  809cfa:	66 85 f8             	test   %di,%ax
  809cfd:	74 15                	je     809d14 <ip_input+0x1e0>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  809cff:	89 34 24             	mov    %esi,(%esp)
  809d02:	e8 4a 05 00 00       	call   80a251 <ip_reass>
  809d07:	89 c6                	mov    %eax,%esi
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  809d09:	85 c0                	test   %eax,%eax
  809d0b:	0f 84 cc 00 00 00    	je     809ddd <ip_input+0x2a9>
      return ERR_OK;
    }
    iphdr = p->payload;
  809d11:	8b 58 04             	mov    0x4(%eax),%ebx
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  809d14:	8b 45 0c             	mov    0xc(%ebp),%eax
  809d17:	89 44 24 04          	mov    %eax,0x4(%esp)
  809d1b:	89 34 24             	mov    %esi,(%esp)
  809d1e:	e8 30 7e 00 00       	call   811b53 <raw_input>
  809d23:	84 c0                	test   %al,%al
  809d25:	0f 85 b2 00 00 00    	jne    809ddd <ip_input+0x2a9>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  809d2b:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809d2f:	89 04 24             	mov    %eax,(%esp)
  809d32:	e8 4a 0f 00 00       	call   80ac81 <ntohs>
  809d37:	0f b6 c0             	movzbl %al,%eax
  809d3a:	83 f8 06             	cmp    $0x6,%eax
  809d3d:	74 24                	je     809d63 <ip_input+0x22f>
  809d3f:	83 f8 11             	cmp    $0x11,%eax
  809d42:	74 0e                	je     809d52 <ip_input+0x21e>
  809d44:	83 f8 01             	cmp    $0x1,%eax
  809d47:	75 3c                	jne    809d85 <ip_input+0x251>
  809d49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  809d50:	eb 22                	jmp    809d74 <ip_input+0x240>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  809d52:	8b 45 0c             	mov    0xc(%ebp),%eax
  809d55:	89 44 24 04          	mov    %eax,0x4(%esp)
  809d59:	89 34 24             	mov    %esi,(%esp)
  809d5c:	e8 c6 26 00 00       	call   80c427 <udp_input>
      break;
  809d61:	eb 7a                	jmp    809ddd <ip_input+0x2a9>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  809d63:	8b 45 0c             	mov    0xc(%ebp),%eax
  809d66:	89 44 24 04          	mov    %eax,0x4(%esp)
  809d6a:	89 34 24             	mov    %esi,(%esp)
  809d6d:	e8 a5 6d 00 00       	call   810b17 <tcp_input>
      break;
  809d72:	eb 69                	jmp    809ddd <ip_input+0x2a9>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  809d74:	8b 45 0c             	mov    0xc(%ebp),%eax
  809d77:	89 44 24 04          	mov    %eax,0x4(%esp)
  809d7b:	89 34 24             	mov    %esi,(%esp)
  809d7e:	e8 a1 80 00 00       	call   811e24 <icmp_input>
      break;
  809d83:	eb 58                	jmp    809ddd <ip_input+0x2a9>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  809d85:	8b 45 0c             	mov    0xc(%ebp),%eax
  809d88:	89 44 24 04          	mov    %eax,0x4(%esp)
  809d8c:	8d 43 10             	lea    0x10(%ebx),%eax
  809d8f:	89 04 24             	mov    %eax,(%esp)
  809d92:	e8 d1 fa ff ff       	call   809868 <ip_addr_isbroadcast>
  809d97:	84 c0                	test   %al,%al
  809d99:	75 3a                	jne    809dd5 <ip_input+0x2a1>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  809d9b:	8b 43 10             	mov    0x10(%ebx),%eax
  809d9e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809da1:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809da8:	e8 0d 11 00 00       	call   80aeba <ntohl>
  809dad:	89 c7                	mov    %eax,%edi
  809daf:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809db6:	e8 ff 10 00 00       	call   80aeba <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  809dbb:	23 7d e4             	and    -0x1c(%ebp),%edi
  809dbe:	39 c7                	cmp    %eax,%edi
  809dc0:	74 13                	je     809dd5 <ip_input+0x2a1>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  809dc2:	89 5e 04             	mov    %ebx,0x4(%esi)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  809dc5:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  809dcc:	00 
  809dcd:	89 34 24             	mov    %esi,(%esp)
  809dd0:	e8 3d 7f 00 00       	call   811d12 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  809dd5:	89 34 24             	mov    %esi,(%esp)
  809dd8:	e8 9b e0 ff ff       	call   807e78 <pbuf_free>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  809ddd:	b8 00 00 00 00       	mov    $0x0,%eax
  809de2:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809de5:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809de8:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809deb:	89 ec                	mov    %ebp,%esp
  809ded:	5d                   	pop    %ebp
  809dee:	c3                   	ret    
	...

00809df0 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  809df0:	55                   	push   %ebp
  809df1:	89 e5                	mov    %esp,%ebp
  809df3:	57                   	push   %edi
  809df4:	56                   	push   %esi
  809df5:	53                   	push   %ebx
  809df6:	83 ec 5c             	sub    $0x5c,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  809df9:	8b 45 0c             	mov    0xc(%ebp),%eax
  809dfc:	0f b7 70 2c          	movzwl 0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  809e00:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  809e07:	00 
  809e08:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809e0f:	00 
  809e10:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809e17:	e8 17 e3 ff ff       	call   808133 <pbuf_alloc>
  809e1c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if (rambuf == NULL) {
  809e1f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809e24:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  809e28:	0f 84 ca 01 00 00    	je     809ff8 <ip_frag+0x208>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  809e2e:	8b 55 d8             	mov    -0x28(%ebp),%edx
  809e31:	66 89 72 0a          	mov    %si,0xa(%edx)
  809e35:	66 89 72 08          	mov    %si,0x8(%edx)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  809e39:	bb 63 54 b3 00       	mov    $0xb35463,%ebx
  809e3e:	83 e3 fc             	and    $0xfffffffc,%ebx
  809e41:	89 5a 04             	mov    %ebx,0x4(%edx)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  809e44:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  809e4b:	00 
  809e4c:	8b 55 08             	mov    0x8(%ebp),%edx
  809e4f:	8b 42 04             	mov    0x4(%edx),%eax
  809e52:	89 44 24 04          	mov    %eax,0x4(%esp)
  809e56:	89 1c 24             	mov    %ebx,(%esp)
  809e59:	e8 d3 77 ff ff       	call   801631 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  809e5e:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809e62:	89 04 24             	mov    %eax,(%esp)
  809e65:	e8 17 0e 00 00       	call   80ac81 <ntohs>
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;
  809e6a:	89 c2                	mov    %eax,%edx
  809e6c:	66 81 e2 00 20       	and    $0x2000,%dx
  809e71:	66 89 55 d2          	mov    %dx,-0x2e(%ebp)

  left = p->tot_len - IP_HLEN;
  809e75:	8b 55 08             	mov    0x8(%ebp),%edx
  809e78:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx

  nfb = (mtu - IP_HLEN) / 8;
  809e7c:	0f b7 f6             	movzwl %si,%esi
  809e7f:	83 ee 14             	sub    $0x14,%esi
  809e82:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  809e85:	89 f2                	mov    %esi,%edx
  809e87:	c1 fa 1f             	sar    $0x1f,%edx
  809e8a:	c1 ea 1d             	shr    $0x1d,%edx
  809e8d:	01 f2                	add    %esi,%edx
  809e8f:	c1 ea 03             	shr    $0x3,%edx
  809e92:	66 89 55 b8          	mov    %dx,-0x48(%ebp)

  while (left) {
  809e96:	66 83 e9 14          	sub    $0x14,%cx
  809e9a:	66 89 4d e6          	mov    %cx,-0x1a(%ebp)
  809e9e:	0f 84 44 01 00 00    	je     809fe8 <ip_frag+0x1f8>
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  809ea4:	66 25 ff 1f          	and    $0x1fff,%ax
  809ea8:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  809eac:	66 c7 45 e2 14 00    	movw   $0x14,-0x1e(%ebp)
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;
  809eb2:	c1 e2 03             	shl    $0x3,%edx
  809eb5:	66 89 55 b2          	mov    %dx,-0x4e(%ebp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  809eb9:	8d 43 14             	lea    0x14(%ebx),%eax
  809ebc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
    last = (left <= mtu - IP_HLEN);
  809ebf:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  809ec3:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  809ec6:	0f 9d c0             	setge  %al
  809ec9:	0f b6 f0             	movzbl %al,%esi

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  809ecc:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809ed0:	66 25 ff 1f          	and    $0x1fff,%ax
  809ed4:	66 0b 45 d2          	or     -0x2e(%ebp),%ax
  809ed8:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    if (!last)
  809edc:	0f b7 7d e6          	movzwl -0x1a(%ebp),%edi
  809ee0:	66 85 f6             	test   %si,%si
  809ee3:	75 0a                	jne    809eef <ip_frag+0xff>
      tmp = tmp | IP_MF;
  809ee5:	66 81 4d e4 00 20    	orw    $0x2000,-0x1c(%ebp)
  809eeb:	0f b7 7d b2          	movzwl -0x4e(%ebp),%edi

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  809eef:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  809ef3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809ef7:	0f b7 c7             	movzwl %di,%eax
  809efa:	89 44 24 08          	mov    %eax,0x8(%esp)
  809efe:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  809f01:	89 54 24 04          	mov    %edx,0x4(%esp)
  809f05:	8b 45 08             	mov    0x8(%ebp),%eax
  809f08:	89 04 24             	mov    %eax,(%esp)
  809f0b:	e8 e6 dc ff ff       	call   807bf6 <pbuf_copy_partial>
  809f10:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  809f14:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  809f18:	89 04 24             	mov    %eax,(%esp)
  809f1b:	e8 54 0d 00 00       	call   80ac74 <htons>
  809f20:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  809f24:	8d 47 14             	lea    0x14(%edi),%eax
  809f27:	0f b7 c0             	movzwl %ax,%eax
  809f2a:	89 04 24             	mov    %eax,(%esp)
  809f2d:	e8 42 0d 00 00       	call   80ac74 <htons>
  809f32:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  809f36:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  809f3c:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  809f43:	00 
  809f44:	89 1c 24             	mov    %ebx,(%esp)
  809f47:	e8 0e 0a 00 00       	call   80a95a <inet_chksum>
  809f4c:	66 89 43 0a          	mov    %ax,0xa(%ebx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  809f50:	66 85 f6             	test   %si,%si
  809f53:	74 19                	je     809f6e <ip_frag+0x17e>
      pbuf_realloc(rambuf, left + IP_HLEN);
  809f55:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  809f59:	83 c0 14             	add    $0x14,%eax
  809f5c:	0f b7 c0             	movzwl %ax,%eax
  809f5f:	89 44 24 04          	mov    %eax,0x4(%esp)
  809f63:	8b 55 d8             	mov    -0x28(%ebp),%edx
  809f66:	89 14 24             	mov    %edx,(%esp)
  809f69:	e8 92 e0 ff ff       	call   808000 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  809f6e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809f75:	00 
  809f76:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809f7d:	00 
  809f7e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809f85:	e8 a9 e1 ff ff       	call   808133 <pbuf_alloc>
  809f8a:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  809f8c:	85 c0                	test   %eax,%eax
  809f8e:	74 46                	je     809fd6 <ip_frag+0x1e6>
      pbuf_chain(header, rambuf);
  809f90:	8b 45 d8             	mov    -0x28(%ebp),%eax
  809f93:	89 44 24 04          	mov    %eax,0x4(%esp)
  809f97:	89 34 24             	mov    %esi,(%esp)
  809f9a:	e8 3d db ff ff       	call   807adc <pbuf_chain>
      netif->output(netif, header, dest);
  809f9f:	8b 55 10             	mov    0x10(%ebp),%edx
  809fa2:	89 54 24 08          	mov    %edx,0x8(%esp)
  809fa6:	89 74 24 04          	mov    %esi,0x4(%esp)
  809faa:	8b 45 0c             	mov    0xc(%ebp),%eax
  809fad:	89 04 24             	mov    %eax,(%esp)
  809fb0:	ff 50 14             	call   *0x14(%eax)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  809fb3:	89 34 24             	mov    %esi,(%esp)
  809fb6:	e8 bd de ff ff       	call   807e78 <pbuf_free>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  809fbb:	66 29 7d e6          	sub    %di,-0x1a(%ebp)
  809fbf:	74 27                	je     809fe8 <ip_frag+0x1f8>

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  809fc1:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  809fc5:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  809fc9:	0f b7 55 b8          	movzwl -0x48(%ebp),%edx
  809fcd:	66 01 55 e0          	add    %dx,-0x20(%ebp)
  809fd1:	e9 e9 fe ff ff       	jmp    809ebf <ip_frag+0xcf>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  809fd6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  809fd9:	89 04 24             	mov    %eax,(%esp)
  809fdc:	e8 97 de ff ff       	call   807e78 <pbuf_free>
  809fe1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
  809fe6:	eb 10                	jmp    809ff8 <ip_frag+0x208>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  809fe8:	8b 55 d8             	mov    -0x28(%ebp),%edx
  809feb:	89 14 24             	mov    %edx,(%esp)
  809fee:	e8 85 de ff ff       	call   807e78 <pbuf_free>
  809ff3:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  809ff8:	83 c4 5c             	add    $0x5c,%esp
  809ffb:	5b                   	pop    %ebx
  809ffc:	5e                   	pop    %esi
  809ffd:	5f                   	pop    %edi
  809ffe:	5d                   	pop    %ebp
  809fff:	c3                   	ret    

0080a000 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  80a000:	55                   	push   %ebp
  80a001:	89 e5                	mov    %esp,%ebp
  80a003:	83 ec 18             	sub    $0x18,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  80a006:	8b 0d 40 54 b3 00    	mov    0xb35440,%ecx
  80a00c:	39 c1                	cmp    %eax,%ecx
  80a00e:	75 0a                	jne    80a01a <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  80a010:	8b 11                	mov    (%ecx),%edx
  80a012:	89 15 40 54 b3 00    	mov    %edx,0xb35440
  80a018:	eb 24                	jmp    80a03e <ip_reass_dequeue_datagram+0x3e>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  80a01a:	85 d2                	test   %edx,%edx
  80a01c:	75 1c                	jne    80a03a <ip_reass_dequeue_datagram+0x3a>
  80a01e:	c7 44 24 08 79 3b 81 	movl   $0x813b79,0x8(%esp)
  80a025:	00 
  80a026:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
  80a02d:	00 
  80a02e:	c7 04 24 92 3b 81 00 	movl   $0x813b92,(%esp)
  80a035:	e8 ae 69 ff ff       	call   8009e8 <_panic>
    prev->next = ipr->next;
  80a03a:	8b 08                	mov    (%eax),%ecx
  80a03c:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  80a03e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a042:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  80a049:	e8 92 d6 ff ff       	call   8076e0 <memp_free>
}
  80a04e:	c9                   	leave  
  80a04f:	c3                   	ret    

0080a050 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  80a050:	55                   	push   %ebp
  80a051:	89 e5                	mov    %esp,%ebp
  80a053:	57                   	push   %edi
  80a054:	56                   	push   %esi
  80a055:	53                   	push   %ebx
  80a056:	83 ec 2c             	sub    $0x2c,%esp
  80a059:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80a05c:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  80a05f:	39 c2                	cmp    %eax,%edx
  80a061:	75 1c                	jne    80a07f <ip_reass_free_complete_datagram+0x2f>
  80a063:	c7 44 24 08 af 3b 81 	movl   $0x813baf,0x8(%esp)
  80a06a:	00 
  80a06b:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80a072:	00 
  80a073:	c7 04 24 92 3b 81 00 	movl   $0x813b92,(%esp)
  80a07a:	e8 69 69 ff ff       	call   8009e8 <_panic>
  if (prev != NULL) {
  80a07f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80a083:	74 26                	je     80a0ab <ip_reass_free_complete_datagram+0x5b>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  80a085:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a088:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a08b:	39 10                	cmp    %edx,(%eax)
  80a08d:	74 1c                	je     80a0ab <ip_reass_free_complete_datagram+0x5b>
  80a08f:	c7 44 24 08 bb 3b 81 	movl   $0x813bbb,0x8(%esp)
  80a096:	00 
  80a097:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  80a09e:	00 
  80a09f:	c7 04 24 92 3b 81 00 	movl   $0x813b92,(%esp)
  80a0a6:	e8 3d 69 ff ff       	call   8009e8 <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  80a0ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a0ae:	8b 58 04             	mov    0x4(%eax),%ebx
  80a0b1:	8b 43 04             	mov    0x4(%ebx),%eax
  if (iprh->start == 0) {
  80a0b4:	bf 00 00 00 00       	mov    $0x0,%edi
  80a0b9:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  80a0be:	75 47                	jne    80a107 <ip_reass_free_complete_datagram+0xb7>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  80a0c0:	8b 00                	mov    (%eax),%eax
  80a0c2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a0c5:	89 42 04             	mov    %eax,0x4(%edx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  80a0c8:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a0cf:	00 
  80a0d0:	89 d0                	mov    %edx,%eax
  80a0d2:	83 c0 08             	add    $0x8,%eax
  80a0d5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a0d9:	8b 43 04             	mov    0x4(%ebx),%eax
  80a0dc:	89 04 24             	mov    %eax,(%esp)
  80a0df:	e8 4d 75 ff ff       	call   801631 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  80a0e4:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80a0eb:	00 
  80a0ec:	89 1c 24             	mov    %ebx,(%esp)
  80a0ef:	e8 0c 7b 00 00       	call   811c00 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  80a0f4:	89 1c 24             	mov    %ebx,(%esp)
  80a0f7:	e8 14 d9 ff ff       	call   807a10 <pbuf_clen>
  80a0fc:	0f b6 f8             	movzbl %al,%edi
    pbuf_free(p);
  80a0ff:	89 1c 24             	mov    %ebx,(%esp)
  80a102:	e8 71 dd ff ff       	call   807e78 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  80a107:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a10a:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  80a10d:	85 db                	test   %ebx,%ebx
  80a10f:	74 22                	je     80a133 <ip_reass_free_complete_datagram+0xe3>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  80a111:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  80a114:	8b 30                	mov    (%eax),%esi
    pbufs_freed += pbuf_clen(pcur);
  80a116:	89 1c 24             	mov    %ebx,(%esp)
  80a119:	e8 f2 d8 ff ff       	call   807a10 <pbuf_clen>
  80a11e:	0f b6 c0             	movzbl %al,%eax
  80a121:	01 c7                	add    %eax,%edi
    pbuf_free(pcur);    
  80a123:	89 1c 24             	mov    %ebx,(%esp)
  80a126:	e8 4d dd ff ff       	call   807e78 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  80a12b:	85 f6                	test   %esi,%esi
  80a12d:	74 04                	je     80a133 <ip_reass_free_complete_datagram+0xe3>
  80a12f:	89 f3                	mov    %esi,%ebx
  80a131:	eb de                	jmp    80a111 <ip_reass_free_complete_datagram+0xc1>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  80a133:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a136:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a139:	e8 c2 fe ff ff       	call   80a000 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  80a13e:	0f b7 05 44 54 b3 00 	movzwl 0xb35444,%eax
  80a145:	0f b7 d0             	movzwl %ax,%edx
  80a148:	39 fa                	cmp    %edi,%edx
  80a14a:	7d 1c                	jge    80a168 <ip_reass_free_complete_datagram+0x118>
  80a14c:	c7 44 24 08 cd 3b 81 	movl   $0x813bcd,0x8(%esp)
  80a153:	00 
  80a154:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  80a15b:	00 
  80a15c:	c7 04 24 92 3b 81 00 	movl   $0x813b92,(%esp)
  80a163:	e8 80 68 ff ff       	call   8009e8 <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  80a168:	66 29 f8             	sub    %di,%ax
  80a16b:	66 a3 44 54 b3 00    	mov    %ax,0xb35444

  return pbufs_freed;
}
  80a171:	89 f8                	mov    %edi,%eax
  80a173:	83 c4 2c             	add    $0x2c,%esp
  80a176:	5b                   	pop    %ebx
  80a177:	5e                   	pop    %esi
  80a178:	5f                   	pop    %edi
  80a179:	5d                   	pop    %ebp
  80a17a:	c3                   	ret    

0080a17b <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  80a17b:	55                   	push   %ebp
  80a17c:	89 e5                	mov    %esp,%ebp
  80a17e:	57                   	push   %edi
  80a17f:	56                   	push   %esi
  80a180:	53                   	push   %ebx
  80a181:	83 ec 2c             	sub    $0x2c,%esp
  80a184:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80a187:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80a18a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  80a191:	8b 0d 40 54 b3 00    	mov    0xb35440,%ecx
    while (r != NULL) {
  80a197:	85 c9                	test   %ecx,%ecx
  80a199:	74 6f                	je     80a20a <ip_reass_remove_oldest_datagram+0x8f>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  80a19b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a19e:	8b 78 0c             	mov    0xc(%eax),%edi
  80a1a1:	bb 00 00 00 00       	mov    $0x0,%ebx
  80a1a6:	ba 00 00 00 00       	mov    $0x0,%edx
  80a1ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80a1b0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  80a1b3:	39 79 14             	cmp    %edi,0x14(%ecx)
  80a1b6:	75 15                	jne    80a1cd <ip_reass_remove_oldest_datagram+0x52>
  80a1b8:	8b 51 18             	mov    0x18(%ecx),%edx
  80a1bb:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80a1be:	3b 56 10             	cmp    0x10(%esi),%edx
  80a1c1:	75 0a                	jne    80a1cd <ip_reass_remove_oldest_datagram+0x52>
  80a1c3:	0f b7 51 0c          	movzwl 0xc(%ecx),%edx
  80a1c7:	66 3b 56 04          	cmp    0x4(%esi),%dx
  80a1cb:	74 14                	je     80a1e1 <ip_reass_remove_oldest_datagram+0x66>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  80a1cd:	83 c3 01             	add    $0x1,%ebx
        if (oldest == NULL) {
  80a1d0:	85 c0                	test   %eax,%eax
  80a1d2:	74 0b                	je     80a1df <ip_reass_remove_oldest_datagram+0x64>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
  80a1d4:	0f b6 71 1f          	movzbl 0x1f(%ecx),%esi
  80a1d8:	89 f2                	mov    %esi,%edx
  80a1da:	3a 50 1f             	cmp    0x1f(%eax),%dl
  80a1dd:	77 02                	ja     80a1e1 <ip_reass_remove_oldest_datagram+0x66>
  80a1df:	89 c8                	mov    %ecx,%eax
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  80a1e1:	8b 31                	mov    (%ecx),%esi
  80a1e3:	85 f6                	test   %esi,%esi
  80a1e5:	74 07                	je     80a1ee <ip_reass_remove_oldest_datagram+0x73>
  80a1e7:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80a1ea:	89 f1                	mov    %esi,%ecx
  80a1ec:	eb c5                	jmp    80a1b3 <ip_reass_remove_oldest_datagram+0x38>
  80a1ee:	8b 55 d4             	mov    -0x2c(%ebp),%edx
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  80a1f1:	85 c0                	test   %eax,%eax
  80a1f3:	74 08                	je     80a1fd <ip_reass_remove_oldest_datagram+0x82>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  80a1f5:	e8 56 fe ff ff       	call   80a050 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  80a1fa:	01 45 e0             	add    %eax,-0x20(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  80a1fd:	8b 75 dc             	mov    -0x24(%ebp),%esi
  80a200:	39 75 e0             	cmp    %esi,-0x20(%ebp)
  80a203:	7d 05                	jge    80a20a <ip_reass_remove_oldest_datagram+0x8f>
  80a205:	83 fb 01             	cmp    $0x1,%ebx
  80a208:	7f 87                	jg     80a191 <ip_reass_remove_oldest_datagram+0x16>
  return pbufs_freed;
}
  80a20a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a20d:	83 c4 2c             	add    $0x2c,%esp
  80a210:	5b                   	pop    %ebx
  80a211:	5e                   	pop    %esi
  80a212:	5f                   	pop    %edi
  80a213:	5d                   	pop    %ebp
  80a214:	c3                   	ret    

0080a215 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  80a215:	55                   	push   %ebp
  80a216:	89 e5                	mov    %esp,%ebp
  80a218:	56                   	push   %esi
  80a219:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  80a21a:	a1 40 54 b3 00       	mov    0xb35440,%eax
  while (r != NULL) {
  80a21f:	85 c0                	test   %eax,%eax
  80a221:	74 2a                	je     80a24d <ip_reass_tmr+0x38>
  80a223:	be 00 00 00 00       	mov    $0x0,%esi
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  80a228:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  80a22c:	84 d2                	test   %dl,%dl
  80a22e:	74 0c                	je     80a23c <ip_reass_tmr+0x27>
      r->timer--;
  80a230:	83 ea 01             	sub    $0x1,%edx
  80a233:	88 50 1f             	mov    %dl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
      r = r->next;
  80a236:	8b 18                	mov    (%eax),%ebx
  80a238:	89 c6                	mov    %eax,%esi
  80a23a:	eb 09                	jmp    80a245 <ip_reass_tmr+0x30>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  80a23c:	8b 18                	mov    (%eax),%ebx
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  80a23e:	89 f2                	mov    %esi,%edx
  80a240:	e8 0b fe ff ff       	call   80a050 <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  80a245:	85 db                	test   %ebx,%ebx
  80a247:	74 04                	je     80a24d <ip_reass_tmr+0x38>
  80a249:	89 d8                	mov    %ebx,%eax
  80a24b:	eb db                	jmp    80a228 <ip_reass_tmr+0x13>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  80a24d:	5b                   	pop    %ebx
  80a24e:	5e                   	pop    %esi
  80a24f:	5d                   	pop    %ebp
  80a250:	c3                   	ret    

0080a251 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  80a251:	55                   	push   %ebp
  80a252:	89 e5                	mov    %esp,%ebp
  80a254:	57                   	push   %edi
  80a255:	56                   	push   %esi
  80a256:	53                   	push   %ebx
  80a257:	83 ec 3c             	sub    $0x3c,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  80a25a:	8b 45 08             	mov    0x8(%ebp),%eax
  80a25d:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  80a260:	0f b7 03             	movzwl (%ebx),%eax
  80a263:	89 04 24             	mov    %eax,(%esp)
  80a266:	e8 16 0a 00 00       	call   80ac81 <ntohs>
  80a26b:	c1 e8 06             	shr    $0x6,%eax
  80a26e:	83 e0 3c             	and    $0x3c,%eax
  80a271:	83 f8 14             	cmp    $0x14,%eax
  80a274:	0f 85 f3 04 00 00    	jne    80a76d <ip_reass+0x51c>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80a27a:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80a27e:	89 04 24             	mov    %eax,(%esp)
  80a281:	e8 fb 09 00 00       	call   80ac81 <ntohs>
  80a286:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80a28a:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80a28e:	89 04 24             	mov    %eax,(%esp)
  80a291:	e8 eb 09 00 00       	call   80ac81 <ntohs>
  80a296:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  80a29a:	0f b7 03             	movzwl (%ebx),%eax
  80a29d:	89 04 24             	mov    %eax,(%esp)
  80a2a0:	e8 dc 09 00 00       	call   80ac81 <ntohs>
  80a2a5:	66 89 45 dc          	mov    %ax,-0x24(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  80a2a9:	8b 55 08             	mov    0x8(%ebp),%edx
  80a2ac:	89 14 24             	mov    %edx,(%esp)
  80a2af:	e8 5c d7 ff ff       	call   807a10 <pbuf_clen>
  80a2b4:	89 c7                	mov    %eax,%edi
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  80a2b6:	0f b6 c8             	movzbl %al,%ecx
  80a2b9:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80a2bc:	0f b7 05 44 54 b3 00 	movzwl 0xb35444,%eax
  80a2c3:	01 c8                	add    %ecx,%eax
  80a2c5:	83 f8 0a             	cmp    $0xa,%eax
  80a2c8:	7e 24                	jle    80a2ee <ip_reass+0x9d>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  80a2ca:	89 ca                	mov    %ecx,%edx
  80a2cc:	89 d8                	mov    %ebx,%eax
  80a2ce:	e8 a8 fe ff ff       	call   80a17b <ip_reass_remove_oldest_datagram>
  80a2d3:	85 c0                	test   %eax,%eax
  80a2d5:	0f 84 92 04 00 00    	je     80a76d <ip_reass+0x51c>
  80a2db:	0f b7 05 44 54 b3 00 	movzwl 0xb35444,%eax
  80a2e2:	03 45 e0             	add    -0x20(%ebp),%eax
  80a2e5:	83 f8 0a             	cmp    $0xa,%eax
  80a2e8:	0f 8f 7f 04 00 00    	jg     80a76d <ip_reass+0x51c>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  80a2ee:	8b 35 40 54 b3 00    	mov    0xb35440,%esi
  80a2f4:	85 f6                	test   %esi,%esi
  80a2f6:	0f 84 97 04 00 00    	je     80a793 <ip_reass+0x542>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  80a2fc:	8b 53 0c             	mov    0xc(%ebx),%edx
  80a2ff:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  80a306:	b9 00 00 00 00       	mov    $0x0,%ecx
  80a30b:	39 56 14             	cmp    %edx,0x14(%esi)
  80a30e:	75 12                	jne    80a322 <ip_reass+0xd1>
  80a310:	8b 46 18             	mov    0x18(%esi),%eax
  80a313:	3b 43 10             	cmp    0x10(%ebx),%eax
  80a316:	75 0a                	jne    80a322 <ip_reass+0xd1>
  80a318:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80a31c:	66 3b 43 04          	cmp    0x4(%ebx),%ax
  80a320:	74 11                	je     80a333 <ip_reass+0xe2>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  80a322:	8b 06                	mov    (%esi),%eax
  80a324:	85 c0                	test   %eax,%eax
  80a326:	75 05                	jne    80a32d <ip_reass+0xdc>
  80a328:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  80a32b:	eb 10                	jmp    80a33d <ip_reass+0xec>
  80a32d:	89 f1                	mov    %esi,%ecx
  80a32f:	89 c6                	mov    %eax,%esi
  80a331:	eb d8                	jmp    80a30b <ip_reass+0xba>
  80a333:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80a336:	89 75 cc             	mov    %esi,-0x34(%ebp)
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
  80a339:	85 f6                	test   %esi,%esi
  80a33b:	75 7d                	jne    80a3ba <ip_reass+0x169>
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  80a33d:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  80a344:	e8 db d3 ff ff       	call   807724 <memp_malloc>
  80a349:	89 c6                	mov    %eax,%esi
  if (ipr == NULL) {
  80a34b:	85 c0                	test   %eax,%eax
  80a34d:	75 29                	jne    80a378 <ip_reass+0x127>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  80a34f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a352:	89 d8                	mov    %ebx,%eax
  80a354:	e8 22 fe ff ff       	call   80a17b <ip_reass_remove_oldest_datagram>
  80a359:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80a35c:	0f 8f 0b 04 00 00    	jg     80a76d <ip_reass+0x51c>
      ipr = memp_malloc(MEMP_REASSDATA);
  80a362:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  80a369:	e8 b6 d3 ff ff       	call   807724 <memp_malloc>
  80a36e:	89 c6                	mov    %eax,%esi
    }
    if (ipr == NULL)
  80a370:	85 c0                	test   %eax,%eax
  80a372:	0f 84 f5 03 00 00    	je     80a76d <ip_reass+0x51c>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  80a378:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80a37f:	00 
  80a380:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80a387:	00 
  80a388:	89 34 24             	mov    %esi,(%esp)
  80a38b:	e8 c6 71 ff ff       	call   801556 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  80a390:	c6 46 1f 03          	movb   $0x3,0x1f(%esi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  80a394:	a1 40 54 b3 00       	mov    0xb35440,%eax
  80a399:	89 06                	mov    %eax,(%esi)
  reassdatagrams = ipr;
  80a39b:	89 35 40 54 b3 00    	mov    %esi,0xb35440
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  80a3a1:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a3a8:	00 
  80a3a9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a3ad:	8d 46 08             	lea    0x8(%esi),%eax
  80a3b0:	89 04 24             	mov    %eax,(%esp)
  80a3b3:	e8 79 72 ff ff       	call   801631 <memcpy>
  80a3b8:	eb 41                	jmp    80a3fb <ip_reass+0x1aa>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80a3ba:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80a3be:	89 04 24             	mov    %eax,(%esp)
  80a3c1:	e8 bb 08 00 00       	call   80ac81 <ntohs>
  80a3c6:	66 a9 ff 1f          	test   $0x1fff,%ax
  80a3ca:	75 2f                	jne    80a3fb <ip_reass+0x1aa>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  80a3cc:	8b 55 cc             	mov    -0x34(%ebp),%edx
  80a3cf:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
  80a3d3:	89 04 24             	mov    %eax,(%esp)
  80a3d6:	e8 a6 08 00 00       	call   80ac81 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80a3db:	66 a9 ff 1f          	test   $0x1fff,%ax
  80a3df:	74 1a                	je     80a3fb <ip_reass+0x1aa>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  80a3e1:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a3e8:	00 
  80a3e9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a3ed:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80a3f0:	83 c0 08             	add    $0x8,%eax
  80a3f3:	89 04 24             	mov    %eax,(%esp)
  80a3f6:	e8 36 72 ff ff       	call   801631 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  80a3fb:	66 81 e7 ff 00       	and    $0xff,%di
  80a400:	66 01 3d 44 54 b3 00 	add    %di,0xb35444

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  80a407:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80a40b:	89 04 24             	mov    %eax,(%esp)
  80a40e:	e8 6e 08 00 00       	call   80ac81 <ntohs>
  80a413:	f6 c4 20             	test   $0x20,%ah
  80a416:	75 21                	jne    80a439 <ip_reass+0x1e8>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  80a418:	80 4e 1e 01          	orb    $0x1,0x1e(%esi)
    ipr->datagram_len = offset + len;
  80a41c:	0f b7 4d d0          	movzwl -0x30(%ebp),%ecx
  80a420:	0f b7 5d da          	movzwl -0x26(%ebp),%ebx
  80a424:	8d 04 cb             	lea    (%ebx,%ecx,8),%eax
  80a427:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
  80a42b:	66 c1 ea 06          	shr    $0x6,%dx
  80a42f:	83 e2 3c             	and    $0x3c,%edx
  80a432:	66 29 d0             	sub    %dx,%ax
  80a435:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  80a439:	8b 7d 08             	mov    0x8(%ebp),%edi
  80a43c:	8b 5f 04             	mov    0x4(%edi),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80a43f:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80a443:	89 04 24             	mov    %eax,(%esp)
  80a446:	e8 36 08 00 00       	call   80ac81 <ntohs>
  80a44b:	89 c7                	mov    %eax,%edi
  80a44d:	0f b7 03             	movzwl (%ebx),%eax
  80a450:	89 04 24             	mov    %eax,(%esp)
  80a453:	e8 29 08 00 00       	call   80ac81 <ntohs>
  80a458:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80a45c:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80a460:	89 04 24             	mov    %eax,(%esp)
  80a463:	e8 19 08 00 00       	call   80ac81 <ntohs>
  80a468:	c1 e0 03             	shl    $0x3,%eax
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  80a46b:	8b 55 08             	mov    0x8(%ebp),%edx
  80a46e:	8b 52 04             	mov    0x4(%edx),%edx
  80a471:	89 55 e0             	mov    %edx,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  80a474:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  80a47a:	66 89 42 04          	mov    %ax,0x4(%edx)
  iprh->end = offset + len;
  80a47e:	8d 0c 38             	lea    (%eax,%edi,1),%ecx
  80a481:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
  80a485:	66 c1 ea 06          	shr    $0x6,%dx
  80a489:	83 e2 3c             	and    $0x3c,%edx
  80a48c:	66 29 d1             	sub    %dx,%cx
  80a48f:	66 89 4d da          	mov    %cx,-0x26(%ebp)
  80a493:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80a496:	66 89 4b 06          	mov    %cx,0x6(%ebx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  80a49a:	8b 7e 04             	mov    0x4(%esi),%edi
  80a49d:	85 ff                	test   %edi,%edi
  80a49f:	0f 84 10 03 00 00    	je     80a7b5 <ip_reass+0x564>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80a4a5:	8b 57 04             	mov    0x4(%edi),%edx
    if (iprh->start < iprh_tmp->start) {
  80a4a8:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  80a4ac:	66 39 c8             	cmp    %cx,%ax
  80a4af:	0f 82 ea 02 00 00    	jb     80a79f <ip_reass+0x54e>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  80a4b5:	66 39 c8             	cmp    %cx,%ax
  80a4b8:	0f 84 23 02 00 00    	je     80a6e1 <ip_reass+0x490>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  80a4be:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  80a4c5:	66 39 42 06          	cmp    %ax,0x6(%edx)
  80a4c9:	0f 86 8e 00 00 00    	jbe    80a55d <ip_reass+0x30c>
  80a4cf:	90                   	nop
  80a4d0:	e9 0c 02 00 00       	jmp    80a6e1 <ip_reass+0x490>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80a4d5:	8b 4f 04             	mov    0x4(%edi),%ecx
    if (iprh->start < iprh_tmp->start) {
  80a4d8:	0f b7 59 04          	movzwl 0x4(%ecx),%ebx
  80a4dc:	66 39 d8             	cmp    %bx,%ax
  80a4df:	73 49                	jae    80a52a <ip_reass+0x2d9>
  80a4e1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80a4e4:	89 75 dc             	mov    %esi,-0x24(%ebp)
  80a4e7:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80a4ea:	89 d3                	mov    %edx,%ebx
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  80a4ec:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80a4ef:	89 39                	mov    %edi,(%ecx)
      if (iprh_prev != NULL) {
  80a4f1:	85 d2                	test   %edx,%edx
  80a4f3:	74 25                	je     80a51a <ip_reass+0x2c9>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  80a4f5:	66 3b 42 06          	cmp    0x6(%edx),%ax
  80a4f9:	0f 82 e2 01 00 00    	jb     80a6e1 <ip_reass+0x490>
  80a4ff:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  80a503:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80a506:	66 3b 47 04          	cmp    0x4(%edi),%ax
  80a50a:	0f 87 d1 01 00 00    	ja     80a6e1 <ip_reass+0x490>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  80a510:	8b 55 08             	mov    0x8(%ebp),%edx
  80a513:	89 13                	mov    %edx,(%ebx)
  80a515:	e9 cc 00 00 00       	jmp    80a5e6 <ip_reass+0x395>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  80a51a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a51d:	89 4e 04             	mov    %ecx,0x4(%esi)
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  80a520:	85 ff                	test   %edi,%edi
  80a522:	0f 85 be 00 00 00    	jne    80a5e6 <ip_reass+0x395>
  80a528:	eb 49                	jmp    80a573 <ip_reass+0x322>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  80a52a:	66 39 d8             	cmp    %bx,%ax
  80a52d:	8d 76 00             	lea    0x0(%esi),%esi
  80a530:	0f 84 ab 01 00 00    	je     80a6e1 <ip_reass+0x490>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  80a536:	66 3b 41 06          	cmp    0x6(%ecx),%ax
  80a53a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80a540:	0f 82 9b 01 00 00    	jb     80a6e1 <ip_reass+0x490>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  80a546:	85 d2                	test   %edx,%edx
  80a548:	74 0f                	je     80a559 <ip_reass+0x308>
        if (iprh_prev->end != iprh_tmp->start) {
  80a54a:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  80a54e:	0f 95 c2             	setne  %dl
  80a551:	0f b6 d2             	movzbl %dl,%edx
  80a554:	83 ea 01             	sub    $0x1,%edx
  80a557:	21 d6                	and    %edx,%esi
  80a559:	89 ca                	mov    %ecx,%edx
  80a55b:	eb 06                	jmp    80a563 <ip_reass+0x312>
  80a55d:	89 75 d0             	mov    %esi,-0x30(%ebp)
  80a560:	8b 75 dc             	mov    -0x24(%ebp),%esi
           * and the previous fragment */
          valid = 0;
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  80a563:	8b 3a                	mov    (%edx),%edi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  80a565:	85 ff                	test   %edi,%edi
  80a567:	0f 85 68 ff ff ff    	jne    80a4d5 <ip_reass+0x284>
  80a56d:	89 75 dc             	mov    %esi,-0x24(%ebp)
  80a570:	8b 75 d0             	mov    -0x30(%ebp),%esi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  80a573:	85 d2                	test   %edx,%edx
  80a575:	74 47                	je     80a5be <ip_reass+0x36d>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  80a577:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a57b:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80a57e:	66 3b 43 04          	cmp    0x4(%ebx),%ax
  80a582:	76 1c                	jbe    80a5a0 <ip_reass+0x34f>
  80a584:	c7 44 24 08 e8 3b 81 	movl   $0x813be8,0x8(%esp)
  80a58b:	00 
  80a58c:	c7 44 24 04 83 01 00 	movl   $0x183,0x4(%esp)
  80a593:	00 
  80a594:	c7 04 24 92 3b 81 00 	movl   $0x813b92,(%esp)
  80a59b:	e8 48 64 ff ff       	call   8009e8 <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  80a5a0:	8b 7d 08             	mov    0x8(%ebp),%edi
  80a5a3:	89 3a                	mov    %edi,(%edx)
      if (iprh_prev->end != iprh->start) {
  80a5a5:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a5a9:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a5ac:	66 3b 42 04          	cmp    0x4(%edx),%ax
  80a5b0:	0f 95 c0             	setne  %al
  80a5b3:	0f b6 c0             	movzbl %al,%eax
  80a5b6:	83 e8 01             	sub    $0x1,%eax
  80a5b9:	21 45 dc             	and    %eax,-0x24(%ebp)
  80a5bc:	eb 28                	jmp    80a5e6 <ip_reass+0x395>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  80a5be:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
  80a5c2:	74 1c                	je     80a5e0 <ip_reass+0x38f>
  80a5c4:	c7 44 24 08 14 3c 81 	movl   $0x813c14,0x8(%esp)
  80a5cb:	00 
  80a5cc:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
  80a5d3:	00 
  80a5d4:	c7 04 24 92 3b 81 00 	movl   $0x813b92,(%esp)
  80a5db:	e8 08 64 ff ff       	call   8009e8 <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  80a5e0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a5e3:	89 4e 04             	mov    %ecx,0x4(%esi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  80a5e6:	f6 46 1e 01          	testb  $0x1,0x1e(%esi)
  80a5ea:	0f 84 91 01 00 00    	je     80a781 <ip_reass+0x530>
    /* and had no wholes so far */
    if (valid) {
  80a5f0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80a5f4:	0f 84 87 01 00 00    	je     80a781 <ip_reass+0x530>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  80a5fa:	8b 56 04             	mov    0x4(%esi),%edx
  80a5fd:	8b 42 04             	mov    0x4(%edx),%eax
  80a600:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  80a605:	0f 85 76 01 00 00    	jne    80a781 <ip_reass+0x530>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  80a60b:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80a60e:	8b 0b                	mov    (%ebx),%ecx
        while (q != NULL) {
  80a610:	85 c9                	test   %ecx,%ecx
  80a612:	0f 84 ae 01 00 00    	je     80a7c6 <ip_reass+0x575>
          iprh = (struct ip_reass_helper*)q->payload;
  80a618:	8b 49 04             	mov    0x4(%ecx),%ecx
          if (iprh_prev->end != iprh->start) {
  80a61b:	0f b7 5b 06          	movzwl 0x6(%ebx),%ebx
  80a61f:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80a622:	66 3b 59 04          	cmp    0x4(%ecx),%bx
  80a626:	74 1a                	je     80a642 <ip_reass+0x3f1>
  80a628:	e9 54 01 00 00       	jmp    80a781 <ip_reass+0x530>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80a62d:	8b 49 04             	mov    0x4(%ecx),%ecx
          if (iprh_prev->end != iprh->start) {
  80a630:	0f b7 5b 06          	movzwl 0x6(%ebx),%ebx
  80a634:	66 3b 59 04          	cmp    0x4(%ecx),%bx
  80a638:	0f 85 43 01 00 00    	jne    80a781 <ip_reass+0x530>
  80a63e:	89 cb                	mov    %ecx,%ebx
  80a640:	eb 03                	jmp    80a645 <ip_reass+0x3f4>
  80a642:	8b 5d e0             	mov    -0x20(%ebp),%ebx
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  80a645:	8b 0b                	mov    (%ebx),%ecx
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  80a647:	85 c9                	test   %ecx,%ecx
  80a649:	75 e2                	jne    80a62d <ip_reass+0x3dc>
  80a64b:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  80a64e:	e9 73 01 00 00       	jmp    80a7c6 <ip_reass+0x575>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80a653:	c7 44 24 08 06 3c 81 	movl   $0x813c06,0x8(%esp)
  80a65a:	00 
  80a65b:	c7 44 24 04 ac 01 00 	movl   $0x1ac,0x4(%esp)
  80a662:	00 
  80a663:	c7 04 24 92 3b 81 00 	movl   $0x813b92,(%esp)
  80a66a:	e8 79 63 ff ff       	call   8009e8 <_panic>
          LWIP_ASSERT("sanity check",
  80a66f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  80a672:	75 1c                	jne    80a690 <ip_reass+0x43f>
  80a674:	c7 44 24 08 06 3c 81 	movl   $0x813c06,0x8(%esp)
  80a67b:	00 
  80a67c:	c7 44 24 04 ae 01 00 	movl   $0x1ae,0x4(%esp)
  80a683:	00 
  80a684:	c7 04 24 92 3b 81 00 	movl   $0x813b92,(%esp)
  80a68b:	e8 58 63 ff ff       	call   8009e8 <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  80a690:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a693:	83 38 00             	cmpl   $0x0,(%eax)
  80a696:	74 1c                	je     80a6b4 <ip_reass+0x463>
  80a698:	c7 44 24 08 4c 3c 81 	movl   $0x813c4c,0x8(%esp)
  80a69f:	00 
  80a6a0:	c7 44 24 04 b0 01 00 	movl   $0x1b0,0x4(%esp)
  80a6a7:	00 
  80a6a8:	c7 04 24 92 3b 81 00 	movl   $0x813b92,(%esp)
  80a6af:	e8 34 63 ff ff       	call   8009e8 <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  80a6b4:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a6b7:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a6bb:	66 3b 46 1c          	cmp    0x1c(%esi),%ax
  80a6bf:	0f 84 10 01 00 00    	je     80a7d5 <ip_reass+0x584>
  80a6c5:	c7 44 24 08 70 3c 81 	movl   $0x813c70,0x8(%esp)
  80a6cc:	00 
  80a6cd:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80a6d4:	00 
  80a6d5:	c7 04 24 92 3b 81 00 	movl   $0x813b92,(%esp)
  80a6dc:	e8 07 63 ff ff       	call   8009e8 <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  80a6e1:	0f b7 1d 44 54 b3 00 	movzwl 0xb35444,%ebx
  80a6e8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a6eb:	89 0c 24             	mov    %ecx,(%esp)
  80a6ee:	e8 1d d3 ff ff       	call   807a10 <pbuf_clen>
  80a6f3:	0f b6 c0             	movzbl %al,%eax
  80a6f6:	66 29 c3             	sub    %ax,%bx
  80a6f9:	66 89 1d 44 54 b3 00 	mov    %bx,0xb35444
  pbuf_free(new_p);
  80a700:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a703:	89 1c 24             	mov    %ebx,(%esp)
  80a706:	e8 6d d7 ff ff       	call   807e78 <pbuf_free>
  80a70b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80a712:	eb 74                	jmp    80a788 <ip_reass+0x537>
  80a714:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80a717:	8b 75 e4             	mov    -0x1c(%ebp),%esi

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;
  80a71a:	8b 5f 04             	mov    0x4(%edi),%ebx

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  80a71d:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80a724:	ff 
  80a725:	89 3c 24             	mov    %edi,(%esp)
  80a728:	e8 d6 d3 ff ff       	call   807b03 <pbuf_header>
      pbuf_cat(p, r);
  80a72d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80a731:	89 34 24             	mov    %esi,(%esp)
  80a734:	e8 02 d3 ff ff       	call   807a3b <pbuf_cat>
      r = iprh->next_pbuf;
  80a739:	8b 3b                	mov    (%ebx),%edi
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80a73b:	85 ff                	test   %edi,%edi
  80a73d:	75 db                	jne    80a71a <ip_reass+0x4c9>
  80a73f:	8b 75 e0             	mov    -0x20(%ebp),%esi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  80a742:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80a745:	89 f0                	mov    %esi,%eax
  80a747:	e8 b4 f8 ff ff       	call   80a000 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  80a74c:	0f b7 1d 44 54 b3 00 	movzwl 0xb35444,%ebx
  80a753:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80a756:	89 3c 24             	mov    %edi,(%esp)
  80a759:	e8 b2 d2 ff ff       	call   807a10 <pbuf_clen>
  80a75e:	0f b6 c0             	movzbl %al,%eax
  80a761:	66 29 c3             	sub    %ax,%bx
  80a764:	66 89 1d 44 54 b3 00 	mov    %bx,0xb35444

    /* Return the pbuf chain */
    return p;
  80a76b:	eb 1b                	jmp    80a788 <ip_reass+0x537>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  80a76d:	8b 45 08             	mov    0x8(%ebp),%eax
  80a770:	89 04 24             	mov    %eax,(%esp)
  80a773:	e8 00 d7 ff ff       	call   807e78 <pbuf_free>
  80a778:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  return NULL;
  80a77f:	eb 07                	jmp    80a788 <ip_reass+0x537>
  80a781:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  80a788:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a78b:	83 c4 3c             	add    $0x3c,%esp
  80a78e:	5b                   	pop    %ebx
  80a78f:	5e                   	pop    %esi
  80a790:	5f                   	pop    %edi
  80a791:	5d                   	pop    %ebp
  80a792:	c3                   	ret    

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
  80a793:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  80a79a:	e9 9e fb ff ff       	jmp    80a33d <ip_reass+0xec>
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  80a79f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a7a2:	89 3a                	mov    %edi,(%edx)
  80a7a4:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  80a7ab:	ba 00 00 00 00       	mov    $0x0,%edx
  80a7b0:	e9 65 fd ff ff       	jmp    80a51a <ip_reass+0x2c9>
  80a7b5:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  80a7bc:	ba 00 00 00 00       	mov    $0x0,%edx
  80a7c1:	e9 ad fd ff ff       	jmp    80a573 <ip_reass+0x322>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80a7c6:	85 d2                	test   %edx,%edx
  80a7c8:	0f 85 a1 fe ff ff    	jne    80a66f <ip_reass+0x41e>
  80a7ce:	66 90                	xchg   %ax,%ax
  80a7d0:	e9 7e fe ff ff       	jmp    80a653 <ip_reass+0x402>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  80a7d5:	83 c0 14             	add    $0x14,%eax
  80a7d8:	66 89 46 1c          	mov    %ax,0x1c(%esi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  80a7dc:	8b 46 04             	mov    0x4(%esi),%eax
  80a7df:	8b 58 04             	mov    0x4(%eax),%ebx
  80a7e2:	8b 3b                	mov    (%ebx),%edi

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  80a7e4:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a7eb:	00 
  80a7ec:	8d 46 08             	lea    0x8(%esi),%eax
  80a7ef:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a7f3:	89 1c 24             	mov    %ebx,(%esp)
  80a7f6:	e8 36 6e ff ff       	call   801631 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  80a7fb:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80a7ff:	89 04 24             	mov    %eax,(%esp)
  80a802:	e8 6d 04 00 00       	call   80ac74 <htons>
  80a807:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(fraghdr, 0);
  80a80b:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_CHKSUM_SET(fraghdr, 0);
  80a811:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  80a817:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80a81e:	00 
  80a81f:	89 1c 24             	mov    %ebx,(%esp)
  80a822:	e8 33 01 00 00       	call   80a95a <inet_chksum>
  80a827:	66 89 43 0a          	mov    %ax,0xa(%ebx)

    p = ipr->p;
  80a82b:	8b 4e 04             	mov    0x4(%esi),%ecx
  80a82e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80a831:	85 ff                	test   %edi,%edi
  80a833:	0f 85 db fe ff ff    	jne    80a714 <ip_reass+0x4c3>
  80a839:	e9 04 ff ff ff       	jmp    80a742 <ip_reass+0x4f1>
	...

0080a840 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80a840:	55                   	push   %ebp
  80a841:	89 e5                	mov    %esp,%ebp
  80a843:	57                   	push   %edi
  80a844:	56                   	push   %esi
  80a845:	53                   	push   %ebx
  80a846:	83 ec 2c             	sub    $0x2c,%esp
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  80a849:	89 c7                	mov    %eax,%edi
  while (len > 1) {
  80a84b:	b9 00 00 00 00       	mov    $0x0,%ecx
  80a850:	66 83 fa 01          	cmp    $0x1,%dx
  80a854:	76 3a                	jbe    80a890 <lwip_standard_chksum+0x50>
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  80a856:	83 ea 02             	sub    $0x2,%edx
  80a859:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
  80a85d:	66 d1 ea             	shr    %dx
  80a860:	0f b7 d2             	movzwl %dx,%edx
  80a863:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80a866:	8d 74 50 02          	lea    0x2(%eax,%edx,2),%esi
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80a86a:	0f b6 18             	movzbl (%eax),%ebx
  80a86d:	c1 e3 08             	shl    $0x8,%ebx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  80a870:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  80a874:	09 da                	or     %ebx,%edx
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  80a876:	83 c0 02             	add    $0x2,%eax
    src = (*octetptr) << 8;
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
    octetptr++;
    acc += src;
  80a879:	0f b7 d2             	movzwl %dx,%edx
  80a87c:	01 d1                	add    %edx,%ecx
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80a87e:	39 c6                	cmp    %eax,%esi
  80a880:	75 e8                	jne    80a86a <lwip_standard_chksum+0x2a>
  80a882:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a885:	8d 7c 47 02          	lea    0x2(%edi,%eax,2),%edi
  80a889:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  80a88d:	83 e2 01             	and    $0x1,%edx
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  80a890:	66 85 d2             	test   %dx,%dx
  80a893:	74 0b                	je     80a8a0 <lwip_standard_chksum+0x60>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
    acc += src;
  80a895:	0f b6 07             	movzbl (%edi),%eax
  80a898:	c1 e0 08             	shl    $0x8,%eax
  80a89b:	0f b7 c0             	movzwl %ax,%eax
  80a89e:	01 c1                	add    %eax,%ecx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80a8a0:	89 c8                	mov    %ecx,%eax
  80a8a2:	c1 e8 10             	shr    $0x10,%eax
  80a8a5:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  80a8ab:	01 c1                	add    %eax,%ecx
  if ((acc & 0xffff0000) != 0) {
  80a8ad:	f7 c1 00 00 ff ff    	test   $0xffff0000,%ecx
  80a8b3:	74 0d                	je     80a8c2 <lwip_standard_chksum+0x82>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80a8b5:	89 c8                	mov    %ecx,%eax
  80a8b7:	c1 e8 10             	shr    $0x10,%eax
  80a8ba:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  80a8c0:	01 c1                	add    %eax,%ecx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  80a8c2:	0f b7 c9             	movzwl %cx,%ecx
  80a8c5:	89 0c 24             	mov    %ecx,(%esp)
  80a8c8:	e8 a7 03 00 00       	call   80ac74 <htons>
}
  80a8cd:	83 c4 2c             	add    $0x2c,%esp
  80a8d0:	5b                   	pop    %ebx
  80a8d1:	5e                   	pop    %esi
  80a8d2:	5f                   	pop    %edi
  80a8d3:	5d                   	pop    %ebp
  80a8d4:	c3                   	ret    

0080a8d5 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  80a8d5:	55                   	push   %ebp
  80a8d6:	89 e5                	mov    %esp,%ebp
  80a8d8:	57                   	push   %edi
  80a8d9:	56                   	push   %esi
  80a8da:	53                   	push   %ebx
  80a8db:	83 ec 0c             	sub    $0xc,%esp
  80a8de:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80a8e1:	be 00 00 00 00       	mov    $0x0,%esi
  80a8e6:	85 db                	test   %ebx,%ebx
  80a8e8:	74 64                	je     80a94e <inet_chksum_pbuf+0x79>
  80a8ea:	bf 00 00 00 00       	mov    $0x0,%edi
    acc += LWIP_CHKSUM(q->payload, q->len);
  80a8ef:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80a8f3:	8b 43 04             	mov    0x4(%ebx),%eax
  80a8f6:	e8 45 ff ff ff       	call   80a840 <lwip_standard_chksum>
  80a8fb:	0f b7 c0             	movzwl %ax,%eax
  80a8fe:	8d 34 30             	lea    (%eax,%esi,1),%esi
    acc = FOLD_U32T(acc);
  80a901:	89 f0                	mov    %esi,%eax
  80a903:	c1 e8 10             	shr    $0x10,%eax
  80a906:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80a90c:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  80a90e:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80a912:	74 1c                	je     80a930 <inet_chksum_pbuf+0x5b>
      swapped = 1 - swapped;
  80a914:	b8 01 00 00 00       	mov    $0x1,%eax
  80a919:	89 fa                	mov    %edi,%edx
  80a91b:	28 d0                	sub    %dl,%al
  80a91d:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80a91f:	89 f0                	mov    %esi,%eax
  80a921:	c1 e0 08             	shl    $0x8,%eax
  80a924:	25 ff ff 00 00       	and    $0xffff,%eax
  80a929:	89 f2                	mov    %esi,%edx
  80a92b:	0f b6 f6             	movzbl %dh,%esi
  80a92e:	09 c6                	or     %eax,%esi
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80a930:	8b 1b                	mov    (%ebx),%ebx
  80a932:	85 db                	test   %ebx,%ebx
  80a934:	75 b9                	jne    80a8ef <inet_chksum_pbuf+0x1a>
  80a936:	89 f0                	mov    %esi,%eax
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  80a938:	89 fa                	mov    %edi,%edx
  80a93a:	84 d2                	test   %dl,%dl
  80a93c:	74 10                	je     80a94e <inet_chksum_pbuf+0x79>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a93e:	89 f2                	mov    %esi,%edx
  80a940:	c1 e2 08             	shl    $0x8,%edx
  80a943:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a949:	0f b6 f4             	movzbl %ah,%esi
  80a94c:	09 d6                	or     %edx,%esi
  80a94e:	89 f0                	mov    %esi,%eax
  80a950:	f7 d0                	not    %eax
  }
  return (u16_t)~(acc & 0xffffUL);
}
  80a952:	83 c4 0c             	add    $0xc,%esp
  80a955:	5b                   	pop    %ebx
  80a956:	5e                   	pop    %esi
  80a957:	5f                   	pop    %edi
  80a958:	5d                   	pop    %ebp
  80a959:	c3                   	ret    

0080a95a <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  80a95a:	55                   	push   %ebp
  80a95b:	89 e5                	mov    %esp,%ebp
  80a95d:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  80a960:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  80a964:	8b 45 08             	mov    0x8(%ebp),%eax
  80a967:	e8 d4 fe ff ff       	call   80a840 <lwip_standard_chksum>
  80a96c:	f7 d0                	not    %eax
}
  80a96e:	c9                   	leave  
  80a96f:	c3                   	ret    

0080a970 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  80a970:	55                   	push   %ebp
  80a971:	89 e5                	mov    %esp,%ebp
  80a973:	57                   	push   %edi
  80a974:	56                   	push   %esi
  80a975:	53                   	push   %ebx
  80a976:	83 ec 2c             	sub    $0x2c,%esp
  80a979:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a97c:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80a980:	88 45 e7             	mov    %al,-0x19(%ebp)
  80a983:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80a987:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80a98b:	be 00 00 00 00       	mov    $0x0,%esi
  80a990:	85 db                	test   %ebx,%ebx
  80a992:	74 64                	je     80a9f8 <inet_chksum_pseudo+0x88>
  80a994:	bf 00 00 00 00       	mov    $0x0,%edi
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  80a999:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80a99d:	8b 43 04             	mov    0x4(%ebx),%eax
  80a9a0:	e8 9b fe ff ff       	call   80a840 <lwip_standard_chksum>
  80a9a5:	0f b7 c0             	movzwl %ax,%eax
  80a9a8:	8d 34 30             	lea    (%eax,%esi,1),%esi
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  80a9ab:	89 f0                	mov    %esi,%eax
  80a9ad:	c1 e8 10             	shr    $0x10,%eax
  80a9b0:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80a9b6:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  80a9b8:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80a9bc:	74 1c                	je     80a9da <inet_chksum_pseudo+0x6a>
      swapped = 1 - swapped;
  80a9be:	b8 01 00 00 00       	mov    $0x1,%eax
  80a9c3:	89 fa                	mov    %edi,%edx
  80a9c5:	28 d0                	sub    %dl,%al
  80a9c7:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80a9c9:	89 f0                	mov    %esi,%eax
  80a9cb:	c1 e0 08             	shl    $0x8,%eax
  80a9ce:	25 ff ff 00 00       	and    $0xffff,%eax
  80a9d3:	89 f2                	mov    %esi,%edx
  80a9d5:	0f b6 f6             	movzbl %dh,%esi
  80a9d8:	09 c6                	or     %eax,%esi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80a9da:	8b 1b                	mov    (%ebx),%ebx
  80a9dc:	85 db                	test   %ebx,%ebx
  80a9de:	75 b9                	jne    80a999 <inet_chksum_pseudo+0x29>
  80a9e0:	89 f0                	mov    %esi,%eax
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80a9e2:	89 fa                	mov    %edi,%edx
  80a9e4:	84 d2                	test   %dl,%dl
  80a9e6:	74 10                	je     80a9f8 <inet_chksum_pseudo+0x88>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a9e8:	89 f2                	mov    %esi,%edx
  80a9ea:	c1 e2 08             	shl    $0x8,%edx
  80a9ed:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a9f3:	0f b6 f4             	movzbl %ah,%esi
  80a9f6:	09 d6                	or     %edx,%esi
  }
  acc += (src->addr & 0xffffUL);
  80a9f8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a9fb:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80a9fd:	8b 45 10             	mov    0x10(%ebp),%eax
  80aa00:	8b 00                	mov    (%eax),%eax
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80aa02:	89 d1                	mov    %edx,%ecx
  80aa04:	c1 e9 10             	shr    $0x10,%ecx
  80aa07:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80aa0d:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  80aa10:	0f b7 c8             	movzwl %ax,%ecx
  80aa13:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  80aa15:	c1 e8 10             	shr    $0x10,%eax
  80aa18:	8d 04 02             	lea    (%edx,%eax,1),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  80aa1b:	8d 34 30             	lea    (%eax,%esi,1),%esi
  acc += (u32_t)htons((u16_t)proto);
  80aa1e:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80aa22:	89 04 24             	mov    %eax,(%esp)
  80aa25:	e8 4a 02 00 00       	call   80ac74 <htons>
  80aa2a:	0f b7 c0             	movzwl %ax,%eax
  80aa2d:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons(proto_len);
  80aa2f:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80aa33:	89 04 24             	mov    %eax,(%esp)
  80aa36:	e8 39 02 00 00       	call   80ac74 <htons>
  80aa3b:	0f b7 c0             	movzwl %ax,%eax
  80aa3e:	01 c6                	add    %eax,%esi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80aa40:	89 f0                	mov    %esi,%eax
  80aa42:	c1 e8 10             	shr    $0x10,%eax
  80aa45:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80aa4b:	01 c6                	add    %eax,%esi
  acc = FOLD_U32T(acc);
  80aa4d:	89 f0                	mov    %esi,%eax
  80aa4f:	c1 e8 10             	shr    $0x10,%eax
  80aa52:	8d 04 06             	lea    (%esi,%eax,1),%eax
  80aa55:	f7 d0                	not    %eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  80aa57:	83 c4 2c             	add    $0x2c,%esp
  80aa5a:	5b                   	pop    %ebx
  80aa5b:	5e                   	pop    %esi
  80aa5c:	5f                   	pop    %edi
  80aa5d:	5d                   	pop    %ebp
  80aa5e:	c3                   	ret    

0080aa5f <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  80aa5f:	55                   	push   %ebp
  80aa60:	89 e5                	mov    %esp,%ebp
  80aa62:	57                   	push   %edi
  80aa63:	56                   	push   %esi
  80aa64:	53                   	push   %ebx
  80aa65:	83 ec 2c             	sub    $0x2c,%esp
  80aa68:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80aa6b:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80aa6f:	88 45 e2             	mov    %al,-0x1e(%ebp)
  80aa72:	0f b7 4d 18          	movzwl 0x18(%ebp),%ecx
  80aa76:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  80aa7a:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80aa7e:	85 db                	test   %ebx,%ebx
  80aa80:	74 05                	je     80aa87 <inet_chksum_pseudo_partial+0x28>
  80aa82:	66 85 f6             	test   %si,%si
  80aa85:	75 0c                	jne    80aa93 <inet_chksum_pseudo_partial+0x34>
  80aa87:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80aa8e:	e9 ad 00 00 00       	jmp    80ab40 <inet_chksum_pseudo_partial+0xe1>
  80aa93:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  80aa97:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  80aa9e:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80aaa2:	89 f7                	mov    %esi,%edi
  80aaa4:	66 39 c6             	cmp    %ax,%si
  80aaa7:	76 02                	jbe    80aaab <inet_chksum_pseudo_partial+0x4c>
  80aaa9:	89 c7                	mov    %eax,%edi
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80aaab:	0f b7 d7             	movzwl %di,%edx
  80aaae:	8b 43 04             	mov    0x4(%ebx),%eax
  80aab1:	e8 8a fd ff ff       	call   80a840 <lwip_standard_chksum>
    chksum_len -= chklen;
  80aab6:	66 29 fe             	sub    %di,%si
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  80aab9:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  80aabe:	76 1c                	jbe    80aadc <inet_chksum_pseudo_partial+0x7d>
  80aac0:	c7 44 24 08 9d 3c 81 	movl   $0x813c9d,0x8(%esp)
  80aac7:	00 
  80aac8:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  80aacf:	00 
  80aad0:	c7 04 24 a8 3c 81 00 	movl   $0x813ca8,(%esp)
  80aad7:	e8 0c 5f ff ff       	call   8009e8 <_panic>
      (void *)q, (void *)q->next));
    chklen = q->len;
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80aadc:	0f b7 c0             	movzwl %ax,%eax
  80aadf:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  80aae2:	89 c2                	mov    %eax,%edx
  80aae4:	c1 ea 10             	shr    $0x10,%edx
  80aae7:	25 ff ff 00 00       	and    $0xffff,%eax
  80aaec:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80aaef:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  80aaf2:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80aaf6:	74 1d                	je     80ab15 <inet_chksum_pseudo_partial+0xb6>
      swapped = 1 - swapped;
  80aaf8:	b8 01 00 00 00       	mov    $0x1,%eax
  80aafd:	2a 45 e3             	sub    -0x1d(%ebp),%al
  80ab00:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80ab03:	89 d0                	mov    %edx,%eax
  80ab05:	c1 e0 08             	shl    $0x8,%eax
  80ab08:	25 ff ff 00 00       	and    $0xffff,%eax
  80ab0d:	0f b6 d6             	movzbl %dh,%edx
  80ab10:	09 c2                	or     %eax,%edx
  80ab12:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80ab15:	8b 1b                	mov    (%ebx),%ebx
  80ab17:	85 db                	test   %ebx,%ebx
  80ab19:	74 09                	je     80ab24 <inet_chksum_pseudo_partial+0xc5>
  80ab1b:	66 85 f6             	test   %si,%si
  80ab1e:	0f 85 7a ff ff ff    	jne    80aa9e <inet_chksum_pseudo_partial+0x3f>
  80ab24:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80ab27:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80ab2b:	74 13                	je     80ab40 <inet_chksum_pseudo_partial+0xe1>
    acc = SWAP_BYTES_IN_WORD(acc);
  80ab2d:	89 c2                	mov    %eax,%edx
  80ab2f:	c1 e2 08             	shl    $0x8,%edx
  80ab32:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80ab38:	0f b6 c4             	movzbl %ah,%eax
  80ab3b:	09 d0                	or     %edx,%eax
  80ab3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  80ab40:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ab43:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80ab45:	8b 55 10             	mov    0x10(%ebp),%edx
  80ab48:	8b 1a                	mov    (%edx),%ebx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80ab4a:	89 c2                	mov    %eax,%edx
  80ab4c:	c1 ea 10             	shr    $0x10,%edx
  80ab4f:	25 ff ff 00 00       	and    $0xffff,%eax
  80ab54:	8d 04 02             	lea    (%edx,%eax,1),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  80ab57:	0f b7 d3             	movzwl %bx,%edx
  80ab5a:	01 d0                	add    %edx,%eax
  acc += (dest->addr & 0xffffUL);
  80ab5c:	c1 eb 10             	shr    $0x10,%ebx
  80ab5f:	8d 1c 18             	lea    (%eax,%ebx,1),%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  80ab62:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  80ab65:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
  80ab69:	89 04 24             	mov    %eax,(%esp)
  80ab6c:	e8 03 01 00 00       	call   80ac74 <htons>
  80ab71:	0f b7 c0             	movzwl %ax,%eax
  80ab74:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  80ab76:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  80ab7a:	89 04 24             	mov    %eax,(%esp)
  80ab7d:	e8 f2 00 00 00       	call   80ac74 <htons>
  80ab82:	0f b7 c0             	movzwl %ax,%eax
  80ab85:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80ab87:	89 d8                	mov    %ebx,%eax
  80ab89:	c1 e8 10             	shr    $0x10,%eax
  80ab8c:	81 e3 ff ff 00 00    	and    $0xffff,%ebx
  80ab92:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  acc = FOLD_U32T(acc);
  80ab95:	89 c2                	mov    %eax,%edx
  80ab97:	c1 ea 10             	shr    $0x10,%edx
  80ab9a:	01 d0                	add    %edx,%eax
  80ab9c:	f7 d0                	not    %eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  80ab9e:	83 c4 2c             	add    $0x2c,%esp
  80aba1:	5b                   	pop    %ebx
  80aba2:	5e                   	pop    %esi
  80aba3:	5f                   	pop    %edi
  80aba4:	5d                   	pop    %ebp
  80aba5:	c3                   	ret    
	...

0080abb0 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  80abb0:	55                   	push   %ebp
  80abb1:	89 e5                	mov    %esp,%ebp
  80abb3:	57                   	push   %edi
  80abb4:	56                   	push   %esi
  80abb5:	53                   	push   %ebx
  80abb6:	83 ec 1c             	sub    $0x1c,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  80abb9:	8b 45 08             	mov    0x8(%ebp),%eax
  80abbc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  80abbf:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80abc2:	89 45 e0             	mov    %eax,-0x20(%ebp)
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80abc5:	8d 45 f3             	lea    -0xd(%ebp),%eax
  80abc8:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80abcb:	b9 3c 5a b3 00       	mov    $0xb35a3c,%ecx
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  80abd0:	ba cd ff ff ff       	mov    $0xffffffcd,%edx
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80abd5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80abd8:	0f b6 18             	movzbl (%eax),%ebx
  80abdb:	be 00 00 00 00       	mov    $0x0,%esi
  80abe0:	89 f0                	mov    %esi,%eax
  80abe2:	89 ce                	mov    %ecx,%esi
  80abe4:	89 c1                	mov    %eax,%ecx
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  80abe6:	89 d8                	mov    %ebx,%eax
  80abe8:	f6 e2                	mul    %dl
  80abea:	66 c1 e8 08          	shr    $0x8,%ax
  80abee:	c0 e8 03             	shr    $0x3,%al
  80abf1:	89 c7                	mov    %eax,%edi
  80abf3:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80abf6:	01 c0                	add    %eax,%eax
  80abf8:	28 c3                	sub    %al,%bl
  80abfa:	89 d8                	mov    %ebx,%eax
      *ap /= (u8_t)10;
  80abfc:	89 fb                	mov    %edi,%ebx
      inv[i++] = '0' + rem;
  80abfe:	0f b6 f9             	movzbl %cl,%edi
  80ac01:	83 c0 30             	add    $0x30,%eax
  80ac04:	88 44 3d ed          	mov    %al,-0x13(%ebp,%edi,1)
  80ac08:	83 c1 01             	add    $0x1,%ecx
    } while(*ap);
  80ac0b:	84 db                	test   %bl,%bl
  80ac0d:	75 d7                	jne    80abe6 <inet_ntoa+0x36>
  80ac0f:	89 c8                	mov    %ecx,%eax
  80ac11:	89 f1                	mov    %esi,%ecx
  80ac13:	89 c6                	mov    %eax,%esi
  80ac15:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ac18:	88 18                	mov    %bl,(%eax)
    while(i--)
  80ac1a:	89 f0                	mov    %esi,%eax
  80ac1c:	84 c0                	test   %al,%al
  80ac1e:	74 2c                	je     80ac4c <inet_ntoa+0x9c>
  80ac20:	8d 5e ff             	lea    -0x1(%esi),%ebx
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80ac23:	0f b6 c3             	movzbl %bl,%eax
  80ac26:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80ac29:	8d 7c 01 01          	lea    0x1(%ecx,%eax,1),%edi
  80ac2d:	89 c8                	mov    %ecx,%eax
  80ac2f:	89 ce                	mov    %ecx,%esi
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
  80ac31:	0f b6 cb             	movzbl %bl,%ecx
  80ac34:	0f b6 4c 0d ed       	movzbl -0x13(%ebp,%ecx,1),%ecx
  80ac39:	88 08                	mov    %cl,(%eax)
  80ac3b:	83 c0 01             	add    $0x1,%eax
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  80ac3e:	83 eb 01             	sub    $0x1,%ebx
  80ac41:	39 f8                	cmp    %edi,%eax
  80ac43:	75 ec                	jne    80ac31 <inet_ntoa+0x81>
  80ac45:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ac48:	8d 4c 06 01          	lea    0x1(%esi,%eax,1),%ecx
      *rp++ = inv[i];
    *rp++ = '.';
  80ac4c:	c6 01 2e             	movb   $0x2e,(%ecx)
  80ac4f:	83 c1 01             	add    $0x1,%ecx
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  80ac52:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ac55:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80ac58:	74 09                	je     80ac63 <inet_ntoa+0xb3>
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  80ac5a:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  80ac5e:	e9 72 ff ff ff       	jmp    80abd5 <inet_ntoa+0x25>
  }
  *--rp = 0;
  80ac63:	c6 41 ff 00          	movb   $0x0,-0x1(%ecx)
  return str;
}
  80ac67:	b8 3c 5a b3 00       	mov    $0xb35a3c,%eax
  80ac6c:	83 c4 1c             	add    $0x1c,%esp
  80ac6f:	5b                   	pop    %ebx
  80ac70:	5e                   	pop    %esi
  80ac71:	5f                   	pop    %edi
  80ac72:	5d                   	pop    %ebp
  80ac73:	c3                   	ret    

0080ac74 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  80ac74:	55                   	push   %ebp
  80ac75:	89 e5                	mov    %esp,%ebp
  80ac77:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80ac7b:	66 c1 c0 08          	rol    $0x8,%ax
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
}
  80ac7f:	5d                   	pop    %ebp
  80ac80:	c3                   	ret    

0080ac81 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  80ac81:	55                   	push   %ebp
  80ac82:	89 e5                	mov    %esp,%ebp
  80ac84:	83 ec 04             	sub    $0x4,%esp
  return htons(n);
  80ac87:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80ac8b:	89 04 24             	mov    %eax,(%esp)
  80ac8e:	e8 e1 ff ff ff       	call   80ac74 <htons>
}
  80ac93:	c9                   	leave  
  80ac94:	c3                   	ret    

0080ac95 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  80ac95:	55                   	push   %ebp
  80ac96:	89 e5                	mov    %esp,%ebp
  80ac98:	8b 55 08             	mov    0x8(%ebp),%edx
  80ac9b:	89 d1                	mov    %edx,%ecx
  80ac9d:	c1 e9 18             	shr    $0x18,%ecx
  80aca0:	89 d0                	mov    %edx,%eax
  80aca2:	c1 e0 18             	shl    $0x18,%eax
  80aca5:	09 c8                	or     %ecx,%eax
  80aca7:	89 d1                	mov    %edx,%ecx
  80aca9:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80acaf:	c1 e1 08             	shl    $0x8,%ecx
  80acb2:	09 c8                	or     %ecx,%eax
  80acb4:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  80acba:	c1 ea 08             	shr    $0x8,%edx
  80acbd:	09 d0                	or     %edx,%eax
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  80acbf:	5d                   	pop    %ebp
  80acc0:	c3                   	ret    

0080acc1 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  80acc1:	55                   	push   %ebp
  80acc2:	89 e5                	mov    %esp,%ebp
  80acc4:	57                   	push   %edi
  80acc5:	56                   	push   %esi
  80acc6:	53                   	push   %ebx
  80acc7:	83 ec 28             	sub    $0x28,%esp
  80acca:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  80accd:	0f be 10             	movsbl (%eax),%edx
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80acd0:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80acd3:	80 f9 09             	cmp    $0x9,%cl
  80acd6:	0f 87 af 01 00 00    	ja     80ae8b <inet_aton+0x1ca>
  80acdc:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  80acdf:	89 4d d8             	mov    %ecx,-0x28(%ebp)
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80ace2:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  80ace5:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
     */
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
  80ace8:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
  80acef:	83 fa 30             	cmp    $0x30,%edx
  80acf2:	75 24                	jne    80ad18 <inet_aton+0x57>
      c = *++cp;
  80acf4:	83 c0 01             	add    $0x1,%eax
  80acf7:	0f be 10             	movsbl (%eax),%edx
      if (c == 'x' || c == 'X') {
  80acfa:	83 fa 78             	cmp    $0x78,%edx
  80acfd:	74 0c                	je     80ad0b <inet_aton+0x4a>
  80acff:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
  80ad06:	83 fa 58             	cmp    $0x58,%edx
  80ad09:	75 0d                	jne    80ad18 <inet_aton+0x57>
        base = 16;
        c = *++cp;
  80ad0b:	83 c0 01             	add    $0x1,%eax
  80ad0e:	0f be 10             	movsbl (%eax),%edx
  80ad11:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
  80ad18:	83 c0 01             	add    $0x1,%eax
  80ad1b:	be 00 00 00 00       	mov    $0x0,%esi
  80ad20:	eb 03                	jmp    80ad25 <inet_aton+0x64>
  80ad22:	83 c0 01             	add    $0x1,%eax
  80ad25:	8d 78 ff             	lea    -0x1(%eax),%edi
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  80ad28:	89 d1                	mov    %edx,%ecx
  80ad2a:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  80ad2d:	80 fb 09             	cmp    $0x9,%bl
  80ad30:	77 0d                	ja     80ad3f <inet_aton+0x7e>
        val = (val * base) + (int)(c - '0');
  80ad32:	0f af 75 e0          	imul   -0x20(%ebp),%esi
  80ad36:	8d 74 32 d0          	lea    -0x30(%edx,%esi,1),%esi
        c = *++cp;
  80ad3a:	0f be 10             	movsbl (%eax),%edx
  80ad3d:	eb e3                	jmp    80ad22 <inet_aton+0x61>
      } else if (base == 16 && isxdigit(c)) {
  80ad3f:	83 7d e0 10          	cmpl   $0x10,-0x20(%ebp)
  80ad43:	75 2b                	jne    80ad70 <inet_aton+0xaf>
  80ad45:	8d 59 9f             	lea    -0x61(%ecx),%ebx
  80ad48:	88 5d d3             	mov    %bl,-0x2d(%ebp)
  80ad4b:	80 fb 05             	cmp    $0x5,%bl
  80ad4e:	76 08                	jbe    80ad58 <inet_aton+0x97>
  80ad50:	8d 59 bf             	lea    -0x41(%ecx),%ebx
  80ad53:	80 fb 05             	cmp    $0x5,%bl
  80ad56:	77 18                	ja     80ad70 <inet_aton+0xaf>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  80ad58:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  80ad5c:	19 c9                	sbb    %ecx,%ecx
  80ad5e:	83 e1 20             	and    $0x20,%ecx
  80ad61:	c1 e6 04             	shl    $0x4,%esi
  80ad64:	29 ca                	sub    %ecx,%edx
  80ad66:	8d 52 c9             	lea    -0x37(%edx),%edx
  80ad69:	09 d6                	or     %edx,%esi
        c = *++cp;
  80ad6b:	0f be 10             	movsbl (%eax),%edx
  80ad6e:	eb b2                	jmp    80ad22 <inet_aton+0x61>
      } else
        break;
    }
    if (c == '.') {
  80ad70:	83 fa 2e             	cmp    $0x2e,%edx
  80ad73:	75 2c                	jne    80ada1 <inet_aton+0xe0>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80ad75:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80ad78:	39 55 d8             	cmp    %edx,-0x28(%ebp)
  80ad7b:	0f 83 0a 01 00 00    	jae    80ae8b <inet_aton+0x1ca>
        return (0);
      *pp++ = val;
  80ad81:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80ad84:	89 31                	mov    %esi,(%ecx)
      c = *++cp;
  80ad86:	8d 47 01             	lea    0x1(%edi),%eax
  80ad89:	0f be 10             	movsbl (%eax),%edx
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80ad8c:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80ad8f:	80 f9 09             	cmp    $0x9,%cl
  80ad92:	0f 87 f3 00 00 00    	ja     80ae8b <inet_aton+0x1ca>
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
  80ad98:	83 45 d8 04          	addl   $0x4,-0x28(%ebp)
  80ad9c:	e9 47 ff ff ff       	jmp    80ace8 <inet_aton+0x27>
  80ada1:	89 f3                	mov    %esi,%ebx
  80ada3:	89 f0                	mov    %esi,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  80ada5:	85 d2                	test   %edx,%edx
  80ada7:	74 37                	je     80ade0 <inet_aton+0x11f>
  80ada9:	80 f9 1f             	cmp    $0x1f,%cl
  80adac:	0f 86 d9 00 00 00    	jbe    80ae8b <inet_aton+0x1ca>
  80adb2:	84 d2                	test   %dl,%dl
  80adb4:	0f 88 d1 00 00 00    	js     80ae8b <inet_aton+0x1ca>
  80adba:	83 fa 20             	cmp    $0x20,%edx
  80adbd:	8d 76 00             	lea    0x0(%esi),%esi
  80adc0:	74 1e                	je     80ade0 <inet_aton+0x11f>
  80adc2:	83 fa 0c             	cmp    $0xc,%edx
  80adc5:	74 19                	je     80ade0 <inet_aton+0x11f>
  80adc7:	83 fa 0a             	cmp    $0xa,%edx
  80adca:	74 14                	je     80ade0 <inet_aton+0x11f>
  80adcc:	83 fa 0d             	cmp    $0xd,%edx
  80adcf:	90                   	nop
  80add0:	74 0e                	je     80ade0 <inet_aton+0x11f>
  80add2:	83 fa 09             	cmp    $0x9,%edx
  80add5:	74 09                	je     80ade0 <inet_aton+0x11f>
  80add7:	83 fa 0b             	cmp    $0xb,%edx
  80adda:	0f 85 ab 00 00 00    	jne    80ae8b <inet_aton+0x1ca>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  80ade0:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80ade3:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80ade6:	29 d1                	sub    %edx,%ecx
  80ade8:	89 ca                	mov    %ecx,%edx
  80adea:	c1 fa 02             	sar    $0x2,%edx
  80aded:	83 c2 01             	add    $0x1,%edx
  80adf0:	83 fa 02             	cmp    $0x2,%edx
  80adf3:	74 2d                	je     80ae22 <inet_aton+0x161>
  80adf5:	83 fa 02             	cmp    $0x2,%edx
  80adf8:	7f 10                	jg     80ae0a <inet_aton+0x149>
  80adfa:	85 d2                	test   %edx,%edx
  80adfc:	0f 84 89 00 00 00    	je     80ae8b <inet_aton+0x1ca>
  80ae02:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80ae08:	eb 62                	jmp    80ae6c <inet_aton+0x1ab>
  80ae0a:	83 fa 03             	cmp    $0x3,%edx
  80ae0d:	8d 76 00             	lea    0x0(%esi),%esi
  80ae10:	74 22                	je     80ae34 <inet_aton+0x173>
  80ae12:	83 fa 04             	cmp    $0x4,%edx
  80ae15:	8d 76 00             	lea    0x0(%esi),%esi
  80ae18:	75 52                	jne    80ae6c <inet_aton+0x1ab>
  80ae1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80ae20:	eb 2b                	jmp    80ae4d <inet_aton+0x18c>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  80ae22:	3d ff ff ff 00       	cmp    $0xffffff,%eax
  80ae27:	90                   	nop
  80ae28:	77 61                	ja     80ae8b <inet_aton+0x1ca>
      return (0);
    val |= parts[0] << 24;
  80ae2a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80ae2d:	c1 e3 18             	shl    $0x18,%ebx
  80ae30:	09 c3                	or     %eax,%ebx
    break;
  80ae32:	eb 38                	jmp    80ae6c <inet_aton+0x1ab>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  80ae34:	3d ff ff 00 00       	cmp    $0xffff,%eax
  80ae39:	77 50                	ja     80ae8b <inet_aton+0x1ca>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  80ae3b:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  80ae3e:	c1 e3 10             	shl    $0x10,%ebx
  80ae41:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80ae44:	c1 e2 18             	shl    $0x18,%edx
  80ae47:	09 d3                	or     %edx,%ebx
  80ae49:	09 c3                	or     %eax,%ebx
    break;
  80ae4b:	eb 1f                	jmp    80ae6c <inet_aton+0x1ab>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  80ae4d:	3d ff 00 00 00       	cmp    $0xff,%eax
  80ae52:	77 37                	ja     80ae8b <inet_aton+0x1ca>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  80ae54:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  80ae57:	c1 e3 10             	shl    $0x10,%ebx
  80ae5a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80ae5d:	c1 e2 18             	shl    $0x18,%edx
  80ae60:	09 d3                	or     %edx,%ebx
  80ae62:	8b 55 ec             	mov    -0x14(%ebp),%edx
  80ae65:	c1 e2 08             	shl    $0x8,%edx
  80ae68:	09 d3                	or     %edx,%ebx
  80ae6a:	09 c3                	or     %eax,%ebx
    break;
  }
  if (addr)
  80ae6c:	b8 01 00 00 00       	mov    $0x1,%eax
  80ae71:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80ae75:	74 19                	je     80ae90 <inet_aton+0x1cf>
    addr->s_addr = htonl(val);
  80ae77:	89 1c 24             	mov    %ebx,(%esp)
  80ae7a:	e8 16 fe ff ff       	call   80ac95 <htonl>
  80ae7f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80ae82:	89 03                	mov    %eax,(%ebx)
  80ae84:	b8 01 00 00 00       	mov    $0x1,%eax
  80ae89:	eb 05                	jmp    80ae90 <inet_aton+0x1cf>
  80ae8b:	b8 00 00 00 00       	mov    $0x0,%eax
  return (1);
}
  80ae90:	83 c4 28             	add    $0x28,%esp
  80ae93:	5b                   	pop    %ebx
  80ae94:	5e                   	pop    %esi
  80ae95:	5f                   	pop    %edi
  80ae96:	5d                   	pop    %ebp
  80ae97:	c3                   	ret    

0080ae98 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  80ae98:	55                   	push   %ebp
  80ae99:	89 e5                	mov    %esp,%ebp
  80ae9b:	83 ec 18             	sub    $0x18,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  80ae9e:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80aea1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80aea5:	8b 45 08             	mov    0x8(%ebp),%eax
  80aea8:	89 04 24             	mov    %eax,(%esp)
  80aeab:	e8 11 fe ff ff       	call   80acc1 <inet_aton>
  80aeb0:	83 f8 01             	cmp    $0x1,%eax
  80aeb3:	19 c0                	sbb    %eax,%eax
  80aeb5:	0b 45 fc             	or     -0x4(%ebp),%eax
    return (val.s_addr);
  }
  return (INADDR_NONE);
}
  80aeb8:	c9                   	leave  
  80aeb9:	c3                   	ret    

0080aeba <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  80aeba:	55                   	push   %ebp
  80aebb:	89 e5                	mov    %esp,%ebp
  80aebd:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  80aec0:	8b 45 08             	mov    0x8(%ebp),%eax
  80aec3:	89 04 24             	mov    %eax,(%esp)
  80aec6:	e8 ca fd ff ff       	call   80ac95 <htonl>
}
  80aecb:	c9                   	leave  
  80aecc:	c3                   	ret    
  80aecd:	00 00                	add    %al,(%eax)
	...

0080aed0 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  80aed0:	55                   	push   %ebp
  80aed1:	89 e5                	mov    %esp,%ebp
  80aed3:	57                   	push   %edi
  80aed4:	56                   	push   %esi
  80aed5:	53                   	push   %ebx
  80aed6:	83 ec 3c             	sub    $0x3c,%esp
  80aed9:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  80aedc:	8b 46 78             	mov    0x78(%esi),%eax
  80aedf:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  80aee2:	85 c0                	test   %eax,%eax
  80aee4:	75 0e                	jne    80aef4 <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  80aee6:	8b 56 74             	mov    0x74(%esi),%edx
  80aee9:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  if(seg == NULL)
  80aeec:	85 d2                	test   %edx,%edx
  80aeee:	0f 84 4b 01 00 00    	je     80b03f <tcp_zero_window_probe+0x16f>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  80aef4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80aefb:	00 
  80aefc:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  80af03:	00 
  80af04:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80af0b:	e8 23 d2 ff ff       	call   808133 <pbuf_alloc>
  80af10:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80af12:	85 c0                	test   %eax,%eax
  80af14:	0f 84 25 01 00 00    	je     80b03f <tcp_zero_window_probe+0x16f>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80af1a:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80af1f:	77 1c                	ja     80af3d <tcp_zero_window_probe+0x6d>
  80af21:	c7 44 24 08 cc 3c 81 	movl   $0x813ccc,0x8(%esp)
  80af28:	00 
  80af29:	c7 44 24 04 8d 03 00 	movl   $0x38d,0x4(%esp)
  80af30:	00 
  80af31:	c7 04 24 70 3e 81 00 	movl   $0x813e70,(%esp)
  80af38:	e8 ab 5a ff ff       	call   8009e8 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80af3d:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80af40:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80af44:	89 04 24             	mov    %eax,(%esp)
  80af47:	e8 28 fd ff ff       	call   80ac74 <htons>
  80af4c:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80af4f:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80af53:	89 04 24             	mov    %eax,(%esp)
  80af56:	e8 19 fd ff ff       	call   80ac74 <htons>
  80af5b:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  80af5f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80af62:	8b 41 10             	mov    0x10(%ecx),%eax
  80af65:	8b 40 04             	mov    0x4(%eax),%eax
  80af68:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80af6b:	8b 46 24             	mov    0x24(%esi),%eax
  80af6e:	89 04 24             	mov    %eax,(%esp)
  80af71:	e8 1f fd ff ff       	call   80ac95 <htonl>
  80af76:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80af79:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80af7d:	89 04 24             	mov    %eax,(%esp)
  80af80:	e8 fc fc ff ff       	call   80ac81 <ntohs>
  80af85:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80af8a:	89 04 24             	mov    %eax,(%esp)
  80af8d:	e8 e2 fc ff ff       	call   80ac74 <htons>
  80af92:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80af96:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80af9a:	89 04 24             	mov    %eax,(%esp)
  80af9d:	e8 d2 fc ff ff       	call   80ac74 <htons>
  80afa2:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80afa6:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80afac:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80afb0:	89 04 24             	mov    %eax,(%esp)
  80afb3:	e8 c9 fc ff ff       	call   80ac81 <ntohs>
  80afb8:	83 e0 3f             	and    $0x3f,%eax
  80afbb:	80 cc 50             	or     $0x50,%ah
  80afbe:	89 04 24             	mov    %eax,(%esp)
  80afc1:	e8 ae fc ff ff       	call   80ac74 <htons>
  80afc6:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80afca:	8b 47 04             	mov    0x4(%edi),%eax
  80afcd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80afd0:	8b 51 08             	mov    0x8(%ecx),%edx
  80afd3:	0f b6 12             	movzbl (%edx),%edx
  80afd6:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  80afd9:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80afdf:	8d 46 04             	lea    0x4(%esi),%eax
  80afe2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80afe5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80afe9:	89 44 24 10          	mov    %eax,0x10(%esp)
  80afed:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80aff4:	00 
  80aff5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80aff8:	89 54 24 08          	mov    %edx,0x8(%esp)
  80affc:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b000:	89 3c 24             	mov    %edi,(%esp)
  80b003:	e8 68 f9 ff ff       	call   80a970 <inet_chksum_pseudo>
  80b008:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80b00c:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b013:	00 
  80b014:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80b01b:	00 
  80b01c:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80b020:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b024:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80b027:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80b02b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b02f:	89 3c 24             	mov    %edi,(%esp)
  80b032:	e8 86 ea ff ff       	call   809abd <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80b037:	89 3c 24             	mov    %edi,(%esp)
  80b03a:	e8 39 ce ff ff       	call   807e78 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80b03f:	83 c4 3c             	add    $0x3c,%esp
  80b042:	5b                   	pop    %ebx
  80b043:	5e                   	pop    %esi
  80b044:	5f                   	pop    %edi
  80b045:	5d                   	pop    %ebp
  80b046:	c3                   	ret    

0080b047 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  80b047:	55                   	push   %ebp
  80b048:	89 e5                	mov    %esp,%ebp
  80b04a:	57                   	push   %edi
  80b04b:	56                   	push   %esi
  80b04c:	53                   	push   %ebx
  80b04d:	83 ec 3c             	sub    $0x3c,%esp
  80b050:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80b053:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b05a:	00 
  80b05b:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80b062:	00 
  80b063:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80b06a:	e8 c4 d0 ff ff       	call   808133 <pbuf_alloc>
  80b06f:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80b071:	85 c0                	test   %eax,%eax
  80b073:	0f 84 1b 01 00 00    	je     80b194 <tcp_keepalive+0x14d>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80b079:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80b07e:	77 1c                	ja     80b09c <tcp_keepalive+0x55>
  80b080:	c7 44 24 08 cc 3c 81 	movl   $0x813ccc,0x8(%esp)
  80b087:	00 
  80b088:	c7 44 24 04 3a 03 00 	movl   $0x33a,0x4(%esp)
  80b08f:	00 
  80b090:	c7 04 24 70 3e 81 00 	movl   $0x813e70,(%esp)
  80b097:	e8 4c 59 ff ff       	call   8009e8 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80b09c:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80b09f:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80b0a3:	89 04 24             	mov    %eax,(%esp)
  80b0a6:	e8 c9 fb ff ff       	call   80ac74 <htons>
  80b0ab:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80b0ae:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80b0b2:	89 04 24             	mov    %eax,(%esp)
  80b0b5:	e8 ba fb ff ff       	call   80ac74 <htons>
  80b0ba:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  80b0be:	8b 46 54             	mov    0x54(%esi),%eax
  80b0c1:	83 e8 01             	sub    $0x1,%eax
  80b0c4:	89 04 24             	mov    %eax,(%esp)
  80b0c7:	e8 c9 fb ff ff       	call   80ac95 <htonl>
  80b0cc:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b0cf:	8b 46 24             	mov    0x24(%esi),%eax
  80b0d2:	89 04 24             	mov    %eax,(%esp)
  80b0d5:	e8 bb fb ff ff       	call   80ac95 <htonl>
  80b0da:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80b0dd:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b0e1:	89 04 24             	mov    %eax,(%esp)
  80b0e4:	e8 98 fb ff ff       	call   80ac81 <ntohs>
  80b0e9:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80b0ee:	89 04 24             	mov    %eax,(%esp)
  80b0f1:	e8 7e fb ff ff       	call   80ac74 <htons>
  80b0f6:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b0fa:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80b0fe:	89 04 24             	mov    %eax,(%esp)
  80b101:	e8 6e fb ff ff       	call   80ac74 <htons>
  80b106:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80b10a:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80b110:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b114:	89 04 24             	mov    %eax,(%esp)
  80b117:	e8 65 fb ff ff       	call   80ac81 <ntohs>
  80b11c:	83 e0 3f             	and    $0x3f,%eax
  80b11f:	80 cc 50             	or     $0x50,%ah
  80b122:	89 04 24             	mov    %eax,(%esp)
  80b125:	e8 4a fb ff ff       	call   80ac74 <htons>
  80b12a:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80b12e:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80b134:	8d 46 04             	lea    0x4(%esi),%eax
  80b137:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80b13a:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b13e:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b142:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b149:	00 
  80b14a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b14d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b151:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b155:	89 3c 24             	mov    %edi,(%esp)
  80b158:	e8 13 f8 ff ff       	call   80a970 <inet_chksum_pseudo>
  80b15d:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80b161:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b168:	00 
  80b169:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80b170:	00 
  80b171:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80b175:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b179:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b17c:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b180:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b184:	89 3c 24             	mov    %edi,(%esp)
  80b187:	e8 31 e9 ff ff       	call   809abd <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80b18c:	89 3c 24             	mov    %edi,(%esp)
  80b18f:	e8 e4 cc ff ff       	call   807e78 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80b194:	83 c4 3c             	add    $0x3c,%esp
  80b197:	5b                   	pop    %ebx
  80b198:	5e                   	pop    %esi
  80b199:	5f                   	pop    %edi
  80b19a:	5d                   	pop    %ebp
  80b19b:	c3                   	ret    

0080b19c <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  80b19c:	55                   	push   %ebp
  80b19d:	89 e5                	mov    %esp,%ebp
  80b19f:	57                   	push   %edi
  80b1a0:	56                   	push   %esi
  80b1a1:	53                   	push   %ebx
  80b1a2:	83 ec 3c             	sub    $0x3c,%esp
  80b1a5:	8b 7d 14             	mov    0x14(%ebp),%edi
  80b1a8:	0f b7 45 18          	movzwl 0x18(%ebp),%eax
  80b1ac:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  80b1b0:	0f b7 45 1c          	movzwl 0x1c(%ebp),%eax
  80b1b4:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80b1b8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b1bf:	00 
  80b1c0:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80b1c7:	00 
  80b1c8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80b1cf:	e8 5f cf ff ff       	call   808133 <pbuf_alloc>
  80b1d4:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  80b1d6:	85 c0                	test   %eax,%eax
  80b1d8:	0f 84 15 01 00 00    	je     80b2f3 <tcp_rst+0x157>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80b1de:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80b1e3:	77 1c                	ja     80b201 <tcp_rst+0x65>
  80b1e5:	c7 44 24 08 cc 3c 81 	movl   $0x813ccc,0x8(%esp)
  80b1ec:	00 
  80b1ed:	c7 44 24 04 be 02 00 	movl   $0x2be,0x4(%esp)
  80b1f4:	00 
  80b1f5:	c7 04 24 70 3e 81 00 	movl   $0x813e70,(%esp)
  80b1fc:	e8 e7 57 ff ff       	call   8009e8 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80b201:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  80b204:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80b208:	89 04 24             	mov    %eax,(%esp)
  80b20b:	e8 64 fa ff ff       	call   80ac74 <htons>
  80b210:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  80b213:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b217:	89 04 24             	mov    %eax,(%esp)
  80b21a:	e8 55 fa ff ff       	call   80ac74 <htons>
  80b21f:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  80b223:	8b 45 08             	mov    0x8(%ebp),%eax
  80b226:	89 04 24             	mov    %eax,(%esp)
  80b229:	e8 67 fa ff ff       	call   80ac95 <htonl>
  80b22e:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  80b231:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b234:	89 04 24             	mov    %eax,(%esp)
  80b237:	e8 59 fa ff ff       	call   80ac95 <htonl>
  80b23c:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  80b23f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b243:	89 04 24             	mov    %eax,(%esp)
  80b246:	e8 36 fa ff ff       	call   80ac81 <ntohs>
  80b24b:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80b250:	83 c8 14             	or     $0x14,%eax
  80b253:	89 04 24             	mov    %eax,(%esp)
  80b256:	e8 19 fa ff ff       	call   80ac74 <htons>
  80b25b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  80b25f:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  80b266:	e8 09 fa ff ff       	call   80ac74 <htons>
  80b26b:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80b26f:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80b275:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b279:	89 04 24             	mov    %eax,(%esp)
  80b27c:	e8 00 fa ff ff       	call   80ac81 <ntohs>
  80b281:	83 e0 3f             	and    $0x3f,%eax
  80b284:	80 cc 50             	or     $0x50,%ah
  80b287:	89 04 24             	mov    %eax,(%esp)
  80b28a:	e8 e5 f9 ff ff       	call   80ac74 <htons>
  80b28f:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80b293:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  80b299:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b29d:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b2a1:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b2a8:	00 
  80b2a9:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80b2ad:	8b 45 10             	mov    0x10(%ebp),%eax
  80b2b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b2b4:	89 34 24             	mov    %esi,(%esp)
  80b2b7:	e8 b4 f6 ff ff       	call   80a970 <inet_chksum_pseudo>
  80b2bc:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  80b2c0:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b2c7:	00 
  80b2c8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80b2cf:	00 
  80b2d0:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80b2d7:	00 
  80b2d8:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80b2dc:	8b 45 10             	mov    0x10(%ebp),%eax
  80b2df:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b2e3:	89 34 24             	mov    %esi,(%esp)
  80b2e6:	e8 d2 e7 ff ff       	call   809abd <ip_output>
  pbuf_free(p);
  80b2eb:	89 34 24             	mov    %esi,(%esp)
  80b2ee:	e8 85 cb ff ff       	call   807e78 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  80b2f3:	83 c4 3c             	add    $0x3c,%esp
  80b2f6:	5b                   	pop    %ebx
  80b2f7:	5e                   	pop    %esi
  80b2f8:	5f                   	pop    %edi
  80b2f9:	5d                   	pop    %ebp
  80b2fa:	c3                   	ret    

0080b2fb <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  80b2fb:	55                   	push   %ebp
  80b2fc:	89 e5                	mov    %esp,%ebp
  80b2fe:	57                   	push   %edi
  80b2ff:	56                   	push   %esi
  80b300:	53                   	push   %ebx
  80b301:	83 ec 4c             	sub    $0x4c,%esp
  80b304:	8b 75 08             	mov    0x8(%ebp),%esi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80b307:	b8 00 00 00 00       	mov    $0x0,%eax
  80b30c:	39 35 28 f0 b3 00    	cmp    %esi,0xb3f028
  80b312:	0f 84 7e 04 00 00    	je     80b796 <tcp_output+0x49b>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  80b318:	0f b7 56 4e          	movzwl 0x4e(%esi),%edx
  80b31c:	0f b7 46 5c          	movzwl 0x5c(%esi),%eax
  80b320:	66 39 d0             	cmp    %dx,%ax
  80b323:	76 02                	jbe    80b327 <tcp_output+0x2c>
  80b325:	89 d0                	mov    %edx,%eax
  80b327:	0f b7 c0             	movzwl %ax,%eax
  80b32a:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  seg = pcb->unsent;
  80b32d:	8b 5e 74             	mov    0x74(%esi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80b330:	8b 7e 78             	mov    0x78(%esi),%edi
  if (useg != NULL) {
  80b333:	85 ff                	test   %edi,%edi
  80b335:	74 0a                	je     80b341 <tcp_output+0x46>
    for (; useg->next != NULL; useg = useg->next);
  80b337:	8b 07                	mov    (%edi),%eax
  80b339:	85 c0                	test   %eax,%eax
  80b33b:	74 04                	je     80b341 <tcp_output+0x46>
  80b33d:	89 c7                	mov    %eax,%edi
  80b33f:	eb f6                	jmp    80b337 <tcp_output+0x3c>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80b341:	f6 46 20 02          	testb  $0x2,0x20(%esi)
  80b345:	75 0e                	jne    80b355 <tcp_output+0x5a>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80b347:	85 db                	test   %ebx,%ebx
  80b349:	75 2c                	jne    80b377 <tcp_output+0x7c>
  80b34b:	90                   	nop
  80b34c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80b350:	e9 38 04 00 00       	jmp    80b78d <tcp_output+0x492>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80b355:	85 db                	test   %ebx,%ebx
  80b357:	90                   	nop
  80b358:	74 2e                	je     80b388 <tcp_output+0x8d>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  80b35a:	8b 43 10             	mov    0x10(%ebx),%eax
  80b35d:	8b 40 04             	mov    0x4(%eax),%eax
  80b360:	89 04 24             	mov    %eax,(%esp)
  80b363:	e8 52 fb ff ff       	call   80aeba <ntohl>
  80b368:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80b36c:	2b 56 48             	sub    0x48(%esi),%edx
  80b36f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80b372:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80b375:	72 11                	jb     80b388 <tcp_output+0x8d>
  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80b377:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    netif = ip_route(&(pcb->remote_ip));
  80b37a:	8d 46 04             	lea    0x4(%esi),%eax
  80b37d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80b380:	89 7d d8             	mov    %edi,-0x28(%ebp)
  80b383:	e9 a7 03 00 00       	jmp    80b72f <tcp_output+0x434>
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80b388:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b38f:	00 
  80b390:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80b397:	00 
  80b398:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80b39f:	e8 8f cd ff ff       	call   808133 <pbuf_alloc>
  80b3a4:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  80b3a6:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80b3ab:	85 ff                	test   %edi,%edi
  80b3ad:	0f 84 e3 03 00 00    	je     80b796 <tcp_output+0x49b>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80b3b3:	80 66 20 fc          	andb   $0xfc,0x20(%esi)

    tcphdr = p->payload;
  80b3b7:	8b 5f 04             	mov    0x4(%edi),%ebx
    tcphdr->src = htons(pcb->local_port);
  80b3ba:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80b3be:	89 04 24             	mov    %eax,(%esp)
  80b3c1:	e8 ae f8 ff ff       	call   80ac74 <htons>
  80b3c6:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  80b3c9:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80b3cd:	89 04 24             	mov    %eax,(%esp)
  80b3d0:	e8 9f f8 ff ff       	call   80ac74 <htons>
  80b3d5:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  80b3d9:	8b 46 54             	mov    0x54(%esi),%eax
  80b3dc:	89 04 24             	mov    %eax,(%esp)
  80b3df:	e8 b1 f8 ff ff       	call   80ac95 <htonl>
  80b3e4:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b3e7:	8b 46 24             	mov    0x24(%esi),%eax
  80b3ea:	89 04 24             	mov    %eax,(%esp)
  80b3ed:	e8 a3 f8 ff ff       	call   80ac95 <htonl>
  80b3f2:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  80b3f5:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b3f9:	89 04 24             	mov    %eax,(%esp)
  80b3fc:	e8 80 f8 ff ff       	call   80ac81 <ntohs>
  80b401:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80b406:	83 c8 10             	or     $0x10,%eax
  80b409:	89 04 24             	mov    %eax,(%esp)
  80b40c:	e8 63 f8 ff ff       	call   80ac74 <htons>
  80b411:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b415:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80b419:	89 04 24             	mov    %eax,(%esp)
  80b41c:	e8 53 f8 ff ff       	call   80ac74 <htons>
  80b421:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  80b425:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80b42b:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b42f:	89 04 24             	mov    %eax,(%esp)
  80b432:	e8 4a f8 ff ff       	call   80ac81 <ntohs>
  80b437:	83 e0 3f             	and    $0x3f,%eax
  80b43a:	80 cc 50             	or     $0x50,%ah
  80b43d:	89 04 24             	mov    %eax,(%esp)
  80b440:	e8 2f f8 ff ff       	call   80ac74 <htons>
  80b445:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80b449:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  80b44f:	8d 56 04             	lea    0x4(%esi),%edx
  80b452:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80b455:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b459:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b45d:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b464:	00 
  80b465:	89 54 24 08          	mov    %edx,0x8(%esp)
  80b469:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b46d:	89 3c 24             	mov    %edi,(%esp)
  80b470:	e8 fb f4 ff ff       	call   80a970 <inet_chksum_pseudo>
  80b475:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80b479:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b480:	00 
  80b481:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  80b485:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b489:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80b48d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b491:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b494:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b498:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b49c:	89 3c 24             	mov    %edi,(%esp)
  80b49f:	e8 19 e6 ff ff       	call   809abd <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  80b4a4:	89 3c 24             	mov    %edi,(%esp)
  80b4a7:	e8 cc c9 ff ff       	call   807e78 <pbuf_free>
  80b4ac:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
  80b4b1:	e9 e0 02 00 00       	jmp    80b796 <tcp_output+0x49b>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  80b4b6:	8b 43 10             	mov    0x10(%ebx),%eax
  80b4b9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b4bd:	89 04 24             	mov    %eax,(%esp)
  80b4c0:	e8 bc f7 ff ff       	call   80ac81 <ntohs>
  80b4c5:	a8 04                	test   $0x4,%al
  80b4c7:	74 1c                	je     80b4e5 <tcp_output+0x1ea>
  80b4c9:	c7 44 24 08 88 3e 81 	movl   $0x813e88,0x8(%esp)
  80b4d0:	00 
  80b4d1:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
  80b4d8:	00 
  80b4d9:	c7 04 24 70 3e 81 00 	movl   $0x813e70,(%esp)
  80b4e0:	e8 03 55 ff ff       	call   8009e8 <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80b4e5:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  80b4e9:	74 1c                	je     80b507 <tcp_output+0x20c>
  80b4eb:	0f b6 46 20          	movzbl 0x20(%esi),%eax
  80b4ef:	a8 40                	test   $0x40,%al
  80b4f1:	75 14                	jne    80b507 <tcp_output+0x20c>
  80b4f3:	8b 56 74             	mov    0x74(%esi),%edx
  80b4f6:	85 d2                	test   %edx,%edx
  80b4f8:	0f 84 a0 02 00 00    	je     80b79e <tcp_output+0x4a3>
  80b4fe:	83 3a 00             	cmpl   $0x0,(%edx)
  80b501:	0f 84 97 02 00 00    	je     80b79e <tcp_output+0x4a3>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  80b507:	8b 03                	mov    (%ebx),%eax
  80b509:	89 46 74             	mov    %eax,0x74(%esi)

    if (pcb->state != SYN_SENT) {
  80b50c:	83 7e 10 02          	cmpl   $0x2,0x10(%esi)
  80b510:	74 25                	je     80b537 <tcp_output+0x23c>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  80b512:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b515:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80b519:	89 04 24             	mov    %eax,(%esp)
  80b51c:	e8 60 f7 ff ff       	call   80ac81 <ntohs>
  80b521:	83 c8 10             	or     $0x10,%eax
  80b524:	0f b7 c0             	movzwl %ax,%eax
  80b527:	89 04 24             	mov    %eax,(%esp)
  80b52a:	e8 45 f7 ff ff       	call   80ac74 <htons>
  80b52f:	66 89 47 0c          	mov    %ax,0xc(%edi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80b533:	80 66 20 fc          	andb   $0xfc,0x20(%esi)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b537:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b53a:	8b 46 24             	mov    0x24(%esi),%eax
  80b53d:	89 04 24             	mov    %eax,(%esp)
  80b540:	e8 50 f7 ff ff       	call   80ac95 <htonl>
  80b545:	89 47 08             	mov    %eax,0x8(%edi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b548:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b54b:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80b54f:	89 04 24             	mov    %eax,(%esp)
  80b552:	e8 1d f7 ff ff       	call   80ac74 <htons>
  80b557:	66 89 47 0e          	mov    %ax,0xe(%edi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80b55b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80b55f:	74 05                	je     80b566 <tcp_output+0x26b>
  80b561:	83 3e 00             	cmpl   $0x0,(%esi)
  80b564:	75 22                	jne    80b588 <tcp_output+0x28d>
    netif = ip_route(&(pcb->remote_ip));
  80b566:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b569:	89 14 24             	mov    %edx,(%esp)
  80b56c:	e8 f0 e4 ff ff       	call   809a61 <ip_route>
    if (netif == NULL) {
  80b571:	85 c0                	test   %eax,%eax
  80b573:	0f 84 c3 00 00 00    	je     80b63c <tcp_output+0x341>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  80b579:	ba 00 00 00 00       	mov    $0x0,%edx
  80b57e:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80b581:	74 03                	je     80b586 <tcp_output+0x28b>
  80b583:	8b 50 04             	mov    0x4(%eax),%edx
  80b586:	89 16                	mov    %edx,(%esi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  80b588:	66 83 7e 32 ff       	cmpw   $0xffffffff,0x32(%esi)
  80b58d:	75 06                	jne    80b595 <tcp_output+0x29a>
    pcb->rtime = 0;
  80b58f:	66 c7 46 32 00 00    	movw   $0x0,0x32(%esi)

  if (pcb->rttest == 0) {
  80b595:	83 7e 38 00          	cmpl   $0x0,0x38(%esi)
  80b599:	75 19                	jne    80b5b4 <tcp_output+0x2b9>
    pcb->rttest = tcp_ticks;
  80b59b:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  80b5a0:	89 46 38             	mov    %eax,0x38(%esi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  80b5a3:	8b 43 10             	mov    0x10(%ebx),%eax
  80b5a6:	8b 40 04             	mov    0x4(%eax),%eax
  80b5a9:	89 04 24             	mov    %eax,(%esp)
  80b5ac:	e8 09 f9 ff ff       	call   80aeba <ntohl>
  80b5b1:	89 46 3c             	mov    %eax,0x3c(%esi)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  80b5b4:	8b 43 04             	mov    0x4(%ebx),%eax
  80b5b7:	8b 53 10             	mov    0x10(%ebx),%edx
  80b5ba:	66 2b 50 04          	sub    0x4(%eax),%dx

  seg->p->len -= len;
  80b5be:	66 29 50 0a          	sub    %dx,0xa(%eax)
  seg->p->tot_len -= len;
  80b5c2:	8b 43 04             	mov    0x4(%ebx),%eax
  80b5c5:	66 29 50 08          	sub    %dx,0x8(%eax)

  seg->p->payload = seg->tcphdr;
  80b5c9:	8b 43 04             	mov    0x4(%ebx),%eax
  80b5cc:	8b 53 10             	mov    0x10(%ebx),%edx
  80b5cf:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  80b5d2:	8b 43 10             	mov    0x10(%ebx),%eax
  80b5d5:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80b5db:	8b 7b 10             	mov    0x10(%ebx),%edi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  80b5de:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80b5e1:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  80b5e5:	89 54 24 10          	mov    %edx,0x10(%esp)
  80b5e9:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b5f0:	00 
  80b5f1:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b5f4:	89 54 24 08          	mov    %edx,0x8(%esp)
  80b5f8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b5fb:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b5ff:	89 04 24             	mov    %eax,(%esp)
  80b602:	e8 69 f3 ff ff       	call   80a970 <inet_chksum_pseudo>
  80b607:	66 89 47 10          	mov    %ax,0x10(%edi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80b60b:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b612:	00 
  80b613:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  80b617:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b61b:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80b61f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b623:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b626:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b62a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b62d:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b631:	8b 43 04             	mov    0x4(%ebx),%eax
  80b634:	89 04 24             	mov    %eax,(%esp)
  80b637:	e8 81 e4 ff ff       	call   809abd <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  80b63c:	8b 43 10             	mov    0x10(%ebx),%eax
  80b63f:	8b 40 04             	mov    0x4(%eax),%eax
  80b642:	89 04 24             	mov    %eax,(%esp)
  80b645:	e8 70 f8 ff ff       	call   80aeba <ntohl>
  80b64a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80b64d:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80b651:	8b 43 10             	mov    0x10(%ebx),%eax
  80b654:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b658:	89 04 24             	mov    %eax,(%esp)
  80b65b:	e8 21 f6 ff ff       	call   80ac81 <ntohs>
  80b660:	a8 01                	test   $0x1,%al
  80b662:	75 1b                	jne    80b67f <tcp_output+0x384>
  80b664:	8b 43 10             	mov    0x10(%ebx),%eax
  80b667:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b66b:	89 04 24             	mov    %eax,(%esp)
  80b66e:	e8 0e f6 ff ff       	call   80ac81 <ntohs>
  80b673:	89 c2                	mov    %eax,%edx
  80b675:	b8 00 00 00 00       	mov    $0x0,%eax
  80b67a:	f6 c2 02             	test   $0x2,%dl
  80b67d:	74 05                	je     80b684 <tcp_output+0x389>
  80b67f:	b8 01 00 00 00       	mov    $0x1,%eax
  80b684:	0f b7 ff             	movzwl %di,%edi
  80b687:	8d 3c 38             	lea    (%eax,%edi,1),%edi
  80b68a:	03 7d dc             	add    -0x24(%ebp),%edi
  80b68d:	89 7e 54             	mov    %edi,0x54(%esi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  80b690:	39 7e 58             	cmp    %edi,0x58(%esi)
  80b693:	79 03                	jns    80b698 <tcp_output+0x39d>
      pcb->snd_max = pcb->snd_nxt;
  80b695:	89 7e 58             	mov    %edi,0x58(%esi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  80b698:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80b69c:	8b 43 10             	mov    0x10(%ebx),%eax
  80b69f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b6a3:	89 04 24             	mov    %eax,(%esp)
  80b6a6:	e8 d6 f5 ff ff       	call   80ac81 <ntohs>
  80b6ab:	a8 01                	test   $0x1,%al
  80b6ad:	75 18                	jne    80b6c7 <tcp_output+0x3cc>
  80b6af:	8b 43 10             	mov    0x10(%ebx),%eax
  80b6b2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b6b6:	89 04 24             	mov    %eax,(%esp)
  80b6b9:	e8 c3 f5 ff ff       	call   80ac81 <ntohs>
  80b6be:	ba 00 00 00 00       	mov    $0x0,%edx
  80b6c3:	a8 02                	test   $0x2,%al
  80b6c5:	74 05                	je     80b6cc <tcp_output+0x3d1>
  80b6c7:	ba 01 00 00 00       	mov    $0x1,%edx
  80b6cc:	0f b7 ff             	movzwl %di,%edi
  80b6cf:	01 fa                	add    %edi,%edx
  80b6d1:	74 4d                	je     80b720 <tcp_output+0x425>
      seg->next = NULL;
  80b6d3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  80b6d9:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  80b6dd:	75 08                	jne    80b6e7 <tcp_output+0x3ec>
        pcb->unacked = seg;
  80b6df:	89 5e 78             	mov    %ebx,0x78(%esi)
  80b6e2:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  80b6e5:	eb 41                	jmp    80b728 <tcp_output+0x42d>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  80b6e7:	8b 43 10             	mov    0x10(%ebx),%eax
  80b6ea:	8b 40 04             	mov    0x4(%eax),%eax
  80b6ed:	89 04 24             	mov    %eax,(%esp)
  80b6f0:	e8 c5 f7 ff ff       	call   80aeba <ntohl>
  80b6f5:	89 c7                	mov    %eax,%edi
  80b6f7:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80b6fa:	8b 42 10             	mov    0x10(%edx),%eax
  80b6fd:	8b 40 04             	mov    0x4(%eax),%eax
  80b700:	89 04 24             	mov    %eax,(%esp)
  80b703:	e8 b2 f7 ff ff       	call   80aeba <ntohl>
  80b708:	39 c7                	cmp    %eax,%edi
  80b70a:	79 0a                	jns    80b716 <tcp_output+0x41b>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  80b70c:	8b 46 78             	mov    0x78(%esi),%eax
  80b70f:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  80b711:	89 5e 78             	mov    %ebx,0x78(%esi)
  80b714:	eb 12                	jmp    80b728 <tcp_output+0x42d>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  80b716:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80b719:	89 18                	mov    %ebx,(%eax)
  80b71b:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  80b71e:	eb 08                	jmp    80b728 <tcp_output+0x42d>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  80b720:	89 1c 24             	mov    %ebx,(%esp)
  80b723:	e8 c9 d2 ff ff       	call   8089f1 <tcp_seg_free>
    }
    seg = pcb->unsent;
  80b728:	8b 5e 74             	mov    0x74(%esi),%ebx
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80b72b:	85 db                	test   %ebx,%ebx
  80b72d:	74 5e                	je     80b78d <tcp_output+0x492>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  80b72f:	8b 43 10             	mov    0x10(%ebx),%eax
  80b732:	8b 40 04             	mov    0x4(%eax),%eax
  80b735:	89 04 24             	mov    %eax,(%esp)
  80b738:	e8 7d f7 ff ff       	call   80aeba <ntohl>
  80b73d:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80b741:	2b 56 48             	sub    0x48(%esi),%edx
  80b744:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80b747:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80b74a:	0f 83 66 fd ff ff    	jae    80b4b6 <tcp_output+0x1bb>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80b750:	85 db                	test   %ebx,%ebx
  80b752:	74 39                	je     80b78d <tcp_output+0x492>
  80b754:	80 be a4 00 00 00 00 	cmpb   $0x0,0xa4(%esi)
  80b75b:	75 30                	jne    80b78d <tcp_output+0x492>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  80b75d:	8b 43 10             	mov    0x10(%ebx),%eax
  80b760:	8b 40 04             	mov    0x4(%eax),%eax
  80b763:	89 04 24             	mov    %eax,(%esp)
  80b766:	e8 4f f7 ff ff       	call   80aeba <ntohl>
  80b76b:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80b76f:	2b 56 48             	sub    0x48(%esi),%edx
  80b772:	01 c2                	add    %eax,%edx
  80b774:	0f b7 46 5c          	movzwl 0x5c(%esi),%eax
  80b778:	39 c2                	cmp    %eax,%edx
  80b77a:	76 11                	jbe    80b78d <tcp_output+0x492>
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  80b77c:	c7 86 a0 00 00 00 00 	movl   $0x0,0xa0(%esi)
  80b783:	00 00 00 
    pcb->persist_backoff = 1;
  80b786:	c6 86 a4 00 00 00 01 	movb   $0x1,0xa4(%esi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  80b78d:	80 66 20 7f          	andb   $0x7f,0x20(%esi)
  80b791:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  80b796:	83 c4 4c             	add    $0x4c,%esp
  80b799:	5b                   	pop    %ebx
  80b79a:	5e                   	pop    %esi
  80b79b:	5f                   	pop    %edi
  80b79c:	5d                   	pop    %ebp
  80b79d:	c3                   	ret    
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80b79e:	a8 a0                	test   $0xa0,%al
  80b7a0:	0f 85 61 fd ff ff    	jne    80b507 <tcp_output+0x20c>
  80b7a6:	eb a8                	jmp    80b750 <tcp_output+0x455>

0080b7a8 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  80b7a8:	55                   	push   %ebp
  80b7a9:	89 e5                	mov    %esp,%ebp
  80b7ab:	53                   	push   %ebx
  80b7ac:	83 ec 14             	sub    $0x14,%esp
  80b7af:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80b7b2:	8b 43 78             	mov    0x78(%ebx),%eax
  80b7b5:	85 c0                	test   %eax,%eax
  80b7b7:	74 34                	je     80b7ed <tcp_rexmit+0x45>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  80b7b9:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  80b7bb:	8b 4b 74             	mov    0x74(%ebx),%ecx
  80b7be:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  80b7c0:	8b 43 78             	mov    0x78(%ebx),%eax
  80b7c3:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80b7c6:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80b7c9:	8b 40 10             	mov    0x10(%eax),%eax
  80b7cc:	8b 40 04             	mov    0x4(%eax),%eax
  80b7cf:	89 04 24             	mov    %eax,(%esp)
  80b7d2:	e8 e3 f6 ff ff       	call   80aeba <ntohl>
  80b7d7:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  80b7da:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  80b7de:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80b7e5:	89 1c 24             	mov    %ebx,(%esp)
  80b7e8:	e8 0e fb ff ff       	call   80b2fb <tcp_output>
}
  80b7ed:	83 c4 14             	add    $0x14,%esp
  80b7f0:	5b                   	pop    %ebx
  80b7f1:	5d                   	pop    %ebp
  80b7f2:	c3                   	ret    

0080b7f3 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  80b7f3:	55                   	push   %ebp
  80b7f4:	89 e5                	mov    %esp,%ebp
  80b7f6:	53                   	push   %ebx
  80b7f7:	83 ec 14             	sub    $0x14,%esp
  80b7fa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80b7fd:	8b 43 78             	mov    0x78(%ebx),%eax
  80b800:	85 c0                	test   %eax,%eax
  80b802:	74 3e                	je     80b842 <tcp_rexmit_rto+0x4f>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  80b804:	89 c2                	mov    %eax,%edx
  80b806:	8b 00                	mov    (%eax),%eax
  80b808:	85 c0                	test   %eax,%eax
  80b80a:	75 f8                	jne    80b804 <tcp_rexmit_rto+0x11>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  80b80c:	8b 43 74             	mov    0x74(%ebx),%eax
  80b80f:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  80b811:	8b 43 78             	mov    0x78(%ebx),%eax
  80b814:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  80b817:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80b81e:	8b 40 10             	mov    0x10(%eax),%eax
  80b821:	8b 40 04             	mov    0x4(%eax),%eax
  80b824:	89 04 24             	mov    %eax,(%esp)
  80b827:	e8 8e f6 ff ff       	call   80aeba <ntohl>
  80b82c:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  80b82f:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  80b833:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  80b83a:	89 1c 24             	mov    %ebx,(%esp)
  80b83d:	e8 b9 fa ff ff       	call   80b2fb <tcp_output>
}
  80b842:	83 c4 14             	add    $0x14,%esp
  80b845:	5b                   	pop    %ebx
  80b846:	5d                   	pop    %ebp
  80b847:	c3                   	ret    

0080b848 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  80b848:	55                   	push   %ebp
  80b849:	89 e5                	mov    %esp,%ebp
  80b84b:	57                   	push   %edi
  80b84c:	56                   	push   %esi
  80b84d:	53                   	push   %ebx
  80b84e:	83 ec 5c             	sub    $0x5c,%esp
  80b851:	8b 7d 08             	mov    0x8(%ebp),%edi
  80b854:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b857:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  80b85b:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  80b85f:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  80b863:	88 4d bb             	mov    %cl,-0x45(%ebp)
  80b866:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  80b86a:	88 45 a8             	mov    %al,-0x58(%ebp)
  80b86d:	0f b6 45 20          	movzbl 0x20(%ebp),%eax
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  80b871:	66 83 7d c2 00       	cmpw   $0x0,-0x3e(%ebp)
  80b876:	74 20                	je     80b898 <tcp_enqueue+0x50>
  80b878:	84 c0                	test   %al,%al
  80b87a:	74 1c                	je     80b898 <tcp_enqueue+0x50>
  80b87c:	c7 44 24 08 fc 3c 81 	movl   $0x813cfc,0x8(%esp)
  80b883:	00 
  80b884:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
  80b88b:	00 
  80b88c:	c7 04 24 70 3e 81 00 	movl   $0x813e70,(%esp)
  80b893:	e8 50 51 ff ff       	call   8009e8 <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  80b898:	85 d2                	test   %edx,%edx
  80b89a:	0f 95 45 c1          	setne  -0x3f(%ebp)
  80b89e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80b8a2:	0f 95 45 cb          	setne  -0x35(%ebp)
  80b8a6:	80 7d c1 00          	cmpb   $0x0,-0x3f(%ebp)
  80b8aa:	74 22                	je     80b8ce <tcp_enqueue+0x86>
  80b8ac:	80 7d cb 00          	cmpb   $0x0,-0x35(%ebp)
  80b8b0:	74 1c                	je     80b8ce <tcp_enqueue+0x86>
  80b8b2:	c7 44 24 08 3c 3d 81 	movl   $0x813d3c,0x8(%esp)
  80b8b9:	00 
  80b8ba:	c7 44 24 04 92 00 00 	movl   $0x92,0x4(%esp)
  80b8c1:	00 
  80b8c2:	c7 04 24 70 3e 81 00 	movl   $0x813e70,(%esp)
  80b8c9:	e8 1a 51 ff ff       	call   8009e8 <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80b8ce:	0f b7 4d c2          	movzwl -0x3e(%ebp),%ecx
  80b8d2:	66 3b 4f 6e          	cmp    0x6e(%edi),%cx
  80b8d6:	76 0e                	jbe    80b8e6 <tcp_enqueue+0x9e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  80b8d8:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  80b8dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  80b8e1:	e9 34 06 00 00       	jmp    80bf1a <tcp_enqueue+0x6d2>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  80b8e6:	8b 4f 68             	mov    0x68(%edi),%ecx
  80b8e9:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  80b8ec:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  80b8f0:	66 89 4d e2          	mov    %cx,-0x1e(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80b8f4:	66 83 f9 1f          	cmp    $0x1f,%cx
  80b8f8:	76 0e                	jbe    80b908 <tcp_enqueue+0xc0>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  80b8fa:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  80b8fe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  80b903:	e9 12 06 00 00       	jmp    80bf1a <tcp_enqueue+0x6d2>
  }
  if (queuelen != 0) {
  80b908:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  80b90d:	74 74                	je     80b983 <tcp_enqueue+0x13b>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80b90f:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b913:	74 4c                	je     80b961 <tcp_enqueue+0x119>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80b915:	89 c1                	mov    %eax,%ecx
  80b917:	c0 e9 02             	shr    $0x2,%cl
  80b91a:	c1 e1 0c             	shl    $0xc,%ecx
  80b91d:	66 81 c1 00 50       	add    $0x5000,%cx
  80b922:	66 89 4d c6          	mov    %cx,-0x3a(%ebp)
  80b926:	89 55 d0             	mov    %edx,-0x30(%ebp)
  80b929:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  80b92d:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  80b931:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  80b938:	be 00 00 00 00       	mov    $0x0,%esi
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80b93d:	0f b6 4d a8          	movzbl -0x58(%ebp),%ecx
  80b941:	83 e1 01             	and    $0x1,%ecx
  80b944:	89 4d bc             	mov    %ecx,-0x44(%ebp)
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80b947:	0f b6 d0             	movzbl %al,%edx
  80b94a:	89 55 cc             	mov    %edx,-0x34(%ebp)
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80b94d:	0f b6 c0             	movzbl %al,%eax
  80b950:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
    seg->tcphdr = seg->p->payload;
    seg->tcphdr->src = htons(pcb->local_port);
    seg->tcphdr->dest = htons(pcb->remote_port);
    seg->tcphdr->seqno = htonl(seqno);
    seg->tcphdr->urgp = 0;
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  80b954:	0f b6 4d bb          	movzbl -0x45(%ebp),%ecx
  80b958:	66 89 4d c8          	mov    %cx,-0x38(%ebp)
  80b95c:	89 7d dc             	mov    %edi,-0x24(%ebp)
  80b95f:	eb 55                	jmp    80b9b6 <tcp_enqueue+0x16e>
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80b961:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80b965:	75 ae                	jne    80b915 <tcp_enqueue+0xcd>
  80b967:	c7 44 24 08 84 3d 81 	movl   $0x813d84,0x8(%esp)
  80b96e:	00 
  80b96f:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
  80b976:	00 
  80b977:	c7 04 24 70 3e 81 00 	movl   $0x813e70,(%esp)
  80b97e:	e8 65 50 ff ff       	call   8009e8 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  80b983:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b987:	75 06                	jne    80b98f <tcp_enqueue+0x147>
  80b989:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80b98d:	74 86                	je     80b915 <tcp_enqueue+0xcd>
  80b98f:	c7 44 24 08 c0 3d 81 	movl   $0x813dc0,0x8(%esp)
  80b996:	00 
  80b997:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  80b99e:	00 
  80b99f:	c7 04 24 70 3e 81 00 	movl   $0x813e70,(%esp)
  80b9a6:	e8 3d 50 ff ff       	call   8009e8 <_panic>
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  80b9ab:	0f b7 f6             	movzwl %si,%esi
  80b9ae:	01 75 d8             	add    %esi,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  80b9b1:	01 75 d0             	add    %esi,-0x30(%ebp)
  80b9b4:	89 de                	mov    %ebx,%esi
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80b9b6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b9b9:	0f b7 78 34          	movzwl 0x34(%eax),%edi

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80b9bd:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80b9c4:	e8 5b bd ff ff       	call   807724 <memp_malloc>
  80b9c9:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  80b9cb:	85 c0                	test   %eax,%eax
  80b9cd:	0f 84 d8 04 00 00    	je     80beab <tcp_enqueue+0x663>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  80b9d3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  80b9d9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  80b9e0:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80b9e4:	75 05                	jne    80b9eb <tcp_enqueue+0x1a3>
  80b9e6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80b9e9:	eb 22                	jmp    80ba0d <tcp_enqueue+0x1c5>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  80b9eb:	85 f6                	test   %esi,%esi
  80b9ed:	75 1c                	jne    80ba0b <tcp_enqueue+0x1c3>
  80b9ef:	c7 44 24 08 9f 3e 81 	movl   $0x813e9f,0x8(%esp)
  80b9f6:	00 
  80b9f7:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80b9fe:	00 
  80b9ff:	c7 04 24 70 3e 81 00 	movl   $0x813e70,(%esp)
  80ba06:	e8 dd 4f ff ff       	call   8009e8 <_panic>
      useg->next = seg;
  80ba0b:	89 06                	mov    %eax,(%esi)
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80ba0d:	0f b7 75 e4          	movzwl -0x1c(%ebp),%esi
  80ba11:	66 39 fe             	cmp    %di,%si
  80ba14:	76 02                	jbe    80ba18 <tcp_enqueue+0x1d0>
  80ba16:	89 fe                	mov    %edi,%esi
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  80ba18:	80 7d cb 00          	cmpb   $0x0,-0x35(%ebp)
  80ba1c:	74 69                	je     80ba87 <tcp_enqueue+0x23f>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80ba1e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ba25:	00 
  80ba26:	8b 55 cc             	mov    -0x34(%ebp),%edx
  80ba29:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ba2d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ba34:	e8 fa c6 ff ff       	call   808133 <pbuf_alloc>
  80ba39:	89 43 04             	mov    %eax,0x4(%ebx)
  80ba3c:	85 c0                	test   %eax,%eax
  80ba3e:	0f 84 6c 04 00 00    	je     80beb0 <tcp_enqueue+0x668>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80ba44:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  80ba48:	66 39 48 0a          	cmp    %cx,0xa(%eax)
  80ba4c:	73 1c                	jae    80ba6a <tcp_enqueue+0x222>
  80ba4e:	c7 44 24 08 f4 3d 81 	movl   $0x813df4,0x8(%esp)
  80ba55:	00 
  80ba56:	c7 44 24 04 df 00 00 	movl   $0xdf,0x4(%esp)
  80ba5d:	00 
  80ba5e:	c7 04 24 70 3e 81 00 	movl   $0x813e70,(%esp)
  80ba65:	e8 7e 4f ff ff       	call   8009e8 <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  80ba6a:	89 04 24             	mov    %eax,(%esp)
  80ba6d:	e8 9e bf ff ff       	call   807a10 <pbuf_clen>
  80ba72:	0f b6 c0             	movzbl %al,%eax
  80ba75:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      seg->dataptr = seg->p->payload;
  80ba79:	8b 43 04             	mov    0x4(%ebx),%eax
  80ba7c:	8b 40 04             	mov    0x4(%eax),%eax
  80ba7f:	89 43 08             	mov    %eax,0x8(%ebx)
  80ba82:	e9 1e 01 00 00       	jmp    80bba5 <tcp_enqueue+0x35d>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80ba87:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
  80ba8b:	0f 84 8b 00 00 00    	je     80bb1c <tcp_enqueue+0x2d4>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  80ba91:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ba98:	00 
  80ba99:	0f b7 c6             	movzwl %si,%eax
  80ba9c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80baa0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80baa7:	e8 87 c6 ff ff       	call   808133 <pbuf_alloc>
  80baac:	89 43 04             	mov    %eax,0x4(%ebx)
  80baaf:	85 c0                	test   %eax,%eax
  80bab1:	0f 84 fe 03 00 00    	je     80beb5 <tcp_enqueue+0x66d>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  80bab7:	66 3b 70 0a          	cmp    0xa(%eax),%si
  80babb:	76 1c                	jbe    80bad9 <tcp_enqueue+0x291>
  80babd:	c7 44 24 08 1c 3e 81 	movl   $0x813e1c,0x8(%esp)
  80bac4:	00 
  80bac5:	c7 44 24 04 ea 00 00 	movl   $0xea,0x4(%esp)
  80bacc:	00 
  80bacd:	c7 04 24 70 3e 81 00 	movl   $0x813e70,(%esp)
  80bad4:	e8 0f 4f ff ff       	call   8009e8 <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  80bad9:	89 04 24             	mov    %eax,(%esp)
  80badc:	e8 2f bf ff ff       	call   807a10 <pbuf_clen>
  80bae1:	89 c7                	mov    %eax,%edi
      if (arg != NULL) {
  80bae3:	80 7d c1 00          	cmpb   $0x0,-0x3f(%ebp)
  80bae7:	74 1c                	je     80bb05 <tcp_enqueue+0x2bd>
        MEMCPY(seg->p->payload, ptr, seglen);
  80bae9:	0f b7 c6             	movzwl %si,%eax
  80baec:	89 44 24 08          	mov    %eax,0x8(%esp)
  80baf0:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80baf3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80baf7:	8b 43 04             	mov    0x4(%ebx),%eax
  80bafa:	8b 40 04             	mov    0x4(%eax),%eax
  80bafd:	89 04 24             	mov    %eax,(%esp)
  80bb00:	e8 2c 5b ff ff       	call   801631 <memcpy>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  80bb05:	89 fa                	mov    %edi,%edx
  80bb07:	0f b6 c2             	movzbl %dl,%eax
  80bb0a:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      if (arg != NULL) {
        MEMCPY(seg->p->payload, ptr, seglen);
      }
      seg->dataptr = seg->p->payload;
  80bb0e:	8b 43 04             	mov    0x4(%ebx),%eax
  80bb11:	8b 40 04             	mov    0x4(%eax),%eax
  80bb14:	89 43 08             	mov    %eax,0x8(%ebx)
  80bb17:	e9 89 00 00 00       	jmp    80bba5 <tcp_enqueue+0x35d>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  80bb1c:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80bb23:	00 
  80bb24:	0f b7 c6             	movzwl %si,%eax
  80bb27:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bb2b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80bb32:	e8 fc c5 ff ff       	call   808133 <pbuf_alloc>
  80bb37:	89 c7                	mov    %eax,%edi
  80bb39:	85 c0                	test   %eax,%eax
  80bb3b:	0f 84 79 03 00 00    	je     80beba <tcp_enqueue+0x672>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
      /* reference the non-volatile payload data */
      p->payload = ptr;
  80bb41:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80bb44:	89 48 04             	mov    %ecx,0x4(%eax)
      seg->dataptr = ptr;
  80bb47:	89 4b 08             	mov    %ecx,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  80bb4a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bb51:	00 
  80bb52:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bb59:	00 
  80bb5a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80bb61:	e8 cd c5 ff ff       	call   808133 <pbuf_alloc>
  80bb66:	89 43 04             	mov    %eax,0x4(%ebx)
  80bb69:	85 c0                	test   %eax,%eax
  80bb6b:	75 12                	jne    80bb7f <tcp_enqueue+0x337>
  80bb6d:	89 fb                	mov    %edi,%ebx
  80bb6f:	8b 7d dc             	mov    -0x24(%ebp),%edi
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  80bb72:	89 1c 24             	mov    %ebx,(%esp)
  80bb75:	e8 fe c2 ff ff       	call   807e78 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  80bb7a:	e9 4b 03 00 00       	jmp    80beca <tcp_enqueue+0x682>
      }
      queuelen += pbuf_clen(seg->p);
  80bb7f:	89 04 24             	mov    %eax,(%esp)
  80bb82:	e8 89 be ff ff       	call   807a10 <pbuf_clen>
  80bb87:	0f b6 c0             	movzbl %al,%eax
  80bb8a:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  80bb8e:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  80bb92:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  80bb96:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80bb9a:	8b 43 04             	mov    0x4(%ebx),%eax
  80bb9d:	89 04 24             	mov    %eax,(%esp)
  80bba0:	e8 96 be ff ff       	call   807a3b <pbuf_cat>
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80bba5:	66 83 7d e2 20       	cmpw   $0x20,-0x1e(%ebp)
  80bbaa:	0f 87 12 03 00 00    	ja     80bec2 <tcp_enqueue+0x67a>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  80bbb0:	66 89 73 0c          	mov    %si,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  80bbb4:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80bbbb:	00 
  80bbbc:	8b 43 04             	mov    0x4(%ebx),%eax
  80bbbf:	89 04 24             	mov    %eax,(%esp)
  80bbc2:	e8 3c bf ff ff       	call   807b03 <pbuf_header>
  80bbc7:	84 c0                	test   %al,%al
  80bbc9:	0f 85 f8 02 00 00    	jne    80bec7 <tcp_enqueue+0x67f>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  80bbcf:	8b 43 04             	mov    0x4(%ebx),%eax
  80bbd2:	8b 78 04             	mov    0x4(%eax),%edi
  80bbd5:	89 7b 10             	mov    %edi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  80bbd8:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80bbdb:	0f b7 41 1c          	movzwl 0x1c(%ecx),%eax
  80bbdf:	89 04 24             	mov    %eax,(%esp)
  80bbe2:	e8 8d f0 ff ff       	call   80ac74 <htons>
  80bbe7:	66 89 07             	mov    %ax,(%edi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  80bbea:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bbed:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80bbf0:	0f b7 42 1e          	movzwl 0x1e(%edx),%eax
  80bbf4:	89 04 24             	mov    %eax,(%esp)
  80bbf7:	e8 78 f0 ff ff       	call   80ac74 <htons>
  80bbfc:	66 89 47 02          	mov    %ax,0x2(%edi)
    seg->tcphdr->seqno = htonl(seqno);
  80bc00:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bc03:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80bc06:	89 0c 24             	mov    %ecx,(%esp)
  80bc09:	e8 87 f0 ff ff       	call   80ac95 <htonl>
  80bc0e:	89 47 04             	mov    %eax,0x4(%edi)
    seg->tcphdr->urgp = 0;
  80bc11:	8b 43 10             	mov    0x10(%ebx),%eax
  80bc14:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  80bc1a:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bc1d:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80bc21:	89 04 24             	mov    %eax,(%esp)
  80bc24:	e8 58 f0 ff ff       	call   80ac81 <ntohs>
  80bc29:	83 e0 c0             	and    $0xffffffc0,%eax
  80bc2c:	66 0b 45 c8          	or     -0x38(%ebp),%ax
  80bc30:	0f b7 c0             	movzwl %ax,%eax
  80bc33:	89 04 24             	mov    %eax,(%esp)
  80bc36:	e8 39 f0 ff ff       	call   80ac74 <htons>
  80bc3b:	66 89 47 0c          	mov    %ax,0xc(%edi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  80bc3f:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80bc43:	75 23                	jne    80bc68 <tcp_enqueue+0x420>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  80bc45:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bc48:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80bc4c:	89 04 24             	mov    %eax,(%esp)
  80bc4f:	e8 2d f0 ff ff       	call   80ac81 <ntohs>
  80bc54:	83 e0 3f             	and    $0x3f,%eax
  80bc57:	80 cc 50             	or     $0x50,%ah
  80bc5a:	89 04 24             	mov    %eax,(%esp)
  80bc5d:	e8 12 f0 ff ff       	call   80ac74 <htons>
  80bc62:	66 89 47 0c          	mov    %ax,0xc(%edi)
  80bc66:	eb 3e                	jmp    80bca6 <tcp_enqueue+0x45e>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80bc68:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bc6b:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80bc6f:	89 04 24             	mov    %eax,(%esp)
  80bc72:	e8 0a f0 ff ff       	call   80ac81 <ntohs>
  80bc77:	83 e0 3f             	and    $0x3f,%eax
  80bc7a:	66 0b 45 c6          	or     -0x3a(%ebp),%ax
  80bc7e:	0f b7 c0             	movzwl %ax,%eax
  80bc81:	89 04 24             	mov    %eax,(%esp)
  80bc84:	e8 eb ef ff ff       	call   80ac74 <htons>
  80bc89:	66 89 47 0c          	mov    %ax,0xc(%edi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  80bc8d:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80bc90:	89 44 24 08          	mov    %eax,0x8(%esp)
  80bc94:	8b 55 1c             	mov    0x1c(%ebp),%edx
  80bc97:	89 54 24 04          	mov    %edx,0x4(%esp)
  80bc9b:	8b 43 08             	mov    0x8(%ebx),%eax
  80bc9e:	89 04 24             	mov    %eax,(%esp)
  80bca1:	e8 8b 59 ff ff       	call   801631 <memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  80bca6:	66 29 75 e4          	sub    %si,-0x1c(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  80bcaa:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80bcae:	0f 84 f7 fc ff ff    	je     80b9ab <tcp_enqueue+0x163>
  80bcb4:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  80bcb9:	0f 85 ec fc ff ff    	jne    80b9ab <tcp_enqueue+0x163>
  80bcbf:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bcc2:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  80bcc5:	8b 4f 74             	mov    0x74(%edi),%ecx
  80bcc8:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80bccb:	85 c9                	test   %ecx,%ecx
  80bccd:	0f 84 1f 01 00 00    	je     80bdf2 <tcp_enqueue+0x5aa>
  80bcd3:	89 ca                	mov    %ecx,%edx
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  80bcd5:	89 d0                	mov    %edx,%eax
  80bcd7:	8b 12                	mov    (%edx),%edx
  80bcd9:	85 d2                	test   %edx,%edx
  80bcdb:	75 f8                	jne    80bcd5 <tcp_enqueue+0x48d>
  80bcdd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80bce0:	85 c0                	test   %eax,%eax
  80bce2:	0f 84 0a 01 00 00    	je     80bdf2 <tcp_enqueue+0x5aa>
    TCP_TCPLEN(useg) != 0 &&
  80bce8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80bcec:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  80bcf0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80bcf3:	8b 42 10             	mov    0x10(%edx),%eax
  80bcf6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80bcfa:	89 04 24             	mov    %eax,(%esp)
  80bcfd:	e8 7f ef ff ff       	call   80ac81 <ntohs>
  80bd02:	a8 01                	test   $0x1,%al
  80bd04:	75 1b                	jne    80bd21 <tcp_enqueue+0x4d9>
  80bd06:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80bd09:	8b 41 10             	mov    0x10(%ecx),%eax
  80bd0c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80bd10:	89 04 24             	mov    %eax,(%esp)
  80bd13:	e8 69 ef ff ff       	call   80ac81 <ntohs>
  80bd18:	ba 00 00 00 00       	mov    $0x0,%edx
  80bd1d:	a8 02                	test   $0x2,%al
  80bd1f:	74 05                	je     80bd26 <tcp_enqueue+0x4de>
  80bd21:	ba 01 00 00 00       	mov    $0x1,%edx
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80bd26:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  80bd2a:	01 c2                	add    %eax,%edx
  80bd2c:	0f 84 f0 01 00 00    	je     80bf22 <tcp_enqueue+0x6da>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  80bd32:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80bd35:	8b 42 10             	mov    0x10(%edx),%eax
  80bd38:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80bd3c:	89 04 24             	mov    %eax,(%esp)
  80bd3f:	e8 3d ef ff ff       	call   80ac81 <ntohs>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80bd44:	a8 03                	test   $0x3,%al
  80bd46:	0f 85 d6 01 00 00    	jne    80bf22 <tcp_enqueue+0x6da>
  80bd4c:	f6 45 bb 03          	testb  $0x3,-0x45(%ebp)
  80bd50:	0f 85 cc 01 00 00    	jne    80bf22 <tcp_enqueue+0x6da>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  80bd56:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80bd59:	0f b7 51 0c          	movzwl 0xc(%ecx),%edx
  80bd5d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80bd60:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  80bd64:	01 c2                	add    %eax,%edx
  80bd66:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80bd6a:	39 c2                	cmp    %eax,%edx
  80bd6c:	0f 8f b0 01 00 00    	jg     80bf22 <tcp_enqueue+0x6da>
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  80bd72:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80bd79:	ff 
  80bd7a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80bd7d:	8b 42 04             	mov    0x4(%edx),%eax
  80bd80:	89 04 24             	mov    %eax,(%esp)
  80bd83:	e8 7b bd ff ff       	call   807b03 <pbuf_header>
  80bd88:	84 c0                	test   %al,%al
  80bd8a:	74 1c                	je     80bda8 <tcp_enqueue+0x560>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80bd8c:	c7 44 24 08 ac 3e 81 	movl   $0x813eac,0x8(%esp)
  80bd93:	00 
  80bd94:	c7 44 24 04 52 01 00 	movl   $0x152,0x4(%esp)
  80bd9b:	00 
  80bd9c:	c7 04 24 70 3e 81 00 	movl   $0x813e70,(%esp)
  80bda3:	e8 40 4c ff ff       	call   8009e8 <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  80bda8:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80bdab:	8b 41 04             	mov    0x4(%ecx),%eax
  80bdae:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bdb2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80bdb5:	8b 42 04             	mov    0x4(%edx),%eax
  80bdb8:	89 04 24             	mov    %eax,(%esp)
  80bdbb:	e8 7b bc ff ff       	call   807a3b <pbuf_cat>
    useg->len += queue->len;
  80bdc0:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80bdc3:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  80bdc7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80bdca:	66 01 42 0c          	add    %ax,0xc(%edx)
    useg->next = queue->next;
  80bdce:	8b 01                	mov    (%ecx),%eax
  80bdd0:	89 02                	mov    %eax,(%edx)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  80bdd2:	39 4d d8             	cmp    %ecx,-0x28(%ebp)
  80bdd5:	0f 94 c0             	sete   %al
  80bdd8:	0f b6 c0             	movzbl %al,%eax
  80bddb:	83 e8 01             	sub    $0x1,%eax
  80bdde:	21 c3                	and    %eax,%ebx
      seg = NULL;
    }
    memp_free(MEMP_TCP_SEG, queue);
  80bde0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80bde4:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80bdeb:	e8 f0 b8 ff ff       	call   8076e0 <memp_free>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80bdf0:	eb 06                	jmp    80bdf8 <tcp_enqueue+0x5b0>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  80bdf2:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80bdf5:	89 4f 74             	mov    %ecx,0x74(%edi)
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  80bdf8:	f6 45 bb 02          	testb  $0x2,-0x45(%ebp)
  80bdfc:	75 0c                	jne    80be0a <tcp_enqueue+0x5c2>
  80bdfe:	f6 45 bb 01          	testb  $0x1,-0x45(%ebp)
  80be02:	0f 85 27 01 00 00    	jne    80bf2f <tcp_enqueue+0x6e7>
  80be08:	eb 0f                	jmp    80be19 <tcp_enqueue+0x5d1>
    ++len;
  80be0a:	66 83 45 c2 01       	addw   $0x1,-0x3e(%ebp)
  }
  if (flags & TCP_FIN) {
  80be0f:	f6 45 bb 01          	testb  $0x1,-0x45(%ebp)
  80be13:	74 04                	je     80be19 <tcp_enqueue+0x5d1>
    pcb->flags |= TF_FIN;
  80be15:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  }
  pcb->snd_lbb += len;
  80be19:	0f b7 45 c2          	movzwl -0x3e(%ebp),%eax
  80be1d:	01 47 68             	add    %eax,0x68(%edi)

  pcb->snd_buf -= len;
  80be20:	0f b7 45 c2          	movzwl -0x3e(%ebp),%eax
  80be24:	66 29 47 6e          	sub    %ax,0x6e(%edi)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  80be28:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  80be2c:	66 89 57 70          	mov    %dx,0x70(%edi)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  80be30:	66 85 d2             	test   %dx,%dx
  80be33:	74 28                	je     80be5d <tcp_enqueue+0x615>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80be35:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80be39:	75 22                	jne    80be5d <tcp_enqueue+0x615>
  80be3b:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80be3f:	75 1c                	jne    80be5d <tcp_enqueue+0x615>
  80be41:	c7 44 24 08 50 3e 81 	movl   $0x813e50,0x8(%esp)
  80be48:	00 
  80be49:	c7 44 24 04 7a 01 00 	movl   $0x17a,0x4(%esp)
  80be50:	00 
  80be51:	c7 04 24 70 3e 81 00 	movl   $0x813e70,(%esp)
  80be58:	e8 8b 4b ff ff       	call   8009e8 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  80be5d:	85 db                	test   %ebx,%ebx
  80be5f:	0f 84 b0 00 00 00    	je     80bf15 <tcp_enqueue+0x6cd>
  80be65:	66 85 f6             	test   %si,%si
  80be68:	0f 84 a7 00 00 00    	je     80bf15 <tcp_enqueue+0x6cd>
  80be6e:	8b 5b 10             	mov    0x10(%ebx),%ebx
  80be71:	85 db                	test   %ebx,%ebx
  80be73:	0f 84 9c 00 00 00    	je     80bf15 <tcp_enqueue+0x6cd>
  80be79:	f6 45 a8 02          	testb  $0x2,-0x58(%ebp)
  80be7d:	8d 76 00             	lea    0x0(%esi),%esi
  80be80:	0f 85 8f 00 00 00    	jne    80bf15 <tcp_enqueue+0x6cd>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  80be86:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80be8a:	89 04 24             	mov    %eax,(%esp)
  80be8d:	e8 ef ed ff ff       	call   80ac81 <ntohs>
  80be92:	83 c8 08             	or     $0x8,%eax
  80be95:	0f b7 c0             	movzwl %ax,%eax
  80be98:	89 04 24             	mov    %eax,(%esp)
  80be9b:	e8 d4 ed ff ff       	call   80ac74 <htons>
  80bea0:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  80bea4:	b8 00 00 00 00       	mov    $0x0,%eax
  80bea9:	eb 6f                	jmp    80bf1a <tcp_enqueue+0x6d2>
  80beab:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80beae:	eb 1a                	jmp    80beca <tcp_enqueue+0x682>
  80beb0:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80beb3:	eb 15                	jmp    80beca <tcp_enqueue+0x682>
  80beb5:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80beb8:	eb 10                	jmp    80beca <tcp_enqueue+0x682>
  80beba:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bebd:	8d 76 00             	lea    0x0(%esi),%esi
  80bec0:	eb 08                	jmp    80beca <tcp_enqueue+0x682>
  80bec2:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bec5:	eb 03                	jmp    80beca <tcp_enqueue+0x682>
  80bec7:	8b 7d dc             	mov    -0x24(%ebp),%edi
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  80beca:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  80bece:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80bed2:	74 0b                	je     80bedf <tcp_enqueue+0x697>
    tcp_segs_free(queue);
  80bed4:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80bed7:	89 0c 24             	mov    %ecx,(%esp)
  80beda:	e8 57 cb ff ff       	call   808a36 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  80bedf:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80bee4:	74 28                	je     80bf0e <tcp_enqueue+0x6c6>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  80bee6:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80beea:	75 22                	jne    80bf0e <tcp_enqueue+0x6c6>
  80beec:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80bef0:	75 1c                	jne    80bf0e <tcp_enqueue+0x6c6>
  80bef2:	c7 44 24 08 50 3e 81 	movl   $0x813e50,0x8(%esp)
  80bef9:	00 
  80befa:	c7 44 24 04 8d 01 00 	movl   $0x18d,0x4(%esp)
  80bf01:	00 
  80bf02:	c7 04 24 70 3e 81 00 	movl   $0x813e70,(%esp)
  80bf09:	e8 da 4a ff ff       	call   8009e8 <_panic>
  80bf0e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bf13:	eb 05                	jmp    80bf1a <tcp_enqueue+0x6d2>
  80bf15:	b8 00 00 00 00       	mov    $0x0,%eax
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  80bf1a:	83 c4 5c             	add    $0x5c,%esp
  80bf1d:	5b                   	pop    %ebx
  80bf1e:	5e                   	pop    %esi
  80bf1f:	5f                   	pop    %edi
  80bf20:	5d                   	pop    %ebp
  80bf21:	c3                   	ret    
      /* initialize list with this segment */
      pcb->unsent = queue;
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  80bf22:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80bf25:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80bf28:	89 10                	mov    %edx,(%eax)
  80bf2a:	e9 c9 fe ff ff       	jmp    80bdf8 <tcp_enqueue+0x5b0>
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    ++len;
  80bf2f:	66 83 45 c2 01       	addw   $0x1,-0x3e(%ebp)
  80bf34:	e9 dc fe ff ff       	jmp    80be15 <tcp_enqueue+0x5cd>

0080bf39 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  80bf39:	55                   	push   %ebp
  80bf3a:	89 e5                	mov    %esp,%ebp
  80bf3c:	83 ec 28             	sub    $0x28,%esp
  80bf3f:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80bf42:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80bf45:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80bf48:	0f b7 5d 10          	movzwl 0x10(%ebp),%ebx
  80bf4c:	0f b6 75 14          	movzbl 0x14(%ebp),%esi
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  80bf50:	8b 51 10             	mov    0x10(%ecx),%edx
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  80bf53:	83 fa 04             	cmp    $0x4,%edx
  80bf56:	74 14                	je     80bf6c <tcp_write+0x33>
  80bf58:	83 fa 07             	cmp    $0x7,%edx
  80bf5b:	74 0f                	je     80bf6c <tcp_write+0x33>
  80bf5d:	83 fa 02             	cmp    $0x2,%edx
  80bf60:	74 0a                	je     80bf6c <tcp_write+0x33>
  80bf62:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  80bf67:	83 fa 03             	cmp    $0x3,%edx
  80bf6a:	75 42                	jne    80bfae <tcp_write+0x75>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  80bf6c:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf71:	66 85 db             	test   %bx,%bx
  80bf74:	74 38                	je     80bfae <tcp_write+0x75>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  80bf76:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80bf7d:	00 
  80bf7e:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80bf85:	00 
  80bf86:	81 e6 ff 00 00 00    	and    $0xff,%esi
  80bf8c:	89 74 24 10          	mov    %esi,0x10(%esp)
  80bf90:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80bf97:	00 
  80bf98:	0f b7 db             	movzwl %bx,%ebx
  80bf9b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80bf9f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bfa2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bfa6:	89 0c 24             	mov    %ecx,(%esp)
  80bfa9:	e8 9a f8 ff ff       	call   80b848 <tcp_enqueue>
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  }
}
  80bfae:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80bfb1:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80bfb4:	89 ec                	mov    %ebp,%esp
  80bfb6:	5d                   	pop    %ebp
  80bfb7:	c3                   	ret    

0080bfb8 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  80bfb8:	55                   	push   %ebp
  80bfb9:	89 e5                	mov    %esp,%ebp
  80bfbb:	83 ec 28             	sub    $0x28,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  80bfbe:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80bfc5:	00 
  80bfc6:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80bfcd:	00 
  80bfce:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  80bfd5:	00 
  80bfd6:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  80bfda:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80bfde:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bfe5:	00 
  80bfe6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bfed:	00 
  80bfee:	8b 45 08             	mov    0x8(%ebp),%eax
  80bff1:	89 04 24             	mov    %eax,(%esp)
  80bff4:	e8 4f f8 ff ff       	call   80b848 <tcp_enqueue>
}
  80bff9:	c9                   	leave  
  80bffa:	c3                   	ret    
  80bffb:	00 00                	add    %al,(%eax)
  80bffd:	00 00                	add    %al,(%eax)
	...

0080c000 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  80c000:	55                   	push   %ebp
  80c001:	89 e5                	mov    %esp,%ebp
  80c003:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  80c006:	8b 15 2c 3b 81 00    	mov    0x813b2c,%edx
  80c00c:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  80c00f:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  80c015:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  80c019:	5d                   	pop    %ebp
  80c01a:	c3                   	ret    

0080c01b <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  80c01b:	55                   	push   %ebp
  80c01c:	89 e5                	mov    %esp,%ebp
  80c01e:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80c021:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c024:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  80c027:	8b 55 10             	mov    0x10(%ebp),%edx
  80c02a:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  80c02d:	5d                   	pop    %ebp
  80c02e:	c3                   	ret    

0080c02f <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  80c02f:	55                   	push   %ebp
  80c030:	89 e5                	mov    %esp,%ebp
  80c032:	53                   	push   %ebx
  80c033:	83 ec 14             	sub    $0x14,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  80c036:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c03d:	e8 e2 b6 ff ff       	call   807724 <memp_malloc>
  80c042:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  80c044:	85 c0                	test   %eax,%eax
  80c046:	74 1c                	je     80c064 <udp_new+0x35>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  80c048:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80c04f:	00 
  80c050:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c057:	00 
  80c058:	89 04 24             	mov    %eax,(%esp)
  80c05b:	e8 f6 54 ff ff       	call   801556 <memset>
    pcb->ttl = UDP_TTL;
  80c060:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  }
  return pcb;
}
  80c064:	89 d8                	mov    %ebx,%eax
  80c066:	83 c4 14             	add    $0x14,%esp
  80c069:	5b                   	pop    %ebx
  80c06a:	5d                   	pop    %ebp
  80c06b:	c3                   	ret    

0080c06c <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  80c06c:	55                   	push   %ebp
  80c06d:	89 e5                	mov    %esp,%ebp
  80c06f:	83 ec 18             	sub    $0x18,%esp
  80c072:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  80c075:	8b 15 24 f0 b3 00    	mov    0xb3f024,%edx
  80c07b:	39 ca                	cmp    %ecx,%edx
  80c07d:	74 06                	je     80c085 <udp_remove+0x19>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80c07f:	85 d2                	test   %edx,%edx
  80c081:	75 0e                	jne    80c091 <udp_remove+0x25>
  80c083:	eb 21                	jmp    80c0a6 <udp_remove+0x3a>

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  80c085:	8b 42 0c             	mov    0xc(%edx),%eax
  80c088:	a3 24 f0 b3 00       	mov    %eax,0xb3f024
  80c08d:	eb 17                	jmp    80c0a6 <udp_remove+0x3a>
  80c08f:	89 c2                	mov    %eax,%edx
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80c091:	8b 42 0c             	mov    0xc(%edx),%eax
  80c094:	85 c0                	test   %eax,%eax
  80c096:	74 0e                	je     80c0a6 <udp_remove+0x3a>
  80c098:	39 c1                	cmp    %eax,%ecx
  80c09a:	75 f3                	jne    80c08f <udp_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80c09c:	8b 41 0c             	mov    0xc(%ecx),%eax
  80c09f:	89 42 0c             	mov    %eax,0xc(%edx)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80c0a2:	85 c0                	test   %eax,%eax
  80c0a4:	75 e9                	jne    80c08f <udp_remove+0x23>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  80c0a6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80c0aa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c0b1:	e8 2a b6 ff ff       	call   8076e0 <memp_free>
}
  80c0b6:	c9                   	leave  
  80c0b7:	c3                   	ret    

0080c0b8 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80c0b8:	55                   	push   %ebp
  80c0b9:	89 e5                	mov    %esp,%ebp
  80c0bb:	57                   	push   %edi
  80c0bc:	56                   	push   %esi
  80c0bd:	53                   	push   %ebx
  80c0be:	83 ec 1c             	sub    $0x1c,%esp
  80c0c1:	8b 55 08             	mov    0x8(%ebp),%edx
  80c0c4:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80c0c7:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c0cb:	a1 24 f0 b3 00       	mov    0xb3f024,%eax
  80c0d0:	b9 00 00 00 00       	mov    $0x0,%ecx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80c0d5:	bb 01 00 00 00       	mov    $0x1,%ebx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c0da:	85 c0                	test   %eax,%eax
  80c0dc:	74 2d                	je     80c10b <udp_bind+0x53>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  80c0de:	39 c2                	cmp    %eax,%edx
  80c0e0:	75 22                	jne    80c104 <udp_bind+0x4c>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80c0e2:	84 c9                	test   %cl,%cl
  80c0e4:	74 1c                	je     80c102 <udp_bind+0x4a>
  80c0e6:	c7 44 24 08 c0 3e 81 	movl   $0x813ec0,0x8(%esp)
  80c0ed:	00 
  80c0ee:	c7 44 24 04 41 02 00 	movl   $0x241,0x4(%esp)
  80c0f5:	00 
  80c0f6:	c7 04 24 cc 3e 81 00 	movl   $0x813ecc,(%esp)
  80c0fd:	e8 e6 48 ff ff       	call   8009e8 <_panic>
  80c102:	89 d9                	mov    %ebx,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c104:	8b 40 0c             	mov    0xc(%eax),%eax
  80c107:	85 c0                	test   %eax,%eax
  80c109:	75 d3                	jne    80c0de <udp_bind+0x26>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  80c10b:	b8 00 00 00 00       	mov    $0x0,%eax
  80c110:	85 ff                	test   %edi,%edi
  80c112:	74 02                	je     80c116 <udp_bind+0x5e>
  80c114:	8b 07                	mov    (%edi),%eax
  80c116:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  80c118:	66 85 f6             	test   %si,%si
  80c11b:	75 39                	jne    80c156 <udp_bind+0x9e>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  80c11d:	8b 3d 24 f0 b3 00    	mov    0xb3f024,%edi
  80c123:	89 f8                	mov    %edi,%eax
  80c125:	be 00 10 00 00       	mov    $0x1000,%esi
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80c12a:	eb 13                	jmp    80c13f <udp_bind+0x87>
      if (ipcb->local_port == port) {
  80c12c:	0f b7 58 12          	movzwl 0x12(%eax),%ebx
  80c130:	66 39 f3             	cmp    %si,%bx
  80c133:	75 07                	jne    80c13c <udp_bind+0x84>
        /* port is already used by another udp_pcb */
        port++;
  80c135:	8d 73 01             	lea    0x1(%ebx),%esi
  80c138:	89 f8                	mov    %edi,%eax
  80c13a:	eb 03                	jmp    80c13f <udp_bind+0x87>
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  80c13c:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80c13f:	85 c0                	test   %eax,%eax
  80c141:	0f 95 c3             	setne  %bl
  80c144:	74 07                	je     80c14d <udp_bind+0x95>
  80c146:	66 81 fe ff 7f       	cmp    $0x7fff,%si
  80c14b:	75 df                	jne    80c12c <udp_bind+0x74>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  80c14d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80c152:	84 db                	test   %bl,%bl
  80c154:	75 20                	jne    80c176 <udp_bind+0xbe>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  80c156:	66 89 72 12          	mov    %si,0x12(%edx)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  80c15a:	b8 00 00 00 00       	mov    $0x0,%eax
  80c15f:	84 c9                	test   %cl,%cl
  80c161:	75 13                	jne    80c176 <udp_bind+0xbe>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  80c163:	a1 24 f0 b3 00       	mov    0xb3f024,%eax
  80c168:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  80c16b:	89 15 24 f0 b3 00    	mov    %edx,0xb3f024
  80c171:	b8 00 00 00 00       	mov    $0x0,%eax
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  80c176:	83 c4 1c             	add    $0x1c,%esp
  80c179:	5b                   	pop    %ebx
  80c17a:	5e                   	pop    %esi
  80c17b:	5f                   	pop    %edi
  80c17c:	5d                   	pop    %ebp
  80c17d:	c3                   	ret    

0080c17e <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80c17e:	55                   	push   %ebp
  80c17f:	89 e5                	mov    %esp,%ebp
  80c181:	57                   	push   %edi
  80c182:	56                   	push   %esi
  80c183:	53                   	push   %ebx
  80c184:	83 ec 1c             	sub    $0x1c,%esp
  80c187:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c18a:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80c18d:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  80c191:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80c196:	75 18                	jne    80c1b0 <udp_connect+0x32>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80c198:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c19f:	00 
  80c1a0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c1a4:	89 1c 24             	mov    %ebx,(%esp)
  80c1a7:	e8 0c ff ff ff       	call   80c0b8 <udp_bind>
    if (err != ERR_OK)
  80c1ac:	84 c0                	test   %al,%al
  80c1ae:	75 48                	jne    80c1f8 <udp_connect+0x7a>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  80c1b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80c1b5:	85 ff                	test   %edi,%edi
  80c1b7:	74 02                	je     80c1bb <udp_connect+0x3d>
  80c1b9:	8b 07                	mov    (%edi),%eax
  80c1bb:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  80c1be:	66 89 73 14          	mov    %si,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  80c1c2:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c1c6:	8b 15 24 f0 b3 00    	mov    0xb3f024,%edx
  80c1cc:	85 d2                	test   %edx,%edx
  80c1ce:	74 13                	je     80c1e3 <udp_connect+0x65>
    if (pcb == ipcb) {
  80c1d0:	89 d0                	mov    %edx,%eax
  80c1d2:	39 d3                	cmp    %edx,%ebx
  80c1d4:	75 06                	jne    80c1dc <udp_connect+0x5e>
  80c1d6:	eb 1b                	jmp    80c1f3 <udp_connect+0x75>
  80c1d8:	39 c3                	cmp    %eax,%ebx
  80c1da:	74 17                	je     80c1f3 <udp_connect+0x75>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c1dc:	8b 40 0c             	mov    0xc(%eax),%eax
  80c1df:	85 c0                	test   %eax,%eax
  80c1e1:	75 f5                	jne    80c1d8 <udp_connect+0x5a>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  80c1e3:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  80c1e6:	89 1d 24 f0 b3 00    	mov    %ebx,0xb3f024
  80c1ec:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
  80c1f1:	eb 05                	jmp    80c1f8 <udp_connect+0x7a>
  80c1f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c1f8:	83 c4 1c             	add    $0x1c,%esp
  80c1fb:	5b                   	pop    %ebx
  80c1fc:	5e                   	pop    %esi
  80c1fd:	5f                   	pop    %edi
  80c1fe:	5d                   	pop    %ebp
  80c1ff:	c3                   	ret    

0080c200 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  80c200:	55                   	push   %ebp
  80c201:	89 e5                	mov    %esp,%ebp
  80c203:	57                   	push   %edi
  80c204:	56                   	push   %esi
  80c205:	53                   	push   %ebx
  80c206:	83 ec 3c             	sub    $0x3c,%esp
  80c209:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c20c:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  80c210:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  80c214:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80c219:	75 1e                	jne    80c239 <udp_sendto_if+0x39>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80c21b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c222:	00 
  80c223:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c227:	89 1c 24             	mov    %ebx,(%esp)
  80c22a:	e8 89 fe ff ff       	call   80c0b8 <udp_bind>
  80c22f:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  80c231:	84 c0                	test   %al,%al
  80c233:	0f 85 6a 01 00 00    	jne    80c3a3 <udp_sendto_if+0x1a3>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  80c239:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80c240:	00 
  80c241:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c244:	89 14 24             	mov    %edx,(%esp)
  80c247:	e8 b7 b8 ff ff       	call   807b03 <pbuf_header>
  80c24c:	84 c0                	test   %al,%al
  80c24e:	75 05                	jne    80c255 <udp_sendto_if+0x55>
  80c250:	8b 75 0c             	mov    0xc(%ebp),%esi
  80c253:	eb 3a                	jmp    80c28f <udp_sendto_if+0x8f>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  80c255:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c25c:	00 
  80c25d:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80c264:	00 
  80c265:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c26c:	e8 c2 be ff ff       	call   808133 <pbuf_alloc>
  80c271:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80c273:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80c278:	85 c0                	test   %eax,%eax
  80c27a:	0f 84 23 01 00 00    	je     80c3a3 <udp_sendto_if+0x1a3>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80c280:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c283:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c287:	89 34 24             	mov    %esi,(%esp)
  80c28a:	e8 4d b8 ff ff       	call   807adc <pbuf_chain>
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  80c28f:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  80c294:	77 1c                	ja     80c2b2 <udp_sendto_if+0xb2>
  80c296:	c7 44 24 08 f4 3e 81 	movl   $0x813ef4,0x8(%esp)
  80c29d:	00 
  80c29e:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80c2a5:	00 
  80c2a6:	c7 04 24 cc 3e 81 00 	movl   $0x813ecc,(%esp)
  80c2ad:	e8 36 47 ff ff       	call   8009e8 <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  80c2b2:	8b 7e 04             	mov    0x4(%esi),%edi
  udphdr->src = htons(pcb->local_port);
  80c2b5:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  80c2b9:	89 04 24             	mov    %eax,(%esp)
  80c2bc:	e8 b3 e9 ff ff       	call   80ac74 <htons>
  80c2c1:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  80c2c4:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80c2c8:	89 04 24             	mov    %eax,(%esp)
  80c2cb:	e8 a4 e9 ff ff       	call   80ac74 <htons>
  80c2d0:	66 89 47 02          	mov    %ax,0x2(%edi)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  80c2d4:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  80c2da:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80c2dd:	85 db                	test   %ebx,%ebx
  80c2df:	74 06                	je     80c2e7 <udp_sendto_if+0xe7>
  80c2e1:	8b 03                	mov    (%ebx),%eax
  80c2e3:	85 c0                	test   %eax,%eax
  80c2e5:	75 0b                	jne    80c2f2 <udp_sendto_if+0xf2>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80c2e7:	8b 55 18             	mov    0x18(%ebp),%edx
  80c2ea:	83 c2 04             	add    $0x4,%edx
  80c2ed:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  udphdr->dest = htons(dst_port);
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  80c2f0:	eb 23                	jmp    80c315 <udp_sendto_if+0x115>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80c2f2:	8b 55 18             	mov    0x18(%ebp),%edx
  80c2f5:	3b 42 04             	cmp    0x4(%edx),%eax
  80c2f8:	74 1b                	je     80c315 <udp_sendto_if+0x115>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  80c2fa:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
  80c2ff:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80c302:	0f 84 9b 00 00 00    	je     80c3a3 <udp_sendto_if+0x1a3>
        /* free the header pbuf */
        pbuf_free(q);
  80c308:	89 34 24             	mov    %esi,(%esp)
  80c30b:	e8 68 bb ff ff       	call   807e78 <pbuf_free>
  80c310:	e9 8e 00 00 00       	jmp    80c3a3 <udp_sendto_if+0x1a3>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  80c315:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c319:	89 04 24             	mov    %eax,(%esp)
  80c31c:	e8 53 e9 ff ff       	call   80ac74 <htons>
  80c321:	66 89 47 04          	mov    %ax,0x4(%edi)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  80c325:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  80c329:	75 34                	jne    80c35f <udp_sendto_if+0x15f>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  80c32b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c32f:	89 44 24 10          	mov    %eax,0x10(%esp)
  80c333:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80c33a:	00 
  80c33b:	8b 45 10             	mov    0x10(%ebp),%eax
  80c33e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c342:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c345:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c349:	89 34 24             	mov    %esi,(%esp)
  80c34c:	e8 1f e6 ff ff       	call   80a970 <inet_chksum_pseudo>
  80c351:	89 c2                	mov    %eax,%edx
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  80c353:	66 83 f8 01          	cmp    $0x1,%ax
  80c357:	19 c0                	sbb    %eax,%eax
  80c359:	09 d0                	or     %edx,%eax
  80c35b:	66 89 47 06          	mov    %ax,0x6(%edi)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  80c35f:	8b 45 18             	mov    0x18(%ebp),%eax
  80c362:	89 44 24 18          	mov    %eax,0x18(%esp)
  80c366:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  80c36d:	00 
  80c36e:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80c372:	89 44 24 10          	mov    %eax,0x10(%esp)
  80c376:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80c37a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80c37e:	8b 55 10             	mov    0x10(%ebp),%edx
  80c381:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c385:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c388:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c38c:	89 34 24             	mov    %esi,(%esp)
  80c38f:	e8 1c d5 ff ff       	call   8098b0 <ip_output_if>
  80c394:	89 c7                	mov    %eax,%edi
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  80c396:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80c399:	74 08                	je     80c3a3 <udp_sendto_if+0x1a3>
    /* free the header pbuf */
    pbuf_free(q);
  80c39b:	89 34 24             	mov    %esi,(%esp)
  80c39e:	e8 d5 ba ff ff       	call   807e78 <pbuf_free>
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  80c3a3:	89 f8                	mov    %edi,%eax
  80c3a5:	83 c4 3c             	add    $0x3c,%esp
  80c3a8:	5b                   	pop    %ebx
  80c3a9:	5e                   	pop    %esi
  80c3aa:	5f                   	pop    %edi
  80c3ab:	5d                   	pop    %ebp
  80c3ac:	c3                   	ret    

0080c3ad <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  80c3ad:	55                   	push   %ebp
  80c3ae:	89 e5                	mov    %esp,%ebp
  80c3b0:	83 ec 28             	sub    $0x28,%esp
  80c3b3:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80c3b6:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80c3b9:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80c3bc:	0f b7 75 14          	movzwl 0x14(%ebp),%esi

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  80c3c0:	89 1c 24             	mov    %ebx,(%esp)
  80c3c3:	e8 99 d6 ff ff       	call   809a61 <ip_route>
  80c3c8:	89 c2                	mov    %eax,%edx
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  80c3ca:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80c3cf:	85 d2                	test   %edx,%edx
  80c3d1:	74 21                	je     80c3f4 <udp_sendto+0x47>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  80c3d3:	89 54 24 10          	mov    %edx,0x10(%esp)
  80c3d7:	0f b7 f6             	movzwl %si,%esi
  80c3da:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80c3de:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80c3e2:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c3e5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c3e9:	8b 45 08             	mov    0x8(%ebp),%eax
  80c3ec:	89 04 24             	mov    %eax,(%esp)
  80c3ef:	e8 0c fe ff ff       	call   80c200 <udp_sendto_if>
}
  80c3f4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80c3f7:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80c3fa:	89 ec                	mov    %ebp,%esp
  80c3fc:	5d                   	pop    %ebp
  80c3fd:	c3                   	ret    

0080c3fe <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  80c3fe:	55                   	push   %ebp
  80c3ff:	89 e5                	mov    %esp,%ebp
  80c401:	83 ec 18             	sub    $0x18,%esp
  80c404:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  80c407:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  80c40b:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80c40f:	8d 50 04             	lea    0x4(%eax),%edx
  80c412:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c416:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c419:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c41d:	89 04 24             	mov    %eax,(%esp)
  80c420:	e8 88 ff ff ff       	call   80c3ad <udp_sendto>
}
  80c425:	c9                   	leave  
  80c426:	c3                   	ret    

0080c427 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  80c427:	55                   	push   %ebp
  80c428:	89 e5                	mov    %esp,%ebp
  80c42a:	57                   	push   %edi
  80c42b:	56                   	push   %esi
  80c42c:	53                   	push   %ebx
  80c42d:	83 ec 4c             	sub    $0x4c,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  80c430:	8b 45 08             	mov    0x8(%ebp),%eax
  80c433:	8b 40 04             	mov    0x4(%eax),%eax
  80c436:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  80c439:	8b 55 08             	mov    0x8(%ebp),%edx
  80c43c:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  80c440:	0f b7 00             	movzwl (%eax),%eax
  80c443:	89 04 24             	mov    %eax,(%esp)
  80c446:	e8 36 e8 ff ff       	call   80ac81 <ntohs>
  80c44b:	0f b6 c4             	movzbl %ah,%eax
  80c44e:	83 e0 0f             	and    $0xf,%eax
  80c451:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80c458:	39 c3                	cmp    %eax,%ebx
  80c45a:	7c 2b                	jl     80c487 <udp_input+0x60>
  80c45c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c45f:	0f b7 02             	movzwl (%edx),%eax
  80c462:	89 04 24             	mov    %eax,(%esp)
  80c465:	e8 17 e8 ff ff       	call   80ac81 <ntohs>
  80c46a:	66 c1 e8 06          	shr    $0x6,%ax
  80c46e:	83 e0 3c             	and    $0x3c,%eax
  80c471:	f7 d8                	neg    %eax
  80c473:	98                   	cwtl   
  80c474:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c478:	8b 45 08             	mov    0x8(%ebp),%eax
  80c47b:	89 04 24             	mov    %eax,(%esp)
  80c47e:	e8 80 b6 ff ff       	call   807b03 <pbuf_header>
  80c483:	84 c0                	test   %al,%al
  80c485:	74 10                	je     80c497 <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  80c487:	8b 55 08             	mov    0x8(%ebp),%edx
  80c48a:	89 14 24             	mov    %edx,(%esp)
  80c48d:	e8 e6 b9 ff ff       	call   807e78 <pbuf_free>
    goto end;
  80c492:	e9 f4 02 00 00       	jmp    80c78b <udp_input+0x364>
  }

  udphdr = (struct udp_hdr *)p->payload;
  80c497:	8b 45 08             	mov    0x8(%ebp),%eax
  80c49a:	8b 40 04             	mov    0x4(%eax),%eax
  80c49d:	89 45 d8             	mov    %eax,-0x28(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  80c4a0:	0f b7 00             	movzwl (%eax),%eax
  80c4a3:	89 04 24             	mov    %eax,(%esp)
  80c4a6:	e8 d6 e7 ff ff       	call   80ac81 <ntohs>
  80c4ab:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  dest = ntohs(udphdr->dest);
  80c4af:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80c4b2:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80c4b6:	89 04 24             	mov    %eax,(%esp)
  80c4b9:	e8 c3 e7 ff ff       	call   80ac81 <ntohs>
  80c4be:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  80c4c0:	66 83 f8 44          	cmp    $0x44,%ax
  80c4c4:	75 49                	jne    80c50f <udp_input+0xe8>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  80c4c6:	66 83 7d e2 43       	cmpw   $0x43,-0x1e(%ebp)
  80c4cb:	0f 85 fa 00 00 00    	jne    80c5cb <udp_input+0x1a4>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  80c4d1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c4d4:	8b 42 20             	mov    0x20(%edx),%eax
  80c4d7:	85 c0                	test   %eax,%eax
  80c4d9:	0f 84 ec 00 00 00    	je     80c5cb <udp_input+0x1a4>
  80c4df:	8b 58 08             	mov    0x8(%eax),%ebx
  80c4e2:	85 db                	test   %ebx,%ebx
  80c4e4:	0f 84 e6 00 00 00    	je     80c5d0 <udp_input+0x1a9>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  80c4ea:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80c4ed:	0f 84 ef 00 00 00    	je     80c5e2 <udp_input+0x1bb>
  80c4f3:	8b 43 04             	mov    0x4(%ebx),%eax
  80c4f6:	85 c0                	test   %eax,%eax
  80c4f8:	0f 84 e4 00 00 00    	je     80c5e2 <udp_input+0x1bb>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
  80c4fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c501:	3b 42 0c             	cmp    0xc(%edx),%eax
  80c504:	0f 85 c1 00 00 00    	jne    80c5cb <udp_input+0x1a4>
  80c50a:	e9 d3 00 00 00       	jmp    80c5e2 <udp_input+0x1bb>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80c50f:	8b 1d 24 f0 b3 00    	mov    0xb3f024,%ebx
  80c515:	85 db                	test   %ebx,%ebx
  80c517:	0f 84 62 02 00 00    	je     80c77f <udp_input+0x358>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80c51d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c520:	83 c0 10             	add    $0x10,%eax
  80c523:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80c526:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  80c52d:	bf 00 00 00 00       	mov    $0x0,%edi
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c532:	66 3b 73 12          	cmp    0x12(%ebx),%si
  80c536:	75 76                	jne    80c5ae <udp_input+0x187>
          (ip_addr_isany(&pcb->local_ip) ||
  80c538:	85 db                	test   %ebx,%ebx
  80c53a:	74 24                	je     80c560 <udp_input+0x139>
  80c53c:	8b 03                	mov    (%ebx),%eax
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c53e:	85 c0                	test   %eax,%eax
  80c540:	74 1e                	je     80c560 <udp_input+0x139>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  80c542:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c545:	3b 42 10             	cmp    0x10(%edx),%eax
  80c548:	74 16                	je     80c560 <udp_input+0x139>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80c54a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c54d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c551:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80c554:	89 14 24             	mov    %edx,(%esp)
  80c557:	e8 0c d3 ff ff       	call   809868 <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c55c:	84 c0                	test   %al,%al
  80c55e:	74 4e                	je     80c5ae <udp_input+0x187>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  80c560:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80c564:	0f 85 02 02 00 00    	jne    80c76c <udp_input+0x345>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
  80c56a:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
  80c56e:	66 90                	xchg   %ax,%ax
  80c570:	0f 84 f3 01 00 00    	je     80c769 <udp_input+0x342>
  80c576:	66 90                	xchg   %ax,%ax
  80c578:	e9 ef 01 00 00       	jmp    80c76c <udp_input+0x345>
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  80c57d:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80c580:	74 0f                	je     80c591 <udp_input+0x16a>
  80c582:	8b 43 04             	mov    0x4(%ebx),%eax
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  80c585:	85 c0                	test   %eax,%eax
  80c587:	74 08                	je     80c591 <udp_input+0x16a>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
  80c589:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c58c:	3b 42 0c             	cmp    0xc(%edx),%eax
  80c58f:	75 1d                	jne    80c5ae <udp_input+0x187>
  80c591:	89 d8                	mov    %ebx,%eax
        /* the first fully matching PCB */
        if (prev != NULL) {
  80c593:	85 ff                	test   %edi,%edi
  80c595:	74 27                	je     80c5be <udp_input+0x197>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  80c597:	8b 53 0c             	mov    0xc(%ebx),%edx
  80c59a:	89 57 0c             	mov    %edx,0xc(%edi)
          pcb->next = udp_pcbs;
  80c59d:	8b 15 24 f0 b3 00    	mov    0xb3f024,%edx
  80c5a3:	89 53 0c             	mov    %edx,0xc(%ebx)
          udp_pcbs = pcb;
  80c5a6:	89 1d 24 f0 b3 00    	mov    %ebx,0xb3f024
  80c5ac:	eb 10                	jmp    80c5be <udp_input+0x197>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80c5ae:	8b 43 0c             	mov    0xc(%ebx),%eax
  80c5b1:	85 c0                	test   %eax,%eax
  80c5b3:	74 0d                	je     80c5c2 <udp_input+0x19b>
  80c5b5:	89 df                	mov    %ebx,%edi
  80c5b7:	89 c3                	mov    %eax,%ebx
  80c5b9:	e9 74 ff ff ff       	jmp    80c532 <udp_input+0x10b>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  80c5be:	85 c0                	test   %eax,%eax
  80c5c0:	75 20                	jne    80c5e2 <udp_input+0x1bb>
  80c5c2:	8b 5d dc             	mov    -0x24(%ebp),%ebx
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  80c5c5:	85 db                	test   %ebx,%ebx
  80c5c7:	75 19                	jne    80c5e2 <udp_input+0x1bb>
  80c5c9:	eb 05                	jmp    80c5d0 <udp_input+0x1a9>
  80c5cb:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c5d0:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c5d3:	8b 42 04             	mov    0x4(%edx),%eax
  80c5d6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c5d9:	3b 42 10             	cmp    0x10(%edx),%eax
  80c5dc:	0f 85 7a 01 00 00    	jne    80c75c <udp_input+0x335>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  80c5e2:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80c5e5:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  80c5ea:	74 44                	je     80c630 <udp_input+0x209>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80c5ec:	8b 55 08             	mov    0x8(%ebp),%edx
  80c5ef:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80c5f3:	89 44 24 10          	mov    %eax,0x10(%esp)
  80c5f7:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80c5fe:	00 
  80c5ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c602:	83 c0 10             	add    $0x10,%eax
  80c605:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c609:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c60c:	83 c0 0c             	add    $0xc,%eax
  80c60f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c613:	89 14 24             	mov    %edx,(%esp)
  80c616:	e8 55 e3 ff ff       	call   80a970 <inet_chksum_pseudo>
  80c61b:	66 85 c0             	test   %ax,%ax
  80c61e:	74 10                	je     80c630 <udp_input+0x209>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  80c620:	8b 45 08             	mov    0x8(%ebp),%eax
  80c623:	89 04 24             	mov    %eax,(%esp)
  80c626:	e8 4d b8 ff ff       	call   807e78 <pbuf_free>
          goto end;
  80c62b:	e9 5b 01 00 00       	jmp    80c78b <udp_input+0x364>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  80c630:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  80c637:	ff 
  80c638:	8b 55 08             	mov    0x8(%ebp),%edx
  80c63b:	89 14 24             	mov    %edx,(%esp)
  80c63e:	e8 c0 b4 ff ff       	call   807b03 <pbuf_header>
  80c643:	84 c0                	test   %al,%al
  80c645:	74 1c                	je     80c663 <udp_input+0x23c>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80c647:	c7 44 24 08 ac 3e 81 	movl   $0x813eac,0x8(%esp)
  80c64e:	00 
  80c64f:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  80c656:	00 
  80c657:	c7 04 24 cc 3e 81 00 	movl   $0x813ecc,(%esp)
  80c65e:	e8 85 43 ff ff       	call   8009e8 <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  80c663:	85 db                	test   %ebx,%ebx
  80c665:	74 41                	je     80c6a8 <udp_input+0x281>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  80c667:	8b 43 18             	mov    0x18(%ebx),%eax
  80c66a:	85 c0                	test   %eax,%eax
  80c66c:	74 2a                	je     80c698 <udp_input+0x271>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  80c66e:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  80c672:	89 54 24 10          	mov    %edx,0x10(%esp)
  80c676:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c679:	83 c2 0c             	add    $0xc,%edx
  80c67c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80c680:	8b 55 08             	mov    0x8(%ebp),%edx
  80c683:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c687:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c68b:	8b 53 1c             	mov    0x1c(%ebx),%edx
  80c68e:	89 14 24             	mov    %edx,(%esp)
  80c691:	ff d0                	call   *%eax
  80c693:	e9 f3 00 00 00       	jmp    80c78b <udp_input+0x364>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  80c698:	8b 45 08             	mov    0x8(%ebp),%eax
  80c69b:	89 04 24             	mov    %eax,(%esp)
  80c69e:	e8 d5 b7 ff ff       	call   807e78 <pbuf_free>
        goto end;
  80c6a3:	e9 e3 00 00 00       	jmp    80c78b <udp_input+0x364>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80c6a8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c6ab:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c6af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c6b2:	83 c0 10             	add    $0x10,%eax
  80c6b5:	89 04 24             	mov    %eax,(%esp)
  80c6b8:	e8 ab d1 ff ff       	call   809868 <ip_addr_isbroadcast>
  80c6bd:	84 c0                	test   %al,%al
  80c6bf:	0f 85 8a 00 00 00    	jne    80c74f <udp_input+0x328>
          !ip_addr_ismulticast(&iphdr->dest)) {
  80c6c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c6c8:	8b 70 10             	mov    0x10(%eax),%esi
  80c6cb:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80c6d2:	e8 e3 e7 ff ff       	call   80aeba <ntohl>
  80c6d7:	89 c3                	mov    %eax,%ebx
  80c6d9:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80c6e0:	e8 d5 e7 ff ff       	call   80aeba <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80c6e5:	21 f3                	and    %esi,%ebx
  80c6e7:	39 c3                	cmp    %eax,%ebx
  80c6e9:	74 64                	je     80c74f <udp_input+0x328>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  80c6eb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c6ee:	0f b7 02             	movzwl (%edx),%eax
  80c6f1:	89 04 24             	mov    %eax,(%esp)
  80c6f4:	e8 88 e5 ff ff       	call   80ac81 <ntohs>
  80c6f9:	0f b6 c4             	movzbl %ah,%eax
  80c6fc:	83 e0 0f             	and    $0xf,%eax
  80c6ff:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80c706:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c70a:	8b 45 08             	mov    0x8(%ebp),%eax
  80c70d:	89 04 24             	mov    %eax,(%esp)
  80c710:	e8 ee b3 ff ff       	call   807b03 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  80c715:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c718:	8b 55 08             	mov    0x8(%ebp),%edx
  80c71b:	39 42 04             	cmp    %eax,0x4(%edx)
  80c71e:	74 1c                	je     80c73c <udp_input+0x315>
  80c720:	c7 44 24 08 e0 3e 81 	movl   $0x813ee0,0x8(%esp)
  80c727:	00 
  80c728:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  80c72f:	00 
  80c730:	c7 04 24 cc 3e 81 00 	movl   $0x813ecc,(%esp)
  80c737:	e8 ac 42 ff ff       	call   8009e8 <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  80c73c:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80c743:	00 
  80c744:	8b 55 08             	mov    0x8(%ebp),%edx
  80c747:	89 14 24             	mov    %edx,(%esp)
  80c74a:	e8 c3 55 00 00       	call   811d12 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  80c74f:	8b 45 08             	mov    0x8(%ebp),%eax
  80c752:	89 04 24             	mov    %eax,(%esp)
  80c755:	e8 1e b7 ff ff       	call   807e78 <pbuf_free>
  80c75a:	eb 2f                	jmp    80c78b <udp_input+0x364>
    }
  } else {
    pbuf_free(p);
  80c75c:	8b 55 08             	mov    0x8(%ebp),%edx
  80c75f:	89 14 24             	mov    %edx,(%esp)
  80c762:	e8 11 b7 ff ff       	call   807e78 <pbuf_free>
  80c767:	eb 22                	jmp    80c78b <udp_input+0x364>
  }
end:
  PERF_STOP("udp_input");
}
  80c769:	89 5d dc             	mov    %ebx,-0x24(%ebp)
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  80c76c:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  80c770:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  80c774:	0f 85 34 fe ff ff    	jne    80c5ae <udp_input+0x187>
  80c77a:	e9 fe fd ff ff       	jmp    80c57d <udp_input+0x156>
  80c77f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  80c786:	e9 37 fe ff ff       	jmp    80c5c2 <udp_input+0x19b>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  80c78b:	83 c4 4c             	add    $0x4c,%esp
  80c78e:	5b                   	pop    %ebx
  80c78f:	5e                   	pop    %esi
  80c790:	5f                   	pop    %edi
  80c791:	5d                   	pop    %ebp
  80c792:	c3                   	ret    
	...

0080c7a0 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  80c7a0:	55                   	push   %ebp
  80c7a1:	89 e5                	mov    %esp,%ebp
  80c7a3:	57                   	push   %edi
  80c7a4:	56                   	push   %esi
  80c7a5:	53                   	push   %ebx
  80c7a6:	83 ec 2c             	sub    $0x2c,%esp
  80c7a9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c7ac:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80c7af:	89 ce                	mov    %ecx,%esi
  80c7b1:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  80c7b4:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80c7b7:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80c7bb:	74 1c                	je     80c7d9 <etharp_send_ip+0x39>
  80c7bd:	c7 44 24 08 24 3f 81 	movl   $0x813f24,0x8(%esp)
  80c7c4:	00 
  80c7c5:	c7 44 24 04 b3 01 00 	movl   $0x1b3,0x4(%esp)
  80c7cc:	00 
  80c7cd:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80c7d4:	e8 0f 42 ff ff       	call   8009e8 <_panic>
  80c7d9:	ba 06 00 00 00       	mov    $0x6,%edx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  80c7de:	83 ea 01             	sub    $0x1,%edx
    ethhdr->dest.addr[k] = dst->addr[k];
  80c7e1:	0f b6 c2             	movzbl %dl,%eax
  80c7e4:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80c7e8:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  80c7eb:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c7ef:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  80c7f3:	84 d2                	test   %dl,%dl
  80c7f5:	75 e7                	jne    80c7de <etharp_send_ip+0x3e>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  80c7f7:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80c7fe:	e8 71 e4 ff ff       	call   80ac74 <htons>
  80c803:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  80c807:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80c80a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c80e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c811:	89 14 24             	mov    %edx,(%esp)
  80c814:	ff 52 18             	call   *0x18(%edx)
}
  80c817:	83 c4 2c             	add    $0x2c,%esp
  80c81a:	5b                   	pop    %ebx
  80c81b:	5e                   	pop    %esi
  80c81c:	5f                   	pop    %edi
  80c81d:	5d                   	pop    %ebp
  80c81e:	c3                   	ret    

0080c81f <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80c81f:	55                   	push   %ebp
  80c820:	89 e5                	mov    %esp,%ebp
  80c822:	57                   	push   %edi
  80c823:	56                   	push   %esi
  80c824:	53                   	push   %ebx
  80c825:	83 ec 3c             	sub    $0x3c,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  80c828:	8b 75 08             	mov    0x8(%ebp),%esi
  80c82b:	83 c6 25             	add    $0x25,%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  80c82e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c835:	00 
  80c836:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  80c83d:	00 
  80c83e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80c845:	e8 e9 b8 ff ff       	call   808133 <pbuf_alloc>
  80c84a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  80c84d:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80c852:	85 c0                	test   %eax,%eax
  80c854:	0f 84 02 01 00 00    	je     80c95c <etharp_request+0x13d>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80c85a:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  80c85f:	77 1c                	ja     80c87d <etharp_request+0x5e>
  80c861:	c7 44 24 08 68 3f 81 	movl   $0x813f68,0x8(%esp)
  80c868:	00 
  80c869:	c7 44 24 04 1c 04 00 	movl   $0x41c,0x4(%esp)
  80c870:	00 
  80c871:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80c878:	e8 6b 41 ff ff       	call   8009e8 <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  80c87d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c880:	8b 5a 04             	mov    0x4(%edx),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  80c883:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c88a:	e8 e5 e3 ff ff       	call   80ac74 <htons>
  80c88f:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80c893:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80c896:	80 79 24 06          	cmpb   $0x6,0x24(%ecx)
  80c89a:	74 1c                	je     80c8b8 <etharp_request+0x99>
  80c89c:	c7 44 24 08 24 3f 81 	movl   $0x813f24,0x8(%esp)
  80c8a3:	00 
  80c8a4:	c7 44 24 04 23 04 00 	movl   $0x423,0x4(%esp)
  80c8ab:	00 
  80c8ac:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80c8b3:	e8 30 41 ff ff       	call   8009e8 <_panic>
  80c8b8:	ba 06 00 00 00       	mov    $0x6,%edx
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80c8bd:	bf 89 40 81 00       	mov    $0x814089,%edi
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  80c8c2:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  80c8c5:	0f b6 c2             	movzbl %dl,%eax
  80c8c8:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c8cc:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80c8d0:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80c8d4:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  80c8d8:	0f b6 88 83 40 81 00 	movzbl 0x814083(%eax),%ecx
  80c8df:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  80c8e2:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c8e6:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  80c8ea:	84 d2                	test   %dl,%dl
  80c8ec:	75 d4                	jne    80c8c2 <etharp_request+0xa3>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  80c8ee:	8b 55 08             	mov    0x8(%ebp),%edx
  80c8f1:	8b 42 04             	mov    0x4(%edx),%eax
  80c8f4:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  80c8f7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c8fa:	8b 00                	mov    (%eax),%eax
  80c8fc:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  80c8ff:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c906:	e8 69 e3 ff ff       	call   80ac74 <htons>
  80c90b:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  80c90f:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80c916:	e8 59 e3 ff ff       	call   80ac74 <htons>
  80c91b:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80c91f:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80c926:	e8 49 e3 ff ff       	call   80ac74 <htons>
  80c92b:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80c92f:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80c936:	e8 39 e3 ff ff       	call   80ac74 <htons>
  80c93b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  80c93f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80c942:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80c946:	8b 45 08             	mov    0x8(%ebp),%eax
  80c949:	89 04 24             	mov    %eax,(%esp)
  80c94c:	ff 50 18             	call   *0x18(%eax)
  80c94f:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  80c951:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80c954:	89 0c 24             	mov    %ecx,(%esp)
  80c957:	e8 1c b5 ff ff       	call   807e78 <pbuf_free>
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80c95c:	89 d8                	mov    %ebx,%eax
  80c95e:	83 c4 3c             	add    $0x3c,%esp
  80c961:	5b                   	pop    %ebx
  80c962:	5e                   	pop    %esi
  80c963:	5f                   	pop    %edi
  80c964:	5d                   	pop    %ebp
  80c965:	c3                   	ret    

0080c966 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  80c966:	55                   	push   %ebp
  80c967:	89 e5                	mov    %esp,%ebp
  80c969:	56                   	push   %esi
  80c96a:	53                   	push   %ebx
  80c96b:	83 ec 10             	sub    $0x10,%esp
  80c96e:	89 c6                	mov    %eax,%esi
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  80c970:	85 c0                	test   %eax,%eax
  80c972:	75 1c                	jne    80c990 <free_etharp_q+0x2a>
  80c974:	c7 44 24 08 d7 37 81 	movl   $0x8137d7,0x8(%esp)
  80c97b:	00 
  80c97c:	c7 44 24 04 93 00 00 	movl   $0x93,0x4(%esp)
  80c983:	00 
  80c984:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80c98b:	e8 58 40 ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80c990:	8b 40 04             	mov    0x4(%eax),%eax
  80c993:	85 c0                	test   %eax,%eax
  80c995:	74 04                	je     80c99b <free_etharp_q+0x35>
  while (q) {
    r = q;
    q = q->next;
  80c997:	8b 1e                	mov    (%esi),%ebx
  80c999:	eb 45                	jmp    80c9e0 <free_etharp_q+0x7a>
static void
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80c99b:	c7 44 24 08 25 40 81 	movl   $0x814025,0x8(%esp)
  80c9a2:	00 
  80c9a3:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
  80c9aa:	00 
  80c9ab:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80c9b2:	e8 31 40 ff ff       	call   8009e8 <_panic>
  while (q) {
    r = q;
    q = q->next;
  80c9b7:	8b 13                	mov    (%ebx),%edx
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  80c9b9:	8b 43 04             	mov    0x4(%ebx),%eax
  80c9bc:	85 c0                	test   %eax,%eax
  80c9be:	75 1c                	jne    80c9dc <free_etharp_q+0x76>
  80c9c0:	c7 44 24 08 32 40 81 	movl   $0x814032,0x8(%esp)
  80c9c7:	00 
  80c9c8:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80c9cf:	00 
  80c9d0:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80c9d7:	e8 0c 40 ff ff       	call   8009e8 <_panic>
  80c9dc:	89 de                	mov    %ebx,%esi
  80c9de:	89 d3                	mov    %edx,%ebx
    pbuf_free(r->p);
  80c9e0:	89 04 24             	mov    %eax,(%esp)
  80c9e3:	e8 90 b4 ff ff       	call   807e78 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  80c9e8:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c9ec:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80c9f3:	e8 e8 ac ff ff       	call   8076e0 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  80c9f8:	85 db                	test   %ebx,%ebx
  80c9fa:	75 bb                	jne    80c9b7 <free_etharp_q+0x51>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  80c9fc:	83 c4 10             	add    $0x10,%esp
  80c9ff:	5b                   	pop    %ebx
  80ca00:	5e                   	pop    %esi
  80ca01:	5d                   	pop    %ebp
  80ca02:	c3                   	ret    

0080ca03 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  80ca03:	55                   	push   %ebp
  80ca04:	89 e5                	mov    %esp,%ebp
  80ca06:	57                   	push   %edi
  80ca07:	56                   	push   %esi
  80ca08:	53                   	push   %ebx
  80ca09:	83 ec 3c             	sub    $0x3c,%esp
  80ca0c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ca0f:	88 55 dd             	mov    %dl,-0x23(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  80ca12:	85 c0                	test   %eax,%eax
  80ca14:	74 16                	je     80ca2c <find_entry+0x29>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  80ca16:	0f b6 05 78 5b b3 00 	movzbl 0xb35b78,%eax
  80ca1d:	0f b6 d0             	movzbl %al,%edx
  80ca20:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80ca23:	83 b9 70 5a b3 00 02 	cmpl   $0x2,0xb35a70(%ecx)
  80ca2a:	74 2a                	je     80ca56 <find_entry+0x53>
  80ca2c:	ba 74 5a b3 00       	mov    $0xb35a74,%edx
  80ca31:	be 00 00 00 00       	mov    $0x0,%esi
  80ca36:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  80ca3a:	bf 00 00 00 00       	mov    $0x0,%edi
  80ca3f:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80ca43:	b8 00 00 00 00       	mov    $0x0,%eax
  80ca48:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80ca4c:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  80ca50:	c6 45 dc 0a          	movb   $0xa,-0x24(%ebp)
  80ca54:	eb 22                	jmp    80ca78 <find_entry+0x75>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  80ca56:	6b d2 1c             	imul   $0x1c,%edx,%edx
  80ca59:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80ca5c:	8b 0b                	mov    (%ebx),%ecx
  80ca5e:	3b 8a 64 5a b3 00    	cmp    0xb35a64(%edx),%ecx
  80ca64:	75 c6                	jne    80ca2c <find_entry+0x29>
  80ca66:	e9 c4 01 00 00       	jmp    80cc2f <find_entry+0x22c>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  80ca6b:	89 ce                	mov    %ecx,%esi
  80ca6d:	0f b6 7d d7          	movzbl -0x29(%ebp),%edi
  80ca71:	0f b6 4d e6          	movzbl -0x1a(%ebp),%ecx
  80ca75:	88 4d e7             	mov    %cl,-0x19(%ebp)
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80ca78:	80 7d e5 0a          	cmpb   $0xa,-0x1b(%ebp)
  80ca7c:	75 1c                	jne    80ca9a <find_entry+0x97>
  80ca7e:	83 7a fc 00          	cmpl   $0x0,-0x4(%edx)
  80ca82:	75 16                	jne    80ca9a <find_entry+0x97>
  80ca84:	88 45 e5             	mov    %al,-0x1b(%ebp)
  80ca87:	89 f1                	mov    %esi,%ecx
  80ca89:	89 fb                	mov    %edi,%ebx
  80ca8b:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80ca8e:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80ca92:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80ca95:	e9 a0 00 00 00       	jmp    80cb3a <find_entry+0x137>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80ca9a:	8b 4a fc             	mov    -0x4(%edx),%ecx
  80ca9d:	83 f9 01             	cmp    $0x1,%ecx
  80caa0:	75 51                	jne    80caf3 <find_entry+0xf0>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80caa2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80caa6:	74 14                	je     80cabc <find_entry+0xb9>
  80caa8:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80caab:	8b 0b                	mov    (%ebx),%ecx
  80caad:	3b 4a f0             	cmp    -0x10(%edx),%ecx
  80cab0:	75 0a                	jne    80cabc <find_entry+0xb9>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80cab2:	a2 78 5b b3 00       	mov    %al,0xb35b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80cab7:	e9 73 01 00 00       	jmp    80cc2f <find_entry+0x22c>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  80cabc:	83 7a ec 00          	cmpl   $0x0,-0x14(%edx)
  80cac0:	74 1a                	je     80cadc <find_entry+0xd9>
        if (arp_table[i].ctime >= age_queue) {
  80cac2:	0f b6 0a             	movzbl (%edx),%ecx
  80cac5:	89 f3                	mov    %esi,%ebx
  80cac7:	38 cb                	cmp    %cl,%bl
  80cac9:	77 61                	ja     80cb2c <find_entry+0x129>
  80cacb:	88 45 df             	mov    %al,-0x21(%ebp)
  80cace:	89 fb                	mov    %edi,%ebx
  80cad0:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80cad3:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80cad7:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80cada:	eb 5e                	jmp    80cb3a <find_entry+0x137>
          age_queue = arp_table[i].ctime;
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  80cadc:	0f b6 0a             	movzbl (%edx),%ecx
  80cadf:	88 4d e6             	mov    %cl,-0x1a(%ebp)
  80cae2:	38 4d e7             	cmp    %cl,-0x19(%ebp)
  80cae5:	77 45                	ja     80cb2c <find_entry+0x129>
  80cae7:	88 45 dc             	mov    %al,-0x24(%ebp)
  80caea:	89 f1                	mov    %esi,%ecx
  80caec:	89 fb                	mov    %edi,%ebx
  80caee:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80caf1:	eb 47                	jmp    80cb3a <find_entry+0x137>
          age_pending = arp_table[i].ctime;
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80caf3:	83 f9 02             	cmp    $0x2,%ecx
  80caf6:	75 34                	jne    80cb2c <find_entry+0x129>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80caf8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80cafc:	74 14                	je     80cb12 <find_entry+0x10f>
  80cafe:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80cb01:	8b 0b                	mov    (%ebx),%ecx
  80cb03:	3b 4a f0             	cmp    -0x10(%edx),%ecx
  80cb06:	75 0a                	jne    80cb12 <find_entry+0x10f>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80cb08:	a2 78 5b b3 00       	mov    %al,0xb35b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80cb0d:	e9 1d 01 00 00       	jmp    80cc2f <find_entry+0x22c>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  80cb12:	0f b6 0a             	movzbl (%edx),%ecx
  80cb15:	88 4d d7             	mov    %cl,-0x29(%ebp)
  80cb18:	89 fb                	mov    %edi,%ebx
  80cb1a:	38 cb                	cmp    %cl,%bl
  80cb1c:	77 0e                	ja     80cb2c <find_entry+0x129>
  80cb1e:	88 45 de             	mov    %al,-0x22(%ebp)
  80cb21:	89 f1                	mov    %esi,%ecx
  80cb23:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80cb27:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80cb2a:	eb 0e                	jmp    80cb3a <find_entry+0x137>
  80cb2c:	89 f1                	mov    %esi,%ecx
  80cb2e:	89 fb                	mov    %edi,%ebx
  80cb30:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80cb33:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80cb37:	88 5d e6             	mov    %bl,-0x1a(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80cb3a:	83 c0 01             	add    $0x1,%eax
  80cb3d:	83 c2 1c             	add    $0x1c,%edx
  80cb40:	3c 0a                	cmp    $0xa,%al
  80cb42:	0f 85 23 ff ff ff    	jne    80ca6b <find_entry+0x68>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  80cb48:	80 7d e5 0a          	cmpb   $0xa,-0x1b(%ebp)
  80cb4c:	75 0a                	jne    80cb58 <find_entry+0x155>
  80cb4e:	f6 45 dd 01          	testb  $0x1,-0x23(%ebp)
  80cb52:	0f 84 d2 00 00 00    	je     80cc2a <find_entry+0x227>
  80cb58:	f6 45 dd 02          	testb  $0x2,-0x23(%ebp)
  80cb5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80cb60:	0f 85 c4 00 00 00    	jne    80cc2a <find_entry+0x227>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  80cb66:	0f b6 5d e5          	movzbl -0x1b(%ebp),%ebx
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  80cb6a:	80 fb 09             	cmp    $0x9,%bl
  80cb6d:	8d 76 00             	lea    0x0(%esi),%esi
  80cb70:	7e 62                	jle    80cbd4 <find_entry+0x1d1>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  80cb72:	80 7d de 09          	cmpb   $0x9,-0x22(%ebp)
  80cb76:	7f 2f                	jg     80cba7 <find_entry+0x1a4>
    /* recycle oldest stable*/
    i = old_stable;
  80cb78:	0f b6 5d de          	movzbl -0x22(%ebp),%ebx
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  80cb7c:	0f b6 c3             	movzbl %bl,%eax
  80cb7f:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80cb82:	83 b8 60 5a b3 00 00 	cmpl   $0x0,0xb35a60(%eax)
  80cb89:	74 49                	je     80cbd4 <find_entry+0x1d1>
  80cb8b:	c7 44 24 08 3f 40 81 	movl   $0x81403f,0x8(%esp)
  80cb92:	00 
  80cb93:	c7 44 24 04 75 01 00 	movl   $0x175,0x4(%esp)
  80cb9a:	00 
  80cb9b:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80cba2:	e8 41 3e ff ff       	call   8009e8 <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
    /* recycle oldest pending */
    i = old_pending;
  80cba7:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  80cbab:	80 fb 09             	cmp    $0x9,%bl
  80cbae:	7e 24                	jle    80cbd4 <find_entry+0x1d1>
    /* recycle oldest pending */
    i = old_pending;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  80cbb0:	80 7d df 09          	cmpb   $0x9,-0x21(%ebp)
  80cbb4:	7f 74                	jg     80cc2a <find_entry+0x227>
    /* recycle oldest pending */
    i = old_queue;
  80cbb6:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  80cbba:	0f b6 f3             	movzbl %bl,%esi
  80cbbd:	bf 60 5a b3 00       	mov    $0xb35a60,%edi
  80cbc2:	6b f6 1c             	imul   $0x1c,%esi,%esi
  80cbc5:	8b 04 3e             	mov    (%esi,%edi,1),%eax
  80cbc8:	e8 99 fd ff ff       	call   80c966 <free_etharp_q>
    arp_table[i].q = NULL;
  80cbcd:	c7 04 3e 00 00 00 00 	movl   $0x0,(%esi,%edi,1)
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  80cbd4:	80 fb 09             	cmp    $0x9,%bl
  80cbd7:	76 1c                	jbe    80cbf5 <find_entry+0x1f2>
  80cbd9:	c7 44 24 08 56 40 81 	movl   $0x814056,0x8(%esp)
  80cbe0:	00 
  80cbe1:	c7 44 24 04 8b 01 00 	movl   $0x18b,0x4(%esp)
  80cbe8:	00 
  80cbe9:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80cbf0:	e8 f3 3d ff ff       	call   8009e8 <_panic>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  80cbf5:	0f b6 c3             	movzbl %bl,%eax
  80cbf8:	6b d0 1c             	imul   $0x1c,%eax,%edx
  80cbfb:	c7 82 70 5a b3 00 00 	movl   $0x0,0xb35a70(%edx)
  80cc02:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  80cc05:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80cc09:	74 0b                	je     80cc16 <find_entry+0x213>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  80cc0b:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80cc0e:	8b 0e                	mov    (%esi),%ecx
  80cc10:	89 8a 64 5a b3 00    	mov    %ecx,0xb35a64(%edx)
  }
  arp_table[i].ctime = 0;
  80cc16:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80cc19:	c6 80 74 5a b3 00 00 	movb   $0x0,0xb35a74(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  80cc20:	88 1d 78 5b b3 00    	mov    %bl,0xb35b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  80cc26:	89 d8                	mov    %ebx,%eax
  80cc28:	eb 05                	jmp    80cc2f <find_entry+0x22c>
  80cc2a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80cc2f:	83 c4 3c             	add    $0x3c,%esp
  80cc32:	5b                   	pop    %ebx
  80cc33:	5e                   	pop    %esi
  80cc34:	5f                   	pop    %edi
  80cc35:	5d                   	pop    %ebp
  80cc36:	c3                   	ret    

0080cc37 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  80cc37:	55                   	push   %ebp
  80cc38:	89 e5                	mov    %esp,%ebp
  80cc3a:	83 ec 38             	sub    $0x38,%esp
  80cc3d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80cc40:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80cc43:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80cc46:	8b 75 08             	mov    0x8(%ebp),%esi
  80cc49:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80cc4c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80cc50:	89 1c 24             	mov    %ebx,(%esp)
  80cc53:	e8 10 cc ff ff       	call   809868 <ip_addr_isbroadcast>
  80cc58:	84 c0                	test   %al,%al
  80cc5a:	0f 85 c7 01 00 00    	jne    80ce27 <etharp_query+0x1f0>
      ip_addr_ismulticast(ipaddr) ||
  80cc60:	8b 03                	mov    (%ebx),%eax
  80cc62:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cc65:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80cc6c:	e8 49 e2 ff ff       	call   80aeba <ntohl>
  80cc71:	89 c7                	mov    %eax,%edi
  80cc73:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80cc7a:	e8 3b e2 ff ff       	call   80aeba <ntohl>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80cc7f:	23 7d e4             	and    -0x1c(%ebp),%edi
  80cc82:	39 c7                	cmp    %eax,%edi
  80cc84:	0f 84 9d 01 00 00    	je     80ce27 <etharp_query+0x1f0>
  80cc8a:	85 db                	test   %ebx,%ebx
  80cc8c:	0f 84 95 01 00 00    	je     80ce27 <etharp_query+0x1f0>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
  80cc92:	83 3b 00             	cmpl   $0x0,(%ebx)
  80cc95:	0f 84 8c 01 00 00    	je     80ce27 <etharp_query+0x1f0>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  80cc9b:	ba 01 00 00 00       	mov    $0x1,%edx
  80cca0:	89 d8                	mov    %ebx,%eax
  80cca2:	e8 5c fd ff ff       	call   80ca03 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  80cca7:	84 c0                	test   %al,%al
  80cca9:	0f 88 83 01 00 00    	js     80ce32 <etharp_query+0x1fb>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80ccaf:	0f be f8             	movsbl %al,%edi
  80ccb2:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80ccb5:	8b 80 70 5a b3 00    	mov    0xb35a70(%eax),%eax
  80ccbb:	85 c0                	test   %eax,%eax
  80ccbd:	75 0f                	jne    80ccce <etharp_query+0x97>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80ccbf:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80ccc2:	c7 80 70 5a b3 00 01 	movl   $0x1,0xb35a70(%eax)
  80ccc9:	00 00 00 
  80cccc:	eb 33                	jmp    80cd01 <etharp_query+0xca>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80ccce:	8d 50 ff             	lea    -0x1(%eax),%edx
  80ccd1:	83 fa 01             	cmp    $0x1,%edx
  80ccd4:	76 1c                	jbe    80ccf2 <etharp_query+0xbb>
  80ccd6:	c7 44 24 08 9c 3f 81 	movl   $0x813f9c,0x8(%esp)
  80ccdd:	00 
  80ccde:	c7 44 24 04 92 03 00 	movl   $0x392,0x4(%esp)
  80cce5:	00 
  80cce6:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80cced:	e8 f6 3c ff ff       	call   8009e8 <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  80ccf2:	83 f8 01             	cmp    $0x1,%eax
  80ccf5:	74 0a                	je     80cd01 <etharp_query+0xca>
  80ccf7:	c6 45 e4 ff          	movb   $0xff,-0x1c(%ebp)
  80ccfb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80ccff:	75 0f                	jne    80cd10 <etharp_query+0xd9>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80cd01:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80cd05:	89 34 24             	mov    %esi,(%esp)
  80cd08:	e8 12 fb ff ff       	call   80c81f <etharp_request>
  80cd0d:	88 45 e4             	mov    %al,-0x1c(%ebp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  80cd10:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80cd14:	0f 84 14 01 00 00    	je     80ce2e <etharp_query+0x1f7>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80cd1a:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80cd1d:	8b 80 70 5a b3 00    	mov    0xb35a70(%eax),%eax
  80cd23:	83 f8 02             	cmp    $0x2,%eax
  80cd26:	75 1d                	jne    80cd45 <etharp_query+0x10e>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80cd28:	8d 4e 25             	lea    0x25(%esi),%ecx
  80cd2b:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80cd2e:	05 68 5a b3 00       	add    $0xb35a68,%eax
  80cd33:	89 04 24             	mov    %eax,(%esp)
  80cd36:	8b 55 10             	mov    0x10(%ebp),%edx
  80cd39:	89 f0                	mov    %esi,%eax
  80cd3b:	e8 60 fa ff ff       	call   80c7a0 <etharp_send_ip>
  80cd40:	e9 ed 00 00 00       	jmp    80ce32 <etharp_query+0x1fb>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80cd45:	83 f8 01             	cmp    $0x1,%eax
  80cd48:	0f 85 e0 00 00 00    	jne    80ce2e <etharp_query+0x1f7>
  80cd4e:	8b 45 10             	mov    0x10(%ebp),%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  80cd51:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80cd55:	66 3b 50 08          	cmp    0x8(%eax),%dx
  80cd59:	75 21                	jne    80cd7c <etharp_query+0x145>
  80cd5b:	83 38 00             	cmpl   $0x0,(%eax)
  80cd5e:	74 1c                	je     80cd7c <etharp_query+0x145>
  80cd60:	c7 44 24 08 69 40 81 	movl   $0x814069,0x8(%esp)
  80cd67:	00 
  80cd68:	c7 44 24 04 b1 03 00 	movl   $0x3b1,0x4(%esp)
  80cd6f:	00 
  80cd70:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80cd77:	e8 6c 3c ff ff       	call   8009e8 <_panic>
        if(p->type != PBUF_ROM) {
  80cd7c:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  80cd80:	75 0b                	jne    80cd8d <etharp_query+0x156>
          copy_needed = 1;
          break;
        }
        p = p->next;
  80cd82:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  80cd84:	85 c0                	test   %eax,%eax
  80cd86:	75 c9                	jne    80cd51 <etharp_query+0x11a>
  80cd88:	e9 b2 00 00 00       	jmp    80ce3f <etharp_query+0x208>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80cd8d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80cd91:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80cd98:	00 
  80cd99:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cd9d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80cda4:	e8 8a b3 ff ff       	call   808133 <pbuf_alloc>
  80cda9:	89 c3                	mov    %eax,%ebx
        if(p != NULL) {
  80cdab:	85 c0                	test   %eax,%eax
  80cdad:	74 7f                	je     80ce2e <etharp_query+0x1f7>
          if (pbuf_copy(p, q) != ERR_OK) {
  80cdaf:	8b 45 10             	mov    0x10(%ebp),%eax
  80cdb2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cdb6:	89 1c 24             	mov    %ebx,(%esp)
  80cdb9:	e8 07 af ff ff       	call   807cc5 <pbuf_copy>
  80cdbe:	84 c0                	test   %al,%al
  80cdc0:	74 10                	je     80cdd2 <etharp_query+0x19b>
            pbuf_free(p);
  80cdc2:	89 1c 24             	mov    %ebx,(%esp)
  80cdc5:	e8 ae b0 ff ff       	call   807e78 <pbuf_free>
  80cdca:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80cdce:	66 90                	xchg   %ax,%ax
  80cdd0:	eb 60                	jmp    80ce32 <etharp_query+0x1fb>
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  80cdd2:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80cdd9:	e8 46 a9 ff ff       	call   807724 <memp_malloc>
        if (new_entry != NULL) {
  80cdde:	85 c0                	test   %eax,%eax
  80cde0:	74 37                	je     80ce19 <etharp_query+0x1e2>
          new_entry->next = 0;
  80cde2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  80cde8:	89 58 04             	mov    %ebx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  80cdeb:	6b d7 1c             	imul   $0x1c,%edi,%edx
  80cdee:	8b 92 60 5a b3 00    	mov    0xb35a60(%edx),%edx
  80cdf4:	85 d2                	test   %edx,%edx
  80cdf6:	74 11                	je     80ce09 <etharp_query+0x1d2>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  80cdf8:	89 d1                	mov    %edx,%ecx
  80cdfa:	8b 12                	mov    (%edx),%edx
  80cdfc:	85 d2                	test   %edx,%edx
  80cdfe:	75 f8                	jne    80cdf8 <etharp_query+0x1c1>
              r = r->next;
            }
            r->next = new_entry;
  80ce00:	89 01                	mov    %eax,(%ecx)
  80ce02:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce07:	eb 29                	jmp    80ce32 <etharp_query+0x1fb>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  80ce09:	6b ff 1c             	imul   $0x1c,%edi,%edi
  80ce0c:	89 87 60 5a b3 00    	mov    %eax,0xb35a60(%edi)
  80ce12:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce17:	eb 19                	jmp    80ce32 <etharp_query+0x1fb>
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  80ce19:	89 1c 24             	mov    %ebx,(%esp)
  80ce1c:	e8 57 b0 ff ff       	call   807e78 <pbuf_free>
  80ce21:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
  80ce25:	eb 0b                	jmp    80ce32 <etharp_query+0x1fb>
  80ce27:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80ce2c:	eb 04                	jmp    80ce32 <etharp_query+0x1fb>
  80ce2e:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  80ce32:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ce35:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ce38:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ce3b:	89 ec                	mov    %ebp,%esp
  80ce3d:	5d                   	pop    %ebp
  80ce3e:	c3                   	ret    
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  80ce3f:	8b 45 10             	mov    0x10(%ebp),%eax
  80ce42:	89 04 24             	mov    %eax,(%esp)
  80ce45:	e8 e0 ab ff ff       	call   807a2a <pbuf_ref>
  80ce4a:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80ce4d:	eb 83                	jmp    80cdd2 <etharp_query+0x19b>

0080ce4f <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  80ce4f:	55                   	push   %ebp
  80ce50:	89 e5                	mov    %esp,%ebp
  80ce52:	83 ec 48             	sub    $0x48,%esp
  80ce55:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ce58:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80ce5b:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80ce5e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ce61:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ce64:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80ce67:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  80ce6e:	00 
  80ce6f:	89 34 24             	mov    %esi,(%esp)
  80ce72:	e8 8c ac ff ff       	call   807b03 <pbuf_header>
  80ce77:	89 c2                	mov    %eax,%edx
  80ce79:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80ce7e:	84 d2                	test   %dl,%dl
  80ce80:	0f 85 bd 00 00 00    	jne    80cf43 <etharp_output+0xf4>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80ce86:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ce8a:	89 3c 24             	mov    %edi,(%esp)
  80ce8d:	e8 d6 c9 ff ff       	call   809868 <ip_addr_isbroadcast>
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80ce92:	ba 83 40 81 00       	mov    $0x814083,%edx
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80ce97:	84 c0                	test   %al,%al
  80ce99:	0f 85 95 00 00 00    	jne    80cf34 <etharp_output+0xe5>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  80ce9f:	8b 07                	mov    (%edi),%eax
  80cea1:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80cea4:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80ceab:	e8 0a e0 ff ff       	call   80aeba <ntohl>
  80ceb0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80ceb3:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80ceba:	e8 fb df ff ff       	call   80aeba <ntohl>
  80cebf:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80cec2:	23 55 d0             	and    -0x30(%ebp),%edx
  80cec5:	39 c2                	cmp    %eax,%edx
  80cec7:	75 41                	jne    80cf0a <etharp_output+0xbb>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  80cec9:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  80cecd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  80ced1:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  80ced5:	8b 07                	mov    (%edi),%eax
  80ced7:	89 04 24             	mov    %eax,(%esp)
  80ceda:	e8 db df ff ff       	call   80aeba <ntohl>
  80cedf:	c1 e8 10             	shr    $0x10,%eax
  80cee2:	83 e0 7f             	and    $0x7f,%eax
  80cee5:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  80cee8:	8b 07                	mov    (%edi),%eax
  80ceea:	89 04 24             	mov    %eax,(%esp)
  80ceed:	e8 c8 df ff ff       	call   80aeba <ntohl>
  80cef2:	c1 e8 08             	shr    $0x8,%eax
  80cef5:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  80cef8:	8b 07                	mov    (%edi),%eax
  80cefa:	89 04 24             	mov    %eax,(%esp)
  80cefd:	e8 b8 df ff ff       	call   80aeba <ntohl>
  80cf02:	88 45 e7             	mov    %al,-0x19(%ebp)
  80cf05:	8d 55 e2             	lea    -0x1e(%ebp),%edx
  80cf08:	eb 2a                	jmp    80cf34 <etharp_output+0xe5>
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  80cf0a:	8b 43 04             	mov    0x4(%ebx),%eax
  80cf0d:	33 07                	xor    (%edi),%eax
  80cf0f:	85 43 08             	test   %eax,0x8(%ebx)
  80cf12:	74 0e                	je     80cf22 <etharp_output+0xd3>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  80cf14:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80cf19:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  80cf1d:	74 24                	je     80cf43 <etharp_output+0xf4>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  80cf1f:	8d 7b 0c             	lea    0xc(%ebx),%edi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80cf22:	89 74 24 08          	mov    %esi,0x8(%esp)
  80cf26:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80cf2a:	89 1c 24             	mov    %ebx,(%esp)
  80cf2d:	e8 05 fd ff ff       	call   80cc37 <etharp_query>
  80cf32:	eb 0f                	jmp    80cf43 <etharp_output+0xf4>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  80cf34:	8d 4b 25             	lea    0x25(%ebx),%ecx
  80cf37:	89 14 24             	mov    %edx,(%esp)
  80cf3a:	89 f2                	mov    %esi,%edx
  80cf3c:	89 d8                	mov    %ebx,%eax
  80cf3e:	e8 5d f8 ff ff       	call   80c7a0 <etharp_send_ip>
}
  80cf43:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80cf46:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80cf49:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80cf4c:	89 ec                	mov    %ebp,%esp
  80cf4e:	5d                   	pop    %ebp
  80cf4f:	c3                   	ret    

0080cf50 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  80cf50:	55                   	push   %ebp
  80cf51:	89 e5                	mov    %esp,%ebp
  80cf53:	53                   	push   %ebx
  80cf54:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  80cf57:	ba 02 00 00 00       	mov    $0x2,%edx
  80cf5c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80cf5f:	e8 9f fa ff ff       	call   80ca03 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  80cf64:	84 c0                	test   %al,%al
  80cf66:	78 29                	js     80cf91 <etharp_find_addr+0x41>
  80cf68:	0f be d0             	movsbl %al,%edx
  80cf6b:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80cf6e:	83 b9 70 5a b3 00 02 	cmpl   $0x2,0xb35a70(%ecx)
  80cf75:	75 1a                	jne    80cf91 <etharp_find_addr+0x41>
      *eth_ret = &arp_table[i].ethaddr;
  80cf77:	89 ca                	mov    %ecx,%edx
  80cf79:	81 c2 60 5a b3 00    	add    $0xb35a60,%edx
  80cf7f:	8d 5a 08             	lea    0x8(%edx),%ebx
  80cf82:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80cf85:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  80cf87:	83 c2 04             	add    $0x4,%edx
  80cf8a:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80cf8d:	89 11                	mov    %edx,(%ecx)
      return i;
  80cf8f:	eb 05                	jmp    80cf96 <etharp_find_addr+0x46>
  80cf91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }
  return -1;
}
  80cf96:	83 c4 04             	add    $0x4,%esp
  80cf99:	5b                   	pop    %ebx
  80cf9a:	5d                   	pop    %ebp
  80cf9b:	c3                   	ret    

0080cf9c <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  80cf9c:	55                   	push   %ebp
  80cf9d:	89 e5                	mov    %esp,%ebp
  80cf9f:	57                   	push   %edi
  80cfa0:	56                   	push   %esi
  80cfa1:	53                   	push   %ebx
  80cfa2:	83 ec 0c             	sub    $0xc,%esp
  80cfa5:	bb 00 00 00 00       	mov    $0x0,%ebx
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80cfaa:	be 74 5a b3 00       	mov    $0xb35a74,%esi
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80cfaf:	bf 70 5a b3 00       	mov    $0xb35a70,%edi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80cfb4:	0f b6 14 1e          	movzbl (%esi,%ebx,1),%edx
  80cfb8:	83 c2 01             	add    $0x1,%edx
  80cfbb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80cfbe:	8b 04 1f             	mov    (%edi,%ebx,1),%eax
  80cfc1:	83 f8 02             	cmp    $0x2,%eax
  80cfc4:	75 07                	jne    80cfcd <etharp_tmr+0x31>
  80cfc6:	80 fa ef             	cmp    $0xef,%dl
  80cfc9:	77 0f                	ja     80cfda <etharp_tmr+0x3e>
  80cfcb:	eb 2d                	jmp    80cffa <etharp_tmr+0x5e>
  80cfcd:	83 f8 01             	cmp    $0x1,%eax
  80cfd0:	75 28                	jne    80cffa <etharp_tmr+0x5e>
  80cfd2:	80 fa 01             	cmp    $0x1,%dl
  80cfd5:	8d 76 00             	lea    0x0(%esi),%esi
  80cfd8:	76 20                	jbe    80cffa <etharp_tmr+0x5e>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  80cfda:	8b 83 60 5a b3 00    	mov    0xb35a60(%ebx),%eax
  80cfe0:	85 c0                	test   %eax,%eax
  80cfe2:	74 0f                	je     80cff3 <etharp_tmr+0x57>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  80cfe4:	e8 7d f9 ff ff       	call   80c966 <free_etharp_q>
        arp_table[i].q = NULL;
  80cfe9:	c7 83 60 5a b3 00 00 	movl   $0x0,0xb35a60(%ebx)
  80cff0:	00 00 00 
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  80cff3:	c7 04 1f 00 00 00 00 	movl   $0x0,(%edi,%ebx,1)
  80cffa:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80cffd:	81 fb 18 01 00 00    	cmp    $0x118,%ebx
  80d003:	75 af                	jne    80cfb4 <etharp_tmr+0x18>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  80d005:	83 c4 0c             	add    $0xc,%esp
  80d008:	5b                   	pop    %ebx
  80d009:	5e                   	pop    %esi
  80d00a:	5f                   	pop    %edi
  80d00b:	5d                   	pop    %ebp
  80d00c:	c3                   	ret    

0080d00d <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80d00d:	55                   	push   %ebp
  80d00e:	89 e5                	mov    %esp,%ebp
  80d010:	83 ec 38             	sub    $0x38,%esp
  80d013:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80d016:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80d019:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80d01c:	89 c6                	mov    %eax,%esi
  80d01e:	89 d3                	mov    %edx,%ebx
  80d020:	89 cf                	mov    %ecx,%edi
  80d022:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
  80d026:	88 45 e4             	mov    %al,-0x1c(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80d029:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  80d02d:	74 1c                	je     80d04b <update_arp_entry+0x3e>
  80d02f:	c7 44 24 08 c4 3f 81 	movl   $0x813fc4,0x8(%esp)
  80d036:	00 
  80d037:	c7 44 24 04 d9 01 00 	movl   $0x1d9,0x4(%esp)
  80d03e:	00 
  80d03f:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80d046:	e8 9d 39 ff ff       	call   8009e8 <_panic>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80d04b:	85 d2                	test   %edx,%edx
  80d04d:	0f 84 14 01 00 00    	je     80d167 <update_arp_entry+0x15a>
  80d053:	83 3a 00             	cmpl   $0x0,(%edx)
  80d056:	0f 84 0b 01 00 00    	je     80d167 <update_arp_entry+0x15a>
      ip_addr_isbroadcast(ipaddr, netif) ||
  80d05c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80d060:	89 14 24             	mov    %edx,(%esp)
  80d063:	e8 00 c8 ff ff       	call   809868 <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80d068:	84 c0                	test   %al,%al
  80d06a:	0f 85 f7 00 00 00    	jne    80d167 <update_arp_entry+0x15a>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  80d070:	8b 13                	mov    (%ebx),%edx
  80d072:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80d075:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80d07c:	e8 39 de ff ff       	call   80aeba <ntohl>
  80d081:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80d084:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d08b:	e8 2a de ff ff       	call   80aeba <ntohl>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80d090:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80d093:	23 55 e0             	and    -0x20(%ebp),%edx
  80d096:	39 c2                	cmp    %eax,%edx
  80d098:	0f 84 c9 00 00 00    	je     80d167 <update_arp_entry+0x15a>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  80d09e:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
  80d0a2:	89 d8                	mov    %ebx,%eax
  80d0a4:	e8 5a f9 ff ff       	call   80ca03 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  80d0a9:	84 c0                	test   %al,%al
  80d0ab:	0f 88 bb 00 00 00    	js     80d16c <update_arp_entry+0x15f>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  80d0b1:	0f be c0             	movsbl %al,%eax
  80d0b4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80d0b7:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80d0ba:	c7 80 70 5a b3 00 02 	movl   $0x2,0xb35a70(%eax)
  80d0c1:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  80d0c4:	89 b0 78 5a b3 00    	mov    %esi,0xb35a78(%eax)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  80d0ca:	0f b6 5f 05          	movzbl 0x5(%edi),%ebx
  80d0ce:	88 98 6d 5a b3 00    	mov    %bl,0xb35a6d(%eax)
  80d0d4:	6b 4d e0 07          	imul   $0x7,-0x20(%ebp),%ecx
  80d0d8:	bb 60 5a b3 00       	mov    $0xb35a60,%ebx
  80d0dd:	0f b6 57 04          	movzbl 0x4(%edi),%edx
  80d0e1:	88 54 8b 0c          	mov    %dl,0xc(%ebx,%ecx,4)
  80d0e5:	0f b6 4f 03          	movzbl 0x3(%edi),%ecx
  80d0e9:	88 88 6b 5a b3 00    	mov    %cl,0xb35a6b(%eax)
  80d0ef:	6b 4d e0 0e          	imul   $0xe,-0x20(%ebp),%ecx
  80d0f3:	0f b6 57 02          	movzbl 0x2(%edi),%edx
  80d0f7:	88 54 4b 0a          	mov    %dl,0xa(%ebx,%ecx,2)
  80d0fb:	0f b6 4f 01          	movzbl 0x1(%edi),%ecx
  80d0ff:	88 88 69 5a b3 00    	mov    %cl,0xb35a69(%eax)
  80d105:	0f b6 0f             	movzbl (%edi),%ecx
  80d108:	88 4c 18 08          	mov    %cl,0x8(%eax,%ebx,1)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  80d10c:	c6 80 74 5a b3 00 00 	movb   $0x0,0xb35a74(%eax)
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80d113:	8d 4e 25             	lea    0x25(%esi),%ecx
  80d116:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80d119:	6b 45 e0 1c          	imul   $0x1c,-0x20(%ebp),%eax
  80d11d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80d120:	eb 39                	jmp    80d15b <update_arp_entry+0x14e>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  80d122:	8b 10                	mov    (%eax),%edx
  80d124:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80d127:	89 14 19             	mov    %edx,(%ecx,%ebx,1)
    /* get the packet pointer */
    p = q->p;
  80d12a:	8b 50 04             	mov    0x4(%eax),%edx
  80d12d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  80d130:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d134:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80d13b:	e8 a0 a5 ff ff       	call   8076e0 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80d140:	89 3c 24             	mov    %edi,(%esp)
  80d143:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80d146:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d149:	89 f0                	mov    %esi,%eax
  80d14b:	e8 50 f6 ff ff       	call   80c7a0 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  80d150:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80d153:	89 0c 24             	mov    %ecx,(%esp)
  80d156:	e8 1d ad ff ff       	call   807e78 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80d15b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80d15e:	8b 04 1a             	mov    (%edx,%ebx,1),%eax
  80d161:	85 c0                	test   %eax,%eax
  80d163:	75 bd                	jne    80d122 <update_arp_entry+0x115>
  80d165:	eb 05                	jmp    80d16c <update_arp_entry+0x15f>
  80d167:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  80d16c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80d16f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80d172:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80d175:	89 ec                	mov    %ebp,%esp
  80d177:	5d                   	pop    %ebp
  80d178:	c3                   	ret    

0080d179 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  80d179:	55                   	push   %ebp
  80d17a:	89 e5                	mov    %esp,%ebp
  80d17c:	83 ec 18             	sub    $0x18,%esp
  80d17f:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80d182:	85 c0                	test   %eax,%eax
  80d184:	75 1c                	jne    80d1a2 <etharp_ip_input+0x29>
  80d186:	c7 44 24 08 83 32 81 	movl   $0x813283,0x8(%esp)
  80d18d:	00 
  80d18e:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  80d195:	00 
  80d196:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80d19d:	e8 46 38 ff ff       	call   8009e8 <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  80d1a2:	8b 55 0c             	mov    0xc(%ebp),%edx
  80d1a5:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80d1a8:	8b 48 04             	mov    0x4(%eax),%ecx
  80d1ab:	33 4a 1c             	xor    0x1c(%edx),%ecx
  80d1ae:	85 48 08             	test   %ecx,0x8(%eax)
  80d1b1:	75 12                	jne    80d1c5 <etharp_ip_input+0x4c>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  80d1b3:	8d 4a 06             	lea    0x6(%edx),%ecx
  80d1b6:	83 c2 1c             	add    $0x1c,%edx
  80d1b9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80d1c0:	e8 48 fe ff ff       	call   80d00d <update_arp_entry>
}
  80d1c5:	c9                   	leave  
  80d1c6:	c3                   	ret    

0080d1c7 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  80d1c7:	55                   	push   %ebp
  80d1c8:	89 e5                	mov    %esp,%ebp
  80d1ca:	83 ec 38             	sub    $0x38,%esp
  80d1cd:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80d1d0:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80d1d3:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80d1d6:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80d1d9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80d1dd:	75 1c                	jne    80d1fb <etharp_arp_input+0x34>
  80d1df:	c7 44 24 08 83 32 81 	movl   $0x813283,0x8(%esp)
  80d1e6:	00 
  80d1e7:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80d1ee:	00 
  80d1ef:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80d1f6:	e8 ed 37 ff ff       	call   8009e8 <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  80d1fb:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  80d200:	77 0d                	ja     80d20f <etharp_arp_input+0x48>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80d202:	89 1c 24             	mov    %ebx,(%esp)
  80d205:	e8 6e ac ff ff       	call   807e78 <pbuf_free>
    return;
  80d20a:	e9 ab 01 00 00       	jmp    80d3ba <etharp_arp_input+0x1f3>
  }

  hdr = p->payload;
  80d20f:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80d212:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  80d216:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80d21d:	e8 52 da ff ff       	call   80ac74 <htons>
  80d222:	66 39 c7             	cmp    %ax,%di
  80d225:	75 3f                	jne    80d266 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  80d227:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  80d22b:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80d232:	e8 3d da ff ff       	call   80ac74 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80d237:	66 39 c7             	cmp    %ax,%di
  80d23a:	75 2a                	jne    80d266 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80d23c:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  80d240:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80d247:	e8 28 da ff ff       	call   80ac74 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80d24c:	66 39 c7             	cmp    %ax,%di
  80d24f:	75 15                	jne    80d266 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  80d251:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  80d255:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80d25c:	e8 13 da ff ff       	call   80ac74 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80d261:	66 39 c7             	cmp    %ax,%di
  80d264:	74 0f                	je     80d275 <etharp_arp_input+0xae>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80d266:	89 1c 24             	mov    %ebx,(%esp)
  80d269:	e8 0a ac ff ff       	call   807e78 <pbuf_free>
    return;
  80d26e:	66 90                	xchg   %ax,%ax
  80d270:	e9 45 01 00 00       	jmp    80d3ba <etharp_arp_input+0x1f3>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  80d275:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80d27c:	00 
  80d27d:	8d 46 1c             	lea    0x1c(%esi),%eax
  80d280:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d284:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d287:	89 04 24             	mov    %eax,(%esp)
  80d28a:	e8 a2 43 ff ff       	call   801631 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  80d28f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80d296:	00 
  80d297:	8d 46 26             	lea    0x26(%esi),%eax
  80d29a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d29e:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80d2a1:	89 04 24             	mov    %eax,(%esp)
  80d2a4:	e8 88 43 ff ff       	call   801631 <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80d2a9:	8b 55 08             	mov    0x8(%ebp),%edx
  80d2ac:	8b 42 04             	mov    0x4(%edx),%eax

  /* ARP message directed to us? */
  if (for_us) {
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80d2af:	bf 00 00 00 00       	mov    $0x0,%edi
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80d2b4:	85 c0                	test   %eax,%eax
  80d2b6:	74 21                	je     80d2d9 <etharp_arp_input+0x112>
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  80d2b8:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  }

  /* ARP message directed to us? */
  if (for_us) {
  80d2bb:	0f 94 c0             	sete   %al
  80d2be:	89 c7                	mov    %eax,%edi
  80d2c0:	75 17                	jne    80d2d9 <etharp_arp_input+0x112>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80d2c2:	8d 4e 16             	lea    0x16(%esi),%ecx
  80d2c5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80d2c8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80d2cf:	8b 45 08             	mov    0x8(%ebp),%eax
  80d2d2:	e8 36 fd ff ff       	call   80d00d <update_arp_entry>
  80d2d7:	eb 15                	jmp    80d2ee <etharp_arp_input+0x127>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  80d2d9:	8d 4e 16             	lea    0x16(%esi),%ecx
  80d2dc:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80d2df:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80d2e6:	8b 45 08             	mov    0x8(%ebp),%eax
  80d2e9:	e8 1f fd ff ff       	call   80d00d <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  80d2ee:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  80d2f2:	89 04 24             	mov    %eax,(%esp)
  80d2f5:	e8 7a d9 ff ff       	call   80ac74 <htons>
  80d2fa:	66 83 f8 01          	cmp    $0x1,%ax
  80d2fe:	74 15                	je     80d315 <etharp_arp_input+0x14e>
  80d300:	66 83 f8 02          	cmp    $0x2,%ax
  80d304:	0f 85 a8 00 00 00    	jne    80d3b2 <etharp_arp_input+0x1eb>
  80d30a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80d310:	e9 8b 00 00 00       	jmp    80d3a0 <etharp_arp_input+0x1d9>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  80d315:	89 fa                	mov    %edi,%edx
  80d317:	84 d2                	test   %dl,%dl
  80d319:	0f 84 93 00 00 00    	je     80d3b2 <etharp_arp_input+0x1eb>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  80d31f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80d326:	e8 49 d9 ff ff       	call   80ac74 <htons>
  80d32b:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  80d32f:	8b 46 1c             	mov    0x1c(%esi),%eax
  80d332:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  80d335:	8b 55 08             	mov    0x8(%ebp),%edx
  80d338:	8b 42 04             	mov    0x4(%edx),%eax
  80d33b:	89 46 1c             	mov    %eax,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80d33e:	ba 06 00 00 00       	mov    $0x6,%edx
  80d343:	8b 45 08             	mov    0x8(%ebp),%eax
  80d346:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80d34a:	74 1c                	je     80d368 <etharp_arp_input+0x1a1>
  80d34c:	c7 44 24 08 24 3f 81 	movl   $0x813f24,0x8(%esp)
  80d353:	00 
  80d354:	c7 44 24 04 c7 02 00 	movl   $0x2c7,0x4(%esp)
  80d35b:	00 
  80d35c:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80d363:	e8 80 36 ff ff       	call   8009e8 <_panic>
  80d368:	8b 7d 0c             	mov    0xc(%ebp),%edi
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  80d36b:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  80d36e:	0f b6 c2             	movzbl %dl,%eax
  80d371:	0f b6 4c 06 16       	movzbl 0x16(%esi,%eax,1),%ecx
  80d376:	88 4c 06 20          	mov    %cl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  80d37a:	88 0c 06             	mov    %cl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  80d37d:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80d381:	88 4c 06 16          	mov    %cl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  80d385:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80d389:	88 4c 06 06          	mov    %cl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  80d38d:	84 d2                	test   %dl,%dl
  80d38f:	75 da                	jne    80d36b <etharp_arp_input+0x1a4>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  80d391:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80d395:	8b 55 08             	mov    0x8(%ebp),%edx
  80d398:	89 14 24             	mov    %edx,(%esp)
  80d39b:	ff 52 18             	call   *0x18(%edx)
  80d39e:	eb 12                	jmp    80d3b2 <etharp_arp_input+0x1eb>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  80d3a0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d3a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d3a7:	8b 45 08             	mov    0x8(%ebp),%eax
  80d3aa:	89 04 24             	mov    %eax,(%esp)
  80d3ad:	e8 75 90 ff ff       	call   806427 <dhcp_arp_reply>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  80d3b2:	89 1c 24             	mov    %ebx,(%esp)
  80d3b5:	e8 be aa ff ff       	call   807e78 <pbuf_free>
}
  80d3ba:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80d3bd:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80d3c0:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80d3c3:	89 ec                	mov    %ebp,%esp
  80d3c5:	5d                   	pop    %ebp
  80d3c6:	c3                   	ret    

0080d3c7 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  80d3c7:	55                   	push   %ebp
  80d3c8:	89 e5                	mov    %esp,%ebp
  80d3ca:	83 ec 18             	sub    $0x18,%esp
  80d3cd:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80d3d0:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80d3d3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80d3d6:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  80d3d9:	8b 43 04             	mov    0x4(%ebx),%eax
  80d3dc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d3e0:	89 04 24             	mov    %eax,(%esp)
  80d3e3:	e8 8c d8 ff ff       	call   80ac74 <htons>
  80d3e8:	66 3d 00 08          	cmp    $0x800,%ax
  80d3ec:	74 0c                	je     80d3fa <ethernet_input+0x33>
  80d3ee:	66 3d 06 08          	cmp    $0x806,%ax
  80d3f2:	75 65                	jne    80d459 <ethernet_input+0x92>
  80d3f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80d3f8:	eb 4a                	jmp    80d444 <ethernet_input+0x7d>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  80d3fa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80d3fe:	89 34 24             	mov    %esi,(%esp)
  80d401:	e8 73 fd ff ff       	call   80d179 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  80d406:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80d40d:	ff 
  80d40e:	89 1c 24             	mov    %ebx,(%esp)
  80d411:	e8 ed a6 ff ff       	call   807b03 <pbuf_header>
  80d416:	84 c0                	test   %al,%al
  80d418:	74 1c                	je     80d436 <ethernet_input+0x6f>
        LWIP_ASSERT("Can't move over header in packet", 0);
  80d41a:	c7 44 24 08 ec 3f 81 	movl   $0x813fec,0x8(%esp)
  80d421:	00 
  80d422:	c7 44 24 04 7e 04 00 	movl   $0x47e,0x4(%esp)
  80d429:	00 
  80d42a:	c7 04 24 0d 40 81 00 	movl   $0x81400d,(%esp)
  80d431:	e8 b2 35 ff ff       	call   8009e8 <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  80d436:	89 74 24 04          	mov    %esi,0x4(%esp)
  80d43a:	89 1c 24             	mov    %ebx,(%esp)
  80d43d:	e8 f2 c6 ff ff       	call   809b34 <ip_input>
      }
      break;
  80d442:	eb 1d                	jmp    80d461 <ethernet_input+0x9a>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  80d444:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80d448:	8d 46 25             	lea    0x25(%esi),%eax
  80d44b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d44f:	89 34 24             	mov    %esi,(%esp)
  80d452:	e8 70 fd ff ff       	call   80d1c7 <etharp_arp_input>
      break;
  80d457:	eb 08                	jmp    80d461 <ethernet_input+0x9a>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  80d459:	89 1c 24             	mov    %ebx,(%esp)
  80d45c:	e8 17 aa ff ff       	call   807e78 <pbuf_free>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  80d461:	b8 00 00 00 00       	mov    $0x0,%eax
  80d466:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80d469:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80d46c:	89 ec                	mov    %ebp,%esp
  80d46e:	5d                   	pop    %ebp
  80d46f:	c3                   	ret    

0080d470 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  80d470:	55                   	push   %ebp
  80d471:	89 e5                	mov    %esp,%ebp
  80d473:	56                   	push   %esi
  80d474:	53                   	push   %ebx
  80d475:	b8 80 5b b3 00       	mov    $0xb35b80,%eax

enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
  80d47a:	be 80 6f b3 00       	mov    $0xb36f80,%esi
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80d47f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  80d485:	89 c1                	mov    %eax,%ecx
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80d487:	8b 15 80 6f b3 00    	mov    0xb36f80,%edx
  80d48d:	89 50 0c             	mov    %edx,0xc(%eax)
  80d490:	85 d2                	test   %edx,%edx
  80d492:	74 06                	je     80d49a <sys_init+0x2a>
  80d494:	8d 58 0c             	lea    0xc(%eax),%ebx
  80d497:	89 5a 10             	mov    %ebx,0x10(%edx)
  80d49a:	89 0d 80 6f b3 00    	mov    %ecx,0xb36f80
  80d4a0:	c7 40 10 80 6f b3 00 	movl   $0xb36f80,0x10(%eax)
  80d4a7:	83 c0 14             	add    $0x14,%eax

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80d4aa:	39 f0                	cmp    %esi,%eax
  80d4ac:	75 d1                	jne    80d47f <sys_init+0xf>
  80d4ae:	b8 a0 6f b3 00       	mov    $0xb36fa0,%eax

enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
  80d4b3:	be a0 bd b3 00       	mov    $0xb3bda0,%esi
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  80d4b8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  80d4be:	89 c1                	mov    %eax,%ecx
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80d4c0:	8b 15 a0 bd b3 00    	mov    0xb3bda0,%edx
  80d4c6:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  80d4cc:	85 d2                	test   %edx,%edx
  80d4ce:	74 0c                	je     80d4dc <sys_init+0x6c>
  80d4d0:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  80d4d6:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  80d4dc:	89 0d a0 bd b3 00    	mov    %ecx,0xb3bda0
  80d4e2:	c7 80 98 00 00 00 a0 	movl   $0xb3bda0,0x98(%eax)
  80d4e9:	bd b3 00 
  80d4ec:	05 9c 00 00 00       	add    $0x9c,%eax
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  80d4f1:	39 f0                	cmp    %esi,%eax
  80d4f3:	75 c3                	jne    80d4b8 <sys_init+0x48>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  80d4f5:	5b                   	pop    %ebx
  80d4f6:	5e                   	pop    %esi
  80d4f7:	5d                   	pop    %ebp
  80d4f8:	c3                   	ret    

0080d4f9 <lwip_core_lock>:
    return &t->tmo;
}

void
lwip_core_lock(void)
{
  80d4f9:	55                   	push   %ebp
  80d4fa:	89 e5                	mov    %esp,%ebp
}
  80d4fc:	5d                   	pop    %ebp
  80d4fd:	c3                   	ret    

0080d4fe <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80d4fe:	55                   	push   %ebp
  80d4ff:	89 e5                	mov    %esp,%ebp
}
  80d501:	5d                   	pop    %ebp
  80d502:	c3                   	ret    

0080d503 <sys_sem_free>:
    return se - &sems[0];
}

void
sys_sem_free(sys_sem_t sem)
{
  80d503:	55                   	push   %ebp
  80d504:	89 e5                	mov    %esp,%ebp
  80d506:	53                   	push   %ebx
  80d507:	83 ec 14             	sub    $0x14,%esp
  80d50a:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80d50d:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80d510:	83 3c 95 80 5b b3 00 	cmpl   $0x0,0xb35b80(,%edx,4)
  80d517:	00 
  80d518:	74 24                	je     80d53e <sys_sem_free+0x3b>
  80d51a:	c7 44 24 0c 8f 40 81 	movl   $0x81408f,0xc(%esp)
  80d521:	00 
  80d522:	c7 44 24 08 20 2c 81 	movl   $0x812c20,0x8(%esp)
  80d529:	00 
  80d52a:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80d531:	00 
  80d532:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80d539:	e8 aa 34 ff ff       	call   8009e8 <_panic>
    sems[sem].freed = 1;
  80d53e:	b9 80 5b b3 00       	mov    $0xb35b80,%ecx
  80d543:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80d54a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  80d54d:	c7 04 99 01 00 00 00 	movl   $0x1,(%ecx,%ebx,4)
    sems[sem].gen++;
  80d554:	83 44 99 04 01       	addl   $0x1,0x4(%ecx,%ebx,4)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80d559:	8d 04 9d 80 5b b3 00 	lea    0xb35b80(,%ebx,4),%eax
  80d560:	8b 15 80 6f b3 00    	mov    0xb36f80,%edx
  80d566:	89 50 0c             	mov    %edx,0xc(%eax)
  80d569:	85 d2                	test   %edx,%edx
  80d56b:	74 06                	je     80d573 <sys_sem_free+0x70>
  80d56d:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d570:	89 4a 10             	mov    %ecx,0x10(%edx)
  80d573:	a3 80 6f b3 00       	mov    %eax,0xb36f80
  80d578:	c7 40 10 80 6f b3 00 	movl   $0xb36f80,0x10(%eax)
}
  80d57f:	83 c4 14             	add    $0x14,%esp
  80d582:	5b                   	pop    %ebx
  80d583:	5d                   	pop    %ebp
  80d584:	c3                   	ret    

0080d585 <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  80d585:	55                   	push   %ebp
  80d586:	89 e5                	mov    %esp,%ebp
  80d588:	56                   	push   %esi
  80d589:	53                   	push   %ebx
  80d58a:	83 ec 10             	sub    $0x10,%esp
  80d58d:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80d590:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80d596:	83 b8 a0 6f b3 00 00 	cmpl   $0x0,0xb36fa0(%eax)
  80d59d:	74 24                	je     80d5c3 <sys_mbox_free+0x3e>
  80d59f:	c7 44 24 0c bd 40 81 	movl   $0x8140bd,0xc(%esp)
  80d5a6:	00 
  80d5a7:	c7 44 24 08 20 2c 81 	movl   $0x812c20,0x8(%esp)
  80d5ae:	00 
  80d5af:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  80d5b6:	00 
  80d5b7:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80d5be:	e8 25 34 ff ff       	call   8009e8 <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  80d5c3:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80d5c9:	8b 83 2c 70 b3 00    	mov    0xb3702c(%ebx),%eax
  80d5cf:	89 04 24             	mov    %eax,(%esp)
  80d5d2:	e8 2c ff ff ff       	call   80d503 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80d5d7:	8b 83 30 70 b3 00    	mov    0xb37030(%ebx),%eax
  80d5dd:	89 04 24             	mov    %eax,(%esp)
  80d5e0:	e8 1e ff ff ff       	call   80d503 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80d5e5:	81 c3 a0 6f b3 00    	add    $0xb36fa0,%ebx
  80d5eb:	a1 a0 bd b3 00       	mov    0xb3bda0,%eax
  80d5f0:	89 83 94 00 00 00    	mov    %eax,0x94(%ebx)
  80d5f6:	85 c0                	test   %eax,%eax
  80d5f8:	74 0c                	je     80d606 <sys_mbox_free+0x81>
  80d5fa:	8d 93 94 00 00 00    	lea    0x94(%ebx),%edx
  80d600:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80d606:	89 1d a0 bd b3 00    	mov    %ebx,0xb3bda0
  80d60c:	c7 83 98 00 00 00 a0 	movl   $0xb3bda0,0x98(%ebx)
  80d613:	bd b3 00 
    mboxes[mbox].freed = 1;
  80d616:	69 f6 9c 00 00 00    	imul   $0x9c,%esi,%esi
  80d61c:	c7 86 a0 6f b3 00 01 	movl   $0x1,0xb36fa0(%esi)
  80d623:	00 00 00 
}
  80d626:	83 c4 10             	add    $0x10,%esp
  80d629:	5b                   	pop    %ebx
  80d62a:	5e                   	pop    %esi
  80d62b:	5d                   	pop    %ebp
  80d62c:	c3                   	ret    

0080d62d <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80d62d:	55                   	push   %ebp
  80d62e:	89 e5                	mov    %esp,%ebp
  80d630:	57                   	push   %edi
  80d631:	56                   	push   %esi
  80d632:	53                   	push   %ebx
  80d633:	83 ec 1c             	sub    $0x1c,%esp
    thread_id_t tid = thread_id();
  80d636:	e8 f8 07 00 00       	call   80de33 <thread_id>
  80d63b:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d63d:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80d642:	f7 e2                	mul    %edx
  80d644:	c1 ea 08             	shr    $0x8,%edx
  80d647:	89 d0                	mov    %edx,%eax
  80d649:	c1 e0 08             	shl    $0x8,%eax
  80d64c:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80d64f:	89 f0                	mov    %esi,%eax
  80d651:	29 d0                	sub    %edx,%eax
  80d653:	8d 3c 85 c0 bd b3 00 	lea    0xb3bdc0(,%eax,4),%edi
  80d65a:	8b 1f                	mov    (%edi),%ebx
  80d65c:	85 db                	test   %ebx,%ebx
  80d65e:	74 22                	je     80d682 <sys_arch_timeouts+0x55>
	if (t->tid == tid)
  80d660:	3b 33                	cmp    (%ebx),%esi
  80d662:	75 12                	jne    80d676 <sys_arch_timeouts+0x49>
  80d664:	e9 b2 00 00 00       	jmp    80d71b <sys_arch_timeouts+0xee>
  80d669:	3b 33                	cmp    (%ebx),%esi
  80d66b:	90                   	nop
  80d66c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80d670:	0f 84 a5 00 00 00    	je     80d71b <sys_arch_timeouts+0xee>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d676:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80d679:	85 db                	test   %ebx,%ebx
  80d67b:	90                   	nop
  80d67c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80d680:	75 e7                	jne    80d669 <sys_arch_timeouts+0x3c>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80d682:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  80d689:	e8 a5 5b ff ff       	call   803233 <malloc>
  80d68e:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80d690:	85 c0                	test   %eax,%eax
  80d692:	75 1c                	jne    80d6b0 <sys_arch_timeouts+0x83>
	panic("sys_arch_timeouts: cannot malloc");
  80d694:	c7 44 24 08 20 41 81 	movl   $0x814120,0x8(%esp)
  80d69b:	00 
  80d69c:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  80d6a3:	00 
  80d6a4:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80d6ab:	e8 38 33 ff ff       	call   8009e8 <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80d6b0:	c7 04 24 26 d7 80 00 	movl   $0x80d726,(%esp)
  80d6b7:	e8 ca 07 00 00       	call   80de86 <thread_onhalt>
    if (r < 0)
  80d6bc:	85 c0                	test   %eax,%eax
  80d6be:	79 28                	jns    80d6e8 <sys_arch_timeouts+0xbb>
	panic("thread_onhalt failed: %s", e2s(r));
  80d6c0:	89 04 24             	mov    %eax,(%esp)
  80d6c3:	e8 30 0b 00 00       	call   80e1f8 <e2s>
  80d6c8:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d6cc:	c7 44 24 08 d1 40 81 	movl   $0x8140d1,0x8(%esp)
  80d6d3:	00 
  80d6d4:	c7 44 24 04 31 01 00 	movl   $0x131,0x4(%esp)
  80d6db:	00 
  80d6dc:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80d6e3:	e8 00 33 ff ff       	call   8009e8 <_panic>

    t->tid = tid;
  80d6e8:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80d6ea:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80d6f1:	00 
  80d6f2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80d6f9:	00 
  80d6fa:	8d 43 04             	lea    0x4(%ebx),%eax
  80d6fd:	89 04 24             	mov    %eax,(%esp)
  80d700:	e8 51 3e ff ff       	call   801556 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80d705:	8b 07                	mov    (%edi),%eax
  80d707:	89 43 08             	mov    %eax,0x8(%ebx)
  80d70a:	85 c0                	test   %eax,%eax
  80d70c:	74 08                	je     80d716 <sys_arch_timeouts+0xe9>
  80d70e:	8b 07                	mov    (%edi),%eax
  80d710:	8d 53 08             	lea    0x8(%ebx),%edx
  80d713:	89 50 0c             	mov    %edx,0xc(%eax)
  80d716:	89 1f                	mov    %ebx,(%edi)
  80d718:	89 7b 0c             	mov    %edi,0xc(%ebx)
  80d71b:	8d 43 04             	lea    0x4(%ebx),%eax

out:
    return &t->tmo;
}
  80d71e:	83 c4 1c             	add    $0x1c,%esp
  80d721:	5b                   	pop    %ebx
  80d722:	5e                   	pop    %esi
  80d723:	5f                   	pop    %edi
  80d724:	5d                   	pop    %ebp
  80d725:	c3                   	ret    

0080d726 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  80d726:	55                   	push   %ebp
  80d727:	89 e5                	mov    %esp,%ebp
  80d729:	83 ec 18             	sub    $0x18,%esp
  80d72c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d72f:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80d734:	89 c8                	mov    %ecx,%eax
  80d736:	f7 e2                	mul    %edx
  80d738:	c1 ea 08             	shr    $0x8,%edx
  80d73b:	89 d0                	mov    %edx,%eax
  80d73d:	c1 e0 08             	shl    $0x8,%eax
  80d740:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80d743:	89 c8                	mov    %ecx,%eax
  80d745:	29 d0                	sub    %edx,%eax
  80d747:	8b 04 85 c0 bd b3 00 	mov    0xb3bdc0(,%eax,4),%eax
  80d74e:	85 c0                	test   %eax,%eax
  80d750:	74 36                	je     80d788 <timeout_cleanup+0x62>
	if (t->tid == tid) {
  80d752:	39 08                	cmp    %ecx,(%eax)
  80d754:	75 2b                	jne    80d781 <timeout_cleanup+0x5b>
  80d756:	eb 0a                	jmp    80d762 <timeout_cleanup+0x3c>
  80d758:	39 08                	cmp    %ecx,(%eax)
  80d75a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80d760:	75 1f                	jne    80d781 <timeout_cleanup+0x5b>
	    LIST_REMOVE(t, link);
  80d762:	8b 50 08             	mov    0x8(%eax),%edx
  80d765:	85 d2                	test   %edx,%edx
  80d767:	74 06                	je     80d76f <timeout_cleanup+0x49>
  80d769:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d76c:	89 4a 0c             	mov    %ecx,0xc(%edx)
  80d76f:	8b 50 0c             	mov    0xc(%eax),%edx
  80d772:	8b 48 08             	mov    0x8(%eax),%ecx
  80d775:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  80d777:	89 04 24             	mov    %eax,(%esp)
  80d77a:	e8 e1 59 ff ff       	call   803160 <free>
	    goto done;
  80d77f:	eb 07                	jmp    80d788 <timeout_cleanup+0x62>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d781:	8b 40 08             	mov    0x8(%eax),%eax
  80d784:	85 c0                	test   %eax,%eax
  80d786:	75 d0                	jne    80d758 <timeout_cleanup+0x32>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  80d788:	c9                   	leave  
  80d789:	c3                   	ret    

0080d78a <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  80d78a:	55                   	push   %ebp
  80d78b:	89 e5                	mov    %esp,%ebp
  80d78d:	53                   	push   %ebx
  80d78e:	83 ec 14             	sub    $0x14,%esp
  80d791:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  80d794:	8b 43 04             	mov    0x4(%ebx),%eax
  80d797:	89 04 24             	mov    %eax,(%esp)
  80d79a:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  80d79c:	89 1c 24             	mov    %ebx,(%esp)
  80d79f:	e8 bc 59 ff ff       	call   803160 <free>
}
  80d7a4:	83 c4 14             	add    $0x14,%esp
  80d7a7:	5b                   	pop    %ebx
  80d7a8:	5d                   	pop    %ebp
  80d7a9:	c3                   	ret    

0080d7aa <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80d7aa:	55                   	push   %ebp
  80d7ab:	89 e5                	mov    %esp,%ebp
  80d7ad:	53                   	push   %ebx
  80d7ae:	83 ec 24             	sub    $0x24,%esp
  80d7b1:	8b 5d 14             	mov    0x14(%ebp),%ebx
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80d7b4:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80d7bb:	e8 73 5a ff ff       	call   803233 <malloc>
    if (lt == 0)
  80d7c0:	85 c0                	test   %eax,%eax
  80d7c2:	75 1c                	jne    80d7e0 <sys_thread_new+0x36>
	panic("sys_thread_new: cannot allocate thread struct");
  80d7c4:	c7 44 24 08 44 41 81 	movl   $0x814144,0x8(%esp)
  80d7cb:	00 
  80d7cc:	c7 44 24 04 fe 00 00 	movl   $0xfe,0x4(%esp)
  80d7d3:	00 
  80d7d4:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80d7db:	e8 08 32 ff ff       	call   8009e8 <_panic>

    if (stacksize > PGSIZE)
  80d7e0:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
  80d7e6:	7e 20                	jle    80d808 <sys_thread_new+0x5e>
	panic("large stack %d", stacksize);
  80d7e8:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80d7ec:	c7 44 24 08 ea 40 81 	movl   $0x8140ea,0x8(%esp)
  80d7f3:	00 
  80d7f4:	c7 44 24 04 01 01 00 	movl   $0x101,0x4(%esp)
  80d7fb:	00 
  80d7fc:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80d803:	e8 e0 31 ff ff       	call   8009e8 <_panic>

    lt->func = thread;
  80d808:	8b 55 0c             	mov    0xc(%ebp),%edx
  80d80b:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80d80d:	8b 55 10             	mov    0x10(%ebp),%edx
  80d810:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80d813:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d817:	c7 44 24 08 8a d7 80 	movl   $0x80d78a,0x8(%esp)
  80d81e:	00 
  80d81f:	8b 45 08             	mov    0x8(%ebp),%eax
  80d822:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d826:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80d829:	89 04 24             	mov    %eax,(%esp)
  80d82c:	e8 c6 07 00 00       	call   80dff7 <thread_create>

    if (r < 0)
  80d831:	85 c0                	test   %eax,%eax
  80d833:	79 28                	jns    80d85d <sys_thread_new+0xb3>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80d835:	89 04 24             	mov    %eax,(%esp)
  80d838:	e8 bb 09 00 00       	call   80e1f8 <e2s>
  80d83d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d841:	c7 44 24 08 74 41 81 	movl   $0x814174,0x8(%esp)
  80d848:	00 
  80d849:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  80d850:	00 
  80d851:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80d858:	e8 8b 31 ff ff       	call   8009e8 <_panic>

    return tid;
}
  80d85d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80d860:	83 c4 24             	add    $0x24,%esp
  80d863:	5b                   	pop    %ebx
  80d864:	5d                   	pop    %ebp
  80d865:	c3                   	ret    

0080d866 <sys_arch_sem_wait>:
    }
}

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80d866:	55                   	push   %ebp
  80d867:	89 e5                	mov    %esp,%ebp
  80d869:	57                   	push   %edi
  80d86a:	56                   	push   %esi
  80d86b:	53                   	push   %ebx
  80d86c:	83 ec 3c             	sub    $0x3c,%esp
    assert(!sems[sem].freed);
  80d86f:	8b 55 08             	mov    0x8(%ebp),%edx
  80d872:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d875:	83 3c 85 80 5b b3 00 	cmpl   $0x0,0xb35b80(,%eax,4)
  80d87c:	00 
  80d87d:	74 24                	je     80d8a3 <sys_arch_sem_wait+0x3d>
  80d87f:	c7 44 24 0c 8f 40 81 	movl   $0x81408f,0xc(%esp)
  80d886:	00 
  80d887:	c7 44 24 08 20 2c 81 	movl   $0x812c20,0x8(%esp)
  80d88e:	00 
  80d88f:	c7 44 24 04 ad 00 00 	movl   $0xad,0x4(%esp)
  80d896:	00 
  80d897:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80d89e:	e8 45 31 ff ff       	call   8009e8 <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80d8a3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80d8a6:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80d8a9:	8b 04 85 84 5b b3 00 	mov    0xb35b84(,%eax,4),%eax
  80d8b0:	89 45 dc             	mov    %eax,-0x24(%ebp)

    while (tm_msec == 0 || waited < tm_msec) {
  80d8b3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80d8b7:	0f 94 45 d7          	sete   -0x29(%ebp)
  80d8bb:	0f 95 45 e3          	setne  -0x1d(%ebp)
  80d8bf:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80d8c3:	75 0a                	jne    80d8cf <sys_arch_sem_wait+0x69>
  80d8c5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80d8c9:	0f 84 d7 00 00 00    	je     80d9a6 <sys_arch_sem_wait+0x140>
	if (sems[sem].counter > 0) {
  80d8cf:	8b 55 08             	mov    0x8(%ebp),%edx
  80d8d2:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d8d5:	0f b7 04 85 88 5b b3 	movzwl 0xb35b88(,%eax,4),%eax
  80d8dc:	00 
  80d8dd:	bf 00 00 00 00       	mov    $0x0,%edi
  80d8e2:	66 85 c0             	test   %ax,%ax
  80d8e5:	75 17                	jne    80d8fe <sys_arch_sem_wait+0x98>
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80d8e7:	83 7d 0c fe          	cmpl   $0xfffffffe,0xc(%ebp)
  80d8eb:	75 27                	jne    80d914 <sys_arch_sem_wait+0xae>
  80d8ed:	e9 b4 00 00 00       	jmp    80d9a6 <sys_arch_sem_wait+0x140>
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80d8f2:	0f b7 83 88 5b b3 00 	movzwl 0xb35b88(%ebx),%eax
  80d8f9:	66 85 c0             	test   %ax,%ax
  80d8fc:	74 31                	je     80d92f <sys_arch_sem_wait+0xc9>
	    sems[sem].counter--;
  80d8fe:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80d901:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  80d904:	83 e8 01             	sub    $0x1,%eax
  80d907:	66 89 04 95 88 5b b3 	mov    %ax,0xb35b88(,%edx,4)
  80d90e:	00 
	    return waited;
  80d90f:	e9 97 00 00 00       	jmp    80d9ab <sys_arch_sem_wait+0x145>
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80d914:	8b 55 08             	mov    0x8(%ebp),%edx
  80d917:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d91a:	8d 04 85 88 5b b3 00 	lea    0xb35b88(,%eax,4),%eax
  80d921:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80d924:	bf 00 00 00 00       	mov    $0x0,%edi
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
  80d929:	8d 1c 92             	lea    (%edx,%edx,4),%ebx
  80d92c:	c1 e3 02             	shl    $0x2,%ebx
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80d92f:	e8 79 40 ff ff       	call   8019ad <sys_time_msec>
  80d934:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80d937:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80d93c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80d940:	74 08                	je     80d94a <sys_arch_sem_wait+0xe4>
  80d942:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80d945:	03 45 0c             	add    0xc(%ebp),%eax
  80d948:	29 f8                	sub    %edi,%eax
	    sems[sem].waiters = 1;
  80d94a:	be 80 5b b3 00       	mov    $0xb35b80,%esi
  80d94f:	66 c7 44 33 0a 01 00 	movw   $0x1,0xa(%ebx,%esi,1)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80d956:	89 44 24 08          	mov    %eax,0x8(%esp)
  80d95a:	8b 44 33 08          	mov    0x8(%ebx,%esi,1),%eax
  80d95e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d962:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80d965:	89 0c 24             	mov    %ecx,(%esp)
  80d968:	e8 d2 07 00 00       	call   80e13f <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80d96d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80d970:	39 44 33 04          	cmp    %eax,0x4(%ebx,%esi,1)
  80d974:	74 13                	je     80d989 <sys_arch_sem_wait+0x123>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80d976:	c7 04 24 a0 41 81 00 	movl   $0x8141a0,(%esp)
  80d97d:	e8 1f 31 ff ff       	call   800aa1 <cprintf>
  80d982:	bf ff ff ff ff       	mov    $0xffffffff,%edi
		return SYS_ARCH_TIMEOUT;
  80d987:	eb 22                	jmp    80d9ab <sys_arch_sem_wait+0x145>
	    }
	    uint32_t b = sys_time_msec();
  80d989:	e8 1f 40 ff ff       	call   8019ad <sys_time_msec>
	    waited += (b - a);
  80d98e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  80d991:	01 c7                	add    %eax,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80d993:	39 7d 0c             	cmp    %edi,0xc(%ebp)
  80d996:	0f 87 56 ff ff ff    	ja     80d8f2 <sys_arch_sem_wait+0x8c>
  80d99c:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80d9a0:	0f 85 4c ff ff ff    	jne    80d8f2 <sys_arch_sem_wait+0x8c>
  80d9a6:	bf ff ff ff ff       	mov    $0xffffffff,%edi
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80d9ab:	89 f8                	mov    %edi,%eax
  80d9ad:	83 c4 3c             	add    $0x3c,%esp
  80d9b0:	5b                   	pop    %ebx
  80d9b1:	5e                   	pop    %esi
  80d9b2:	5f                   	pop    %edi
  80d9b3:	5d                   	pop    %ebp
  80d9b4:	c3                   	ret    

0080d9b5 <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  80d9b5:	55                   	push   %ebp
  80d9b6:	89 e5                	mov    %esp,%ebp
  80d9b8:	53                   	push   %ebx
  80d9b9:	83 ec 14             	sub    $0x14,%esp
  80d9bc:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80d9c0:	a1 80 6f b3 00       	mov    0xb36f80,%eax
    if (!se) {
  80d9c5:	85 c0                	test   %eax,%eax
  80d9c7:	75 13                	jne    80d9dc <sys_sem_new+0x27>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80d9c9:	c7 04 24 cc 41 81 00 	movl   $0x8141cc,(%esp)
  80d9d0:	e8 cc 30 ff ff       	call   800aa1 <cprintf>
  80d9d5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	return SYS_SEM_NULL;
  80d9da:	eb 5d                	jmp    80da39 <sys_sem_new+0x84>
    }
    LIST_REMOVE(se, link);
  80d9dc:	8b 50 0c             	mov    0xc(%eax),%edx
  80d9df:	85 d2                	test   %edx,%edx
  80d9e1:	74 06                	je     80d9e9 <sys_sem_new+0x34>
  80d9e3:	8b 58 10             	mov    0x10(%eax),%ebx
  80d9e6:	89 5a 10             	mov    %ebx,0x10(%edx)
  80d9e9:	8b 50 10             	mov    0x10(%eax),%edx
  80d9ec:	8b 58 0c             	mov    0xc(%eax),%ebx
  80d9ef:	89 1a                	mov    %ebx,(%edx)
    assert(se->freed);
  80d9f1:	83 38 00             	cmpl   $0x0,(%eax)
  80d9f4:	75 24                	jne    80da1a <sys_sem_new+0x65>
  80d9f6:	c7 44 24 0c f9 40 81 	movl   $0x8140f9,0xc(%esp)
  80d9fd:	00 
  80d9fe:	c7 44 24 08 20 2c 81 	movl   $0x812c20,0x8(%esp)
  80da05:	00 
  80da06:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80da0d:	00 
  80da0e:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80da15:	e8 ce 2f ff ff       	call   8009e8 <_panic>
    se->freed = 0;
  80da1a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  80da20:	0f b6 c9             	movzbl %cl,%ecx
  80da23:	66 89 48 08          	mov    %cx,0x8(%eax)
    se->gen++;
  80da27:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  80da2b:	2d 80 5b b3 00       	sub    $0xb35b80,%eax
  80da30:	c1 f8 02             	sar    $0x2,%eax
  80da33:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  80da39:	83 c4 14             	add    $0x14,%esp
  80da3c:	5b                   	pop    %ebx
  80da3d:	5d                   	pop    %ebp
  80da3e:	c3                   	ret    

0080da3f <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  80da3f:	55                   	push   %ebp
  80da40:	89 e5                	mov    %esp,%ebp
  80da42:	56                   	push   %esi
  80da43:	53                   	push   %ebx
  80da44:	83 ec 10             	sub    $0x10,%esp
    assert(size < MBOXSLOTS);
  80da47:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80da4b:	7e 24                	jle    80da71 <sys_mbox_new+0x32>
  80da4d:	c7 44 24 0c 03 41 81 	movl   $0x814103,0xc(%esp)
  80da54:	00 
  80da55:	c7 44 24 08 20 2c 81 	movl   $0x812c20,0x8(%esp)
  80da5c:	00 
  80da5d:	c7 44 24 04 46 00 00 	movl   $0x46,0x4(%esp)
  80da64:	00 
  80da65:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80da6c:	e8 77 2f ff ff       	call   8009e8 <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80da71:	8b 1d a0 bd b3 00    	mov    0xb3bda0,%ebx
    if (!mbe) {
  80da77:	85 db                	test   %ebx,%ebx
  80da79:	75 16                	jne    80da91 <sys_mbox_new+0x52>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80da7b:	c7 04 24 f4 41 81 00 	movl   $0x8141f4,(%esp)
  80da82:	e8 1a 30 ff ff       	call   800aa1 <cprintf>
  80da87:	be ff ff ff ff       	mov    $0xffffffff,%esi
	return SYS_MBOX_NULL;
  80da8c:	e9 bd 00 00 00       	jmp    80db4e <sys_mbox_new+0x10f>
    }
    LIST_REMOVE(mbe, link);
  80da91:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80da97:	85 c0                	test   %eax,%eax
  80da99:	74 0c                	je     80daa7 <sys_mbox_new+0x68>
  80da9b:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80daa1:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80daa7:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80daad:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80dab3:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80dab5:	83 3b 00             	cmpl   $0x0,(%ebx)
  80dab8:	75 24                	jne    80dade <sys_mbox_new+0x9f>
  80daba:	c7 44 24 0c 14 41 81 	movl   $0x814114,0xc(%esp)
  80dac1:	00 
  80dac2:	c7 44 24 08 20 2c 81 	movl   $0x812c20,0x8(%esp)
  80dac9:	00 
  80daca:	c7 44 24 04 4d 00 00 	movl   $0x4d,0x4(%esp)
  80dad1:	00 
  80dad2:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80dad9:	e8 0a 2f ff ff       	call   8009e8 <_panic>
    mbe->freed = 0;
  80dade:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  80dae4:	89 de                	mov    %ebx,%esi
  80dae6:	81 ee a0 6f b3 00    	sub    $0xb36fa0,%esi
  80daec:	c1 fe 02             	sar    $0x2,%esi
  80daef:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
    mbe->head = -1;
  80daf5:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80dafc:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80db03:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80db0a:	e8 a6 fe ff ff       	call   80d9b5 <sys_sem_new>
  80db0f:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80db15:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80db1c:	e8 94 fe ff ff       	call   80d9b5 <sys_sem_new>
  80db21:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  80db27:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80db2e:	74 05                	je     80db35 <sys_mbox_new+0xf6>
  80db30:	83 f8 ff             	cmp    $0xffffffff,%eax
  80db33:	75 19                	jne    80db4e <sys_mbox_new+0x10f>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  80db35:	89 34 24             	mov    %esi,(%esp)
  80db38:	e8 48 fa ff ff       	call   80d585 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80db3d:	c7 04 24 1c 42 81 00 	movl   $0x81421c,(%esp)
  80db44:	e8 58 2f ff ff       	call   800aa1 <cprintf>
  80db49:	be ff ff ff ff       	mov    $0xffffffff,%esi
	return SYS_MBOX_NULL;
    }
    return i;
}
  80db4e:	89 f0                	mov    %esi,%eax
  80db50:	83 c4 10             	add    $0x10,%esp
  80db53:	5b                   	pop    %ebx
  80db54:	5e                   	pop    %esi
  80db55:	5d                   	pop    %ebp
  80db56:	c3                   	ret    

0080db57 <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  80db57:	55                   	push   %ebp
  80db58:	89 e5                	mov    %esp,%ebp
  80db5a:	53                   	push   %ebx
  80db5b:	83 ec 14             	sub    $0x14,%esp
  80db5e:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80db61:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80db64:	83 3c 95 80 5b b3 00 	cmpl   $0x0,0xb35b80(,%edx,4)
  80db6b:	00 
  80db6c:	74 24                	je     80db92 <sys_sem_signal+0x3b>
  80db6e:	c7 44 24 0c 8f 40 81 	movl   $0x81408f,0xc(%esp)
  80db75:	00 
  80db76:	c7 44 24 08 20 2c 81 	movl   $0x812c20,0x8(%esp)
  80db7d:	00 
  80db7e:	c7 44 24 04 a2 00 00 	movl   $0xa2,0x4(%esp)
  80db85:	00 
  80db86:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80db8d:	e8 56 2e ff ff       	call   8009e8 <_panic>
    sems[sem].counter++;
  80db92:	ba 80 5b b3 00       	mov    $0xb35b80,%edx
  80db97:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  80db9e:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
  80dba1:	66 83 44 9a 08 01    	addw   $0x1,0x8(%edx,%ebx,4)
    if (sems[sem].waiters) {
  80dba7:	66 83 7c 9a 0a 00    	cmpw   $0x0,0xa(%edx,%ebx,4)
  80dbad:	74 19                	je     80dbc8 <sys_sem_signal+0x71>
	sems[sem].waiters = 0;
  80dbaf:	66 c7 04 9d 8a 5b b3 	movw   $0x0,0xb35b8a(,%ebx,4)
  80dbb6:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80dbb9:	8d 04 9d 88 5b b3 00 	lea    0xb35b88(,%ebx,4),%eax
  80dbc0:	89 04 24             	mov    %eax,(%esp)
  80dbc3:	e8 77 02 00 00       	call   80de3f <thread_wakeup>
    }
}
  80dbc8:	83 c4 14             	add    $0x14,%esp
  80dbcb:	5b                   	pop    %ebx
  80dbcc:	5d                   	pop    %ebp
  80dbcd:	c3                   	ret    

0080dbce <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80dbce:	55                   	push   %ebp
  80dbcf:	89 e5                	mov    %esp,%ebp
  80dbd1:	83 ec 28             	sub    $0x28,%esp
  80dbd4:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80dbd7:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80dbda:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80dbdd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dbe0:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80dbe3:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80dbe9:	83 b8 a0 6f b3 00 00 	cmpl   $0x0,0xb36fa0(%eax)
  80dbf0:	74 24                	je     80dc16 <sys_arch_mbox_fetch+0x48>
  80dbf2:	c7 44 24 0c bd 40 81 	movl   $0x8140bd,0xc(%esp)
  80dbf9:	00 
  80dbfa:	c7 44 24 08 20 2c 81 	movl   $0x812c20,0x8(%esp)
  80dc01:	00 
  80dc02:	c7 44 24 04 cf 00 00 	movl   $0xcf,0x4(%esp)
  80dc09:	00 
  80dc0a:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80dc11:	e8 d2 2d ff ff       	call   8009e8 <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80dc16:	8b 45 10             	mov    0x10(%ebp),%eax
  80dc19:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dc1d:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80dc23:	8b 80 2c 70 b3 00    	mov    0xb3702c(%eax),%eax
  80dc29:	89 04 24             	mov    %eax,(%esp)
  80dc2c:	e8 35 fc ff ff       	call   80d866 <sys_arch_sem_wait>
  80dc31:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80dc33:	83 f8 ff             	cmp    $0xffffffff,%eax
  80dc36:	0f 84 85 00 00 00    	je     80dcc1 <sys_arch_mbox_fetch+0xf3>
	return waited;

    int slot = mboxes[mbox].head;
  80dc3c:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80dc42:	8b 80 a4 6f b3 00    	mov    0xb36fa4(%eax),%eax
    if (slot == -1)
  80dc48:	83 f8 ff             	cmp    $0xffffffff,%eax
  80dc4b:	75 1c                	jne    80dc69 <sys_arch_mbox_fetch+0x9b>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80dc4d:	c7 44 24 08 48 42 81 	movl   $0x814248,0x8(%esp)
  80dc54:	00 
  80dc55:	c7 44 24 04 d7 00 00 	movl   $0xd7,0x4(%esp)
  80dc5c:	00 
  80dc5d:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80dc64:	e8 7f 2d ff ff       	call   8009e8 <_panic>
    if (msg)
  80dc69:	85 ff                	test   %edi,%edi
  80dc6b:	74 0e                	je     80dc7b <sys_arch_mbox_fetch+0xad>
	*msg = mboxes[mbox].msg[slot];
  80dc6d:	6b d3 27             	imul   $0x27,%ebx,%edx
  80dc70:	01 c2                	add    %eax,%edx
  80dc72:	8b 14 95 ac 6f b3 00 	mov    0xb36fac(,%edx,4),%edx
  80dc79:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80dc7b:	8d 48 01             	lea    0x1(%eax),%ecx
  80dc7e:	89 ca                	mov    %ecx,%edx
  80dc80:	c1 fa 1f             	sar    $0x1f,%edx
  80dc83:	c1 ea 1b             	shr    $0x1b,%edx
  80dc86:	8d 04 11             	lea    (%ecx,%edx,1),%eax
  80dc89:	83 e0 1f             	and    $0x1f,%eax
  80dc8c:	29 d0                	sub    %edx,%eax
  80dc8e:	ba a0 6f b3 00       	mov    $0xb36fa0,%edx
  80dc93:	69 cb 9c 00 00 00    	imul   $0x9c,%ebx,%ecx
  80dc99:	89 44 11 04          	mov    %eax,0x4(%ecx,%edx,1)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80dc9d:	3b 44 11 08          	cmp    0x8(%ecx,%edx,1),%eax
  80dca1:	75 0a                	jne    80dcad <sys_arch_mbox_fetch+0xdf>
	mboxes[mbox].head = -1;
  80dca3:	c7 81 a4 6f b3 00 ff 	movl   $0xffffffff,0xb36fa4(%ecx)
  80dcaa:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80dcad:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80dcb3:	8b 83 30 70 b3 00    	mov    0xb37030(%ebx),%eax
  80dcb9:	89 04 24             	mov    %eax,(%esp)
  80dcbc:	e8 96 fe ff ff       	call   80db57 <sys_sem_signal>
    return waited;
}
  80dcc1:	89 f0                	mov    %esi,%eax
  80dcc3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80dcc6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80dcc9:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80dccc:	89 ec                	mov    %ebp,%esp
  80dcce:	5d                   	pop    %ebp
  80dccf:	c3                   	ret    

0080dcd0 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80dcd0:	55                   	push   %ebp
  80dcd1:	89 e5                	mov    %esp,%ebp
  80dcd3:	83 ec 18             	sub    $0x18,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80dcd6:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
  80dcdd:	ff 
  80dcde:	8b 45 0c             	mov    0xc(%ebp),%eax
  80dce1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dce5:	8b 45 08             	mov    0x8(%ebp),%eax
  80dce8:	89 04 24             	mov    %eax,(%esp)
  80dceb:	e8 de fe ff ff       	call   80dbce <sys_arch_mbox_fetch>
}
  80dcf0:	c9                   	leave  
  80dcf1:	c3                   	ret    

0080dcf2 <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80dcf2:	55                   	push   %ebp
  80dcf3:	89 e5                	mov    %esp,%ebp
  80dcf5:	83 ec 28             	sub    $0x28,%esp
  80dcf8:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80dcfb:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80dcfe:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80dd01:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80dd04:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80dd0a:	83 b8 a0 6f b3 00 00 	cmpl   $0x0,0xb36fa0(%eax)
  80dd11:	74 24                	je     80dd37 <sys_mbox_trypost+0x45>
  80dd13:	c7 44 24 0c bd 40 81 	movl   $0x8140bd,0xc(%esp)
  80dd1a:	00 
  80dd1b:	c7 44 24 08 20 2c 81 	movl   $0x812c20,0x8(%esp)
  80dd22:	00 
  80dd23:	c7 44 24 04 73 00 00 	movl   $0x73,0x4(%esp)
  80dd2a:	00 
  80dd2b:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80dd32:	e8 b1 2c ff ff       	call   8009e8 <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80dd37:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80dd3e:	00 
  80dd3f:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80dd45:	8b 83 30 70 b3 00    	mov    0xb37030(%ebx),%eax
  80dd4b:	89 04 24             	mov    %eax,(%esp)
  80dd4e:	e8 13 fb ff ff       	call   80d866 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80dd53:	b9 a0 6f b3 00       	mov    $0xb36fa0,%ecx
  80dd58:	8b 54 0b 08          	mov    0x8(%ebx,%ecx,1),%edx
  80dd5c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80dd61:	3b 54 0b 04          	cmp    0x4(%ebx,%ecx,1),%edx
  80dd65:	74 4c                	je     80ddb3 <sys_mbox_trypost+0xc1>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80dd67:	89 c8                	mov    %ecx,%eax
  80dd69:	89 d9                	mov    %ebx,%ecx
  80dd6b:	8d 7a 01             	lea    0x1(%edx),%edi
  80dd6e:	89 fb                	mov    %edi,%ebx
  80dd70:	c1 fb 1f             	sar    $0x1f,%ebx
  80dd73:	c1 eb 1b             	shr    $0x1b,%ebx
  80dd76:	01 df                	add    %ebx,%edi
  80dd78:	83 e7 1f             	and    $0x1f,%edi
  80dd7b:	29 df                	sub    %ebx,%edi
  80dd7d:	89 7c 01 08          	mov    %edi,0x8(%ecx,%eax,1)
    mboxes[mbox].msg[slot] = msg;
  80dd81:	6b de 27             	imul   $0x27,%esi,%ebx
  80dd84:	01 d3                	add    %edx,%ebx
  80dd86:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80dd89:	89 7c 98 0c          	mov    %edi,0xc(%eax,%ebx,4)

    if (mboxes[mbox].head == -1)
  80dd8d:	83 7c 01 04 ff       	cmpl   $0xffffffff,0x4(%ecx,%eax,1)
  80dd92:	75 06                	jne    80dd9a <sys_mbox_trypost+0xa8>
	mboxes[mbox].head = slot;
  80dd94:	89 91 a4 6f b3 00    	mov    %edx,0xb36fa4(%ecx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80dd9a:	69 f6 9c 00 00 00    	imul   $0x9c,%esi,%esi
  80dda0:	8b 86 2c 70 b3 00    	mov    0xb3702c(%esi),%eax
  80dda6:	89 04 24             	mov    %eax,(%esp)
  80dda9:	e8 a9 fd ff ff       	call   80db57 <sys_sem_signal>
  80ddae:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
}
  80ddb3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ddb6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ddb9:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ddbc:	89 ec                	mov    %ebp,%esp
  80ddbe:	5d                   	pop    %ebp
  80ddbf:	c3                   	ret    

0080ddc0 <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80ddc0:	55                   	push   %ebp
  80ddc1:	89 e5                	mov    %esp,%ebp
  80ddc3:	83 ec 18             	sub    $0x18,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80ddc6:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ddc9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ddcd:	8b 45 08             	mov    0x8(%ebp),%eax
  80ddd0:	89 04 24             	mov    %eax,(%esp)
  80ddd3:	e8 1a ff ff ff       	call   80dcf2 <sys_mbox_trypost>
  80ddd8:	84 c0                	test   %al,%al
  80ddda:	74 24                	je     80de00 <sys_mbox_post+0x40>
  80dddc:	c7 44 24 0c 70 42 81 	movl   $0x814270,0xc(%esp)
  80dde3:	00 
  80dde4:	c7 44 24 08 20 2c 81 	movl   $0x812c20,0x8(%esp)
  80ddeb:	00 
  80ddec:	c7 44 24 04 6d 00 00 	movl   $0x6d,0x4(%esp)
  80ddf3:	00 
  80ddf4:	c7 04 24 a0 40 81 00 	movl   $0x8140a0,(%esp)
  80ddfb:	e8 e8 2b ff ff       	call   8009e8 <_panic>
}
  80de00:	c9                   	leave  
  80de01:	c3                   	ret    
	...

0080de10 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80de10:	55                   	push   %ebp
  80de11:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80de13:	c7 05 cc c1 b3 00 00 	movl   $0x0,0xb3c1cc
  80de1a:	00 00 00 
    tq->tq_last = 0;
  80de1d:	c7 05 d0 c1 b3 00 00 	movl   $0x0,0xb3c1d0
  80de24:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80de27:	c7 05 c4 c1 b3 00 00 	movl   $0x0,0xb3c1c4
  80de2e:	00 00 00 
}
  80de31:	5d                   	pop    %ebp
  80de32:	c3                   	ret    

0080de33 <thread_id>:

uint32_t
thread_id(void) {
  80de33:	55                   	push   %ebp
  80de34:	89 e5                	mov    %esp,%ebp
  80de36:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80de3b:	8b 00                	mov    (%eax),%eax
    return cur_tc->tc_tid;
}
  80de3d:	5d                   	pop    %ebp
  80de3e:	c3                   	ret    

0080de3f <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80de3f:	55                   	push   %ebp
  80de40:	89 e5                	mov    %esp,%ebp
  80de42:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80de45:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
    while (tc) {
  80de4a:	85 c0                	test   %eax,%eax
  80de4c:	74 10                	je     80de5e <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
  80de4e:	39 50 48             	cmp    %edx,0x48(%eax)
  80de51:	75 04                	jne    80de57 <thread_wakeup+0x18>
	    tc->tc_wakeup = 1;
  80de53:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80de57:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80de5a:	85 c0                	test   %eax,%eax
  80de5c:	75 f0                	jne    80de4e <thread_wakeup+0xf>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80de5e:	5d                   	pop    %ebp
  80de5f:	90                   	nop
  80de60:	c3                   	ret    

0080de61 <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80de61:	55                   	push   %ebp
  80de62:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80de64:	8b 15 cc c1 b3 00    	mov    0xb3c1cc,%edx
    int n = 0;
    while (tc) {
  80de6a:	b8 00 00 00 00       	mov    $0x0,%eax
  80de6f:	85 d2                	test   %edx,%edx
  80de71:	74 11                	je     80de84 <thread_wakeups_pending+0x23>
	if (tc->tc_wakeup)
  80de73:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80de77:	80 f9 01             	cmp    $0x1,%cl
  80de7a:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80de7d:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80de80:	85 d2                	test   %edx,%edx
  80de82:	75 ef                	jne    80de73 <thread_wakeups_pending+0x12>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80de84:	5d                   	pop    %ebp
  80de85:	c3                   	ret    

0080de86 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80de86:	55                   	push   %ebp
  80de87:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80de89:	8b 15 c8 c1 b3 00    	mov    0xb3c1c8,%edx
  80de8f:	8b 4a 60             	mov    0x60(%edx),%ecx
  80de92:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80de97:	83 f9 03             	cmp    $0x3,%ecx
  80de9a:	7f 12                	jg     80deae <thread_onhalt+0x28>
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80de9c:	8b 45 08             	mov    0x8(%ebp),%eax
  80de9f:	89 44 8a 50          	mov    %eax,0x50(%edx,%ecx,4)
  80dea3:	83 c1 01             	add    $0x1,%ecx
  80dea6:	89 4a 60             	mov    %ecx,0x60(%edx)
  80dea9:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
}
  80deae:	5d                   	pop    %ebp
  80deaf:	c3                   	ret    

0080deb0 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80deb0:	55                   	push   %ebp
  80deb1:	89 e5                	mov    %esp,%ebp
  80deb3:	53                   	push   %ebx
  80deb4:	83 ec 14             	sub    $0x14,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80deb7:	8b 1d cc c1 b3 00    	mov    0xb3c1cc,%ebx
  80debd:	85 db                	test   %ebx,%ebx
  80debf:	74 69                	je     80df2a <thread_yield+0x7a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80dec1:	8b 43 64             	mov    0x64(%ebx),%eax
  80dec4:	a3 cc c1 b3 00       	mov    %eax,0xb3c1cc
    tc->tc_queue_link = 0;
  80dec9:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80ded0:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80ded5:	85 c0                	test   %eax,%eax
  80ded7:	74 3e                	je     80df17 <thread_yield+0x67>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80ded9:	83 c0 30             	add    $0x30,%eax
  80dedc:	89 04 24             	mov    %eax,(%esp)
  80dedf:	e8 cc 02 00 00       	call   80e1b0 <jos_setjmp>
  80dee4:	85 c0                	test   %eax,%eax
  80dee6:	75 42                	jne    80df2a <thread_yield+0x7a>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80dee8:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80deed:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80def4:	83 3d cc c1 b3 00 00 	cmpl   $0x0,0xb3c1cc
  80defb:	75 0c                	jne    80df09 <thread_yield+0x59>
	tq->tq_first = tc;
  80defd:	a3 cc c1 b3 00       	mov    %eax,0xb3c1cc
	tq->tq_last = tc;
  80df02:	a3 d0 c1 b3 00       	mov    %eax,0xb3c1d0
  80df07:	eb 0e                	jmp    80df17 <thread_yield+0x67>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80df09:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
  80df0f:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80df12:	a3 d0 c1 b3 00       	mov    %eax,0xb3c1d0
    }

    cur_tc = next_tc;
  80df17:	89 1d c8 c1 b3 00    	mov    %ebx,0xb3c1c8
    jos_longjmp(&cur_tc->tc_jb, 1);
  80df1d:	8d 43 30             	lea    0x30(%ebx),%eax
  80df20:	ba 01 00 00 00       	mov    $0x1,%edx
  80df25:	e8 b6 02 00 00       	call   80e1e0 <jos_longjmp>
}
  80df2a:	83 c4 14             	add    $0x14,%esp
  80df2d:	5b                   	pop    %ebx
  80df2e:	5d                   	pop    %ebp
  80df2f:	c3                   	ret    

0080df30 <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80df30:	55                   	push   %ebp
  80df31:	89 e5                	mov    %esp,%ebp
  80df33:	56                   	push   %esi
  80df34:	53                   	push   %ebx
  80df35:	83 ec 10             	sub    $0x10,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80df38:	8b 1d d4 c1 b3 00    	mov    0xb3c1d4,%ebx
  80df3e:	85 db                	test   %ebx,%ebx
  80df40:	0f 84 88 00 00 00    	je     80dfce <thread_halt+0x9e>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80df46:	8b 43 64             	mov    0x64(%ebx),%eax
  80df49:	a3 d4 c1 b3 00       	mov    %eax,0xb3c1d4
    tc->tc_queue_link = 0;
  80df4e:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80df55:	83 7b 60 00          	cmpl   $0x0,0x60(%ebx)
  80df59:	7e 16                	jle    80df71 <thread_halt+0x41>
  80df5b:	be 00 00 00 00       	mov    $0x0,%esi
	tc->tc_onhalt[i](tc->tc_tid);
  80df60:	8b 03                	mov    (%ebx),%eax
  80df62:	89 04 24             	mov    %eax,(%esp)
  80df65:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80df69:	83 c6 01             	add    $0x1,%esi
  80df6c:	3b 73 60             	cmp    0x60(%ebx),%esi
  80df6f:	7c ef                	jl     80df60 <thread_halt+0x30>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80df71:	8b 43 04             	mov    0x4(%ebx),%eax
  80df74:	89 04 24             	mov    %eax,(%esp)
  80df77:	e8 e4 51 ff ff       	call   803160 <free>
    free(tc);
  80df7c:	89 1c 24             	mov    %ebx,(%esp)
  80df7f:	e8 dc 51 ff ff       	call   803160 <free>
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80df84:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80df89:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80df90:	83 3d d4 c1 b3 00 00 	cmpl   $0x0,0xb3c1d4
  80df97:	75 0c                	jne    80dfa5 <thread_halt+0x75>
	tq->tq_first = tc;
  80df99:	a3 d4 c1 b3 00       	mov    %eax,0xb3c1d4
	tq->tq_last = tc;
  80df9e:	a3 d8 c1 b3 00       	mov    %eax,0xb3c1d8
  80dfa3:	eb 0e                	jmp    80dfb3 <thread_halt+0x83>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80dfa5:	8b 15 d8 c1 b3 00    	mov    0xb3c1d8,%edx
  80dfab:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80dfae:	a3 d8 c1 b3 00       	mov    %eax,0xb3c1d8
    cur_tc = NULL;
  80dfb3:	c7 05 c8 c1 b3 00 00 	movl   $0x0,0xb3c1c8
  80dfba:	00 00 00 
    thread_yield();
  80dfbd:	e8 ee fe ff ff       	call   80deb0 <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80dfc2:	e8 05 2a ff ff       	call   8009cc <exit>
}
  80dfc7:	83 c4 10             	add    $0x10,%esp
  80dfca:	5b                   	pop    %ebx
  80dfcb:	5e                   	pop    %esi
  80dfcc:	5d                   	pop    %ebp
  80dfcd:	c3                   	ret    
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80dfce:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80dfd3:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
  80dfda:	eb bd                	jmp    80df99 <thread_halt+0x69>

0080dfdc <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80dfdc:	55                   	push   %ebp
  80dfdd:	89 e5                	mov    %esp,%ebp
  80dfdf:	83 ec 18             	sub    $0x18,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80dfe2:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80dfe7:	8b 50 2c             	mov    0x2c(%eax),%edx
  80dfea:	89 14 24             	mov    %edx,(%esp)
  80dfed:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80dff0:	e8 3b ff ff ff       	call   80df30 <thread_halt>
}
  80dff5:	c9                   	leave  
  80dff6:	c3                   	ret    

0080dff7 <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80dff7:	55                   	push   %ebp
  80dff8:	89 e5                	mov    %esp,%ebp
  80dffa:	57                   	push   %edi
  80dffb:	56                   	push   %esi
  80dffc:	53                   	push   %ebx
  80dffd:	83 ec 1c             	sub    $0x1c,%esp
  80e000:	8b 7d 08             	mov    0x8(%ebp),%edi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80e003:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp)
  80e00a:	e8 24 52 ff ff       	call   803233 <malloc>
  80e00f:	89 c3                	mov    %eax,%ebx
    if (!tc)
  80e011:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80e016:	85 db                	test   %ebx,%ebx
  80e018:	0f 84 19 01 00 00    	je     80e137 <thread_create+0x140>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80e01e:	c7 44 24 08 68 00 00 	movl   $0x68,0x8(%esp)
  80e025:	00 
  80e026:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e02d:	00 
  80e02e:	89 1c 24             	mov    %ebx,(%esp)
  80e031:	e8 20 35 ff ff       	call   801556 <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80e036:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
  80e03d:	00 
  80e03e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e041:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e045:	8d 43 08             	lea    0x8(%ebx),%eax
  80e048:	89 04 24             	mov    %eax,(%esp)
  80e04b:	e8 c6 33 ff ff       	call   801416 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80e050:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80e054:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e059:	8d 50 01             	lea    0x1(%eax),%edx
  80e05c:	89 15 c4 c1 b3 00    	mov    %edx,0xb3c1c4
    if (max_tid == (uint32_t)~0)
  80e062:	83 fa ff             	cmp    $0xffffffff,%edx
  80e065:	75 1c                	jne    80e083 <thread_create+0x8c>
	panic("alloc_tid: no more thread ids");
  80e067:	c7 44 24 08 96 42 81 	movl   $0x814296,0x8(%esp)
  80e06e:	00 
  80e06f:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80e076:	00 
  80e077:	c7 04 24 b4 42 81 00 	movl   $0x8142b4,(%esp)
  80e07e:	e8 65 29 ff ff       	call   8009e8 <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80e083:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80e085:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  80e08c:	e8 a2 51 ff ff       	call   803233 <malloc>
  80e091:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80e094:	85 c0                	test   %eax,%eax
  80e096:	75 12                	jne    80e0aa <thread_create+0xb3>
	free(tc);
  80e098:	89 1c 24             	mov    %ebx,(%esp)
  80e09b:	e8 c0 50 ff ff       	call   803160 <free>
  80e0a0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
	return -E_NO_MEM;
  80e0a5:	e9 8d 00 00 00       	jmp    80e137 <thread_create+0x140>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80e0aa:	8d b0 fc 0f 00 00    	lea    0xffc(%eax),%esi
    memset(stacktop, 0, 4);
  80e0b0:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80e0b7:	00 
  80e0b8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e0bf:	00 
  80e0c0:	89 34 24             	mov    %esi,(%esp)
  80e0c3:	e8 8e 34 ff ff       	call   801556 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80e0c8:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  80e0cf:	00 
  80e0d0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e0d7:	00 
  80e0d8:	8d 43 30             	lea    0x30(%ebx),%eax
  80e0db:	89 04 24             	mov    %eax,(%esp)
  80e0de:	e8 73 34 ff ff       	call   801556 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80e0e3:	89 73 34             	mov    %esi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80e0e6:	c7 43 30 dc df 80 00 	movl   $0x80dfdc,0x30(%ebx)
    tc->tc_entry = entry;
  80e0ed:	8b 45 10             	mov    0x10(%ebp),%eax
  80e0f0:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80e0f3:	8b 45 14             	mov    0x14(%ebp),%eax
  80e0f6:	89 43 2c             	mov    %eax,0x2c(%ebx)
  80e0f9:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80e100:	83 3d cc c1 b3 00 00 	cmpl   $0x0,0xb3c1cc
  80e107:	75 0e                	jne    80e117 <thread_create+0x120>
	tq->tq_first = tc;
  80e109:	89 1d cc c1 b3 00    	mov    %ebx,0xb3c1cc
	tq->tq_last = tc;
  80e10f:	89 1d d0 c1 b3 00    	mov    %ebx,0xb3c1d0
  80e115:	eb 0e                	jmp    80e125 <thread_create+0x12e>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80e117:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80e11c:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80e11f:	89 1d d0 c1 b3 00    	mov    %ebx,0xb3c1d0

    threadq_push(&thread_queue, tc);

    if (tid)
  80e125:	b8 00 00 00 00       	mov    $0x0,%eax
  80e12a:	85 ff                	test   %edi,%edi
  80e12c:	74 09                	je     80e137 <thread_create+0x140>
	*tid = tc->tc_tid;
  80e12e:	8b 03                	mov    (%ebx),%eax
  80e130:	89 07                	mov    %eax,(%edi)
  80e132:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
}
  80e137:	83 c4 1c             	add    $0x1c,%esp
  80e13a:	5b                   	pop    %ebx
  80e13b:	5e                   	pop    %esi
  80e13c:	5f                   	pop    %edi
  80e13d:	5d                   	pop    %ebp
  80e13e:	c3                   	ret    

0080e13f <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80e13f:	55                   	push   %ebp
  80e140:	89 e5                	mov    %esp,%ebp
  80e142:	57                   	push   %edi
  80e143:	56                   	push   %esi
  80e144:	53                   	push   %ebx
  80e145:	83 ec 0c             	sub    $0xc,%esp
  80e148:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e14b:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80e14e:	e8 5a 38 ff ff       	call   8019ad <sys_time_msec>
  80e153:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80e155:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80e15a:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80e15d:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)

    while (p < msec) {
  80e161:	39 fe                	cmp    %edi,%esi
  80e163:	72 06                	jb     80e16b <thread_wait+0x2c>
  80e165:	eb 2d                	jmp    80e194 <thread_wait+0x55>
	if (p < s)
  80e167:	39 c6                	cmp    %eax,%esi
  80e169:	77 29                	ja     80e194 <thread_wait+0x55>
	    break;
	if (addr && *addr != val)
  80e16b:	85 db                	test   %ebx,%ebx
  80e16d:	8d 76 00             	lea    0x0(%esi),%esi
  80e170:	74 07                	je     80e179 <thread_wait+0x3a>
  80e172:	8b 03                	mov    (%ebx),%eax
  80e174:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80e177:	75 1b                	jne    80e194 <thread_wait+0x55>
	    break;
	if (cur_tc->tc_wakeup)
  80e179:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80e17e:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80e182:	84 c0                	test   %al,%al
  80e184:	75 0e                	jne    80e194 <thread_wait+0x55>
	    break;

	thread_yield();
  80e186:	e8 25 fd ff ff       	call   80deb0 <thread_yield>
	p = sys_time_msec();
  80e18b:	e8 1d 38 ff ff       	call   8019ad <sys_time_msec>
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80e190:	39 c7                	cmp    %eax,%edi
  80e192:	77 d3                	ja     80e167 <thread_wait+0x28>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80e194:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80e199:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80e1a0:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80e1a4:	83 c4 0c             	add    $0xc,%esp
  80e1a7:	5b                   	pop    %ebx
  80e1a8:	5e                   	pop    %esi
  80e1a9:	5f                   	pop    %edi
  80e1aa:	5d                   	pop    %ebp
  80e1ab:	c3                   	ret    
  80e1ac:	00 00                	add    %al,(%eax)
	...

0080e1b0 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80e1b0:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80e1b4:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80e1b7:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80e1b9:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80e1bd:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80e1c0:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80e1c3:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80e1c6:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80e1c9:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80e1cc:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80e1d1:	c3                   	ret    
  80e1d2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80e1d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080e1e0 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80e1e0:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80e1e2:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80e1e5:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80e1e8:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80e1eb:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80e1ee:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80e1f1:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80e1f3:	ff e1                	jmp    *%ecx
  80e1f5:	00 00                	add    %al,(%eax)
	...

0080e1f8 <e2s>:
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
  80e1f8:	55                   	push   %ebp
  80e1f9:	89 e5                	mov    %esp,%ebp
  80e1fb:	8b 45 08             	mov    0x8(%ebp),%eax
  80e1fe:	8b 04 85 60 50 81 00 	mov    0x815060(,%eax,4),%eax
	return sys_errlist[err];
}
  80e205:	5d                   	pop    %ebp
  80e206:	c3                   	ret    

0080e207 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80e207:	55                   	push   %ebp
  80e208:	89 e5                	mov    %esp,%ebp
  80e20a:	83 ec 18             	sub    $0x18,%esp
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80e20d:	a1 20 c2 b3 00       	mov    0xb3c220,%eax
  80e212:	89 04 24             	mov    %eax,(%esp)
  80e215:	e8 de ff ff ff       	call   80e1f8 <e2s>
  80e21a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e21e:	8b 45 08             	mov    0x8(%ebp),%eax
  80e221:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e225:	c7 04 24 cf 42 81 00 	movl   $0x8142cf,(%esp)
  80e22c:	e8 70 28 ff ff       	call   800aa1 <cprintf>
}
  80e231:	c9                   	leave  
  80e232:	c3                   	ret    
	...

0080e240 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80e240:	55                   	push   %ebp
  80e241:	89 e5                	mov    %esp,%ebp
  80e243:	83 ec 38             	sub    $0x38,%esp
  80e246:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80e249:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80e24c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80e24f:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80e252:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80e259:	e8 82 8e ff ff       	call   8070e0 <mem_malloc>
  80e25e:	89 c6                	mov    %eax,%esi

    if (jif == NULL) {
  80e260:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80e265:	85 f6                	test   %esi,%esi
  80e267:	74 7a                	je     80e2e3 <jif_init+0xa3>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80e269:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80e26c:	89 73 1c             	mov    %esi,0x1c(%ebx)
    netif->output = jif_output;
  80e26f:	c7 43 14 05 e4 80 00 	movl   $0x80e405,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80e276:	c7 43 18 f0 e2 80 00 	movl   $0x80e2f0,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80e27d:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80e284:	00 
  80e285:	c7 44 24 04 53 2c 81 	movl   $0x812c53,0x4(%esp)
  80e28c:	00 
  80e28d:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80e290:	89 04 24             	mov    %eax,(%esp)
  80e293:	e8 99 33 ff ff       	call   801631 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80e298:	8d 43 25             	lea    0x25(%ebx),%eax
  80e29b:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80e29d:	8b 17                	mov    (%edi),%edx
  80e29f:	89 56 04             	mov    %edx,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80e2a2:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80e2a6:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80e2ac:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)
    netif->hwaddr[1] = 0x54;
    netif->hwaddr[2] = 0x00;
    netif->hwaddr[3] = 0x12;
    netif->hwaddr[4] = 0x34;
    netif->hwaddr[5] = 0x56;*/
    sys_get_mac(netif->hwaddr);
  80e2b0:	89 04 24             	mov    %eax,(%esp)
  80e2b3:	e8 83 35 ff ff       	call   80183b <sys_get_mac>
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80e2b8:	c7 04 24 8c 24 81 00 	movl   $0x81248c,(%esp)
  80e2bf:	e8 d4 cb ff ff       	call   80ae98 <inet_addr>
  80e2c4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80e2c7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e2ce:	00 
  80e2cf:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e2d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e2d6:	89 1c 24             	mov    %ebx,(%esp)
  80e2d9:	e8 59 e9 ff ff       	call   80cc37 <etharp_query>
  80e2de:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
}
  80e2e3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80e2e6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80e2e9:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80e2ec:	89 ec                	mov    %ebp,%esp
  80e2ee:	5d                   	pop    %ebp
  80e2ef:	c3                   	ret    

0080e2f0 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80e2f0:	55                   	push   %ebp
  80e2f1:	89 e5                	mov    %esp,%ebp
  80e2f3:	57                   	push   %edi
  80e2f4:	56                   	push   %esi
  80e2f5:	53                   	push   %ebx
  80e2f6:	83 ec 2c             	sub    $0x2c,%esp
  80e2f9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80e2fc:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80e303:	00 
  80e304:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80e30b:	10 
  80e30c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e313:	e8 e0 39 ff ff       	call   801cf8 <sys_page_alloc>
    if (r < 0)
  80e318:	85 c0                	test   %eax,%eax
  80e31a:	79 1c                	jns    80e338 <low_level_output+0x48>
	panic("jif: could not allocate page of memory");
  80e31c:	c7 44 24 08 c8 47 81 	movl   $0x8147c8,0x8(%esp)
  80e323:	00 
  80e324:	c7 44 24 04 56 00 00 	movl   $0x56,0x4(%esp)
  80e32b:	00 
  80e32c:	c7 04 24 b1 47 81 00 	movl   $0x8147b1,(%esp)
  80e333:	e8 b0 26 ff ff       	call   8009e8 <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80e338:	8b 45 08             	mov    0x8(%ebp),%eax
  80e33b:	8b 78 1c             	mov    0x1c(%eax),%edi

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80e33e:	be 00 00 00 00       	mov    $0x0,%esi
  80e343:	85 db                	test   %ebx,%ebx
  80e345:	74 74                	je     80e3bb <low_level_output+0xcb>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80e347:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e34b:	0f b7 d0             	movzwl %ax,%edx
  80e34e:	81 fa d0 07 00 00    	cmp    $0x7d0,%edx
  80e354:	7e 38                	jle    80e38e <low_level_output+0x9e>
  80e356:	eb 12                	jmp    80e36a <low_level_output+0x7a>
  80e358:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e35c:	0f b7 d0             	movzwl %ax,%edx
  80e35f:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
  80e362:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80e368:	7e 29                	jle    80e393 <low_level_output+0xa3>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80e36a:	89 74 24 10          	mov    %esi,0x10(%esp)
  80e36e:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e372:	c7 44 24 08 f0 47 81 	movl   $0x8147f0,0x8(%esp)
  80e379:	00 
  80e37a:	c7 44 24 04 65 00 00 	movl   $0x65,0x4(%esp)
  80e381:	00 
  80e382:	c7 04 24 b1 47 81 00 	movl   $0x8147b1,(%esp)
  80e389:	e8 5a 26 ff ff       	call   8009e8 <_panic>
  80e38e:	be 00 00 00 00       	mov    $0x0,%esi
	memcpy(&txbuf[txsize], q->payload, q->len);
  80e393:	8d 96 04 00 00 10    	lea    0x10000004(%esi),%edx
  80e399:	0f b7 c0             	movzwl %ax,%eax
  80e39c:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e3a0:	8b 43 04             	mov    0x4(%ebx),%eax
  80e3a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e3a7:	89 14 24             	mov    %edx,(%esp)
  80e3aa:	e8 82 32 ff ff       	call   801631 <memcpy>
	txsize += q->len;
  80e3af:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e3b3:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80e3b5:	8b 1b                	mov    (%ebx),%ebx
  80e3b7:	85 db                	test   %ebx,%ebx
  80e3b9:	75 9d                	jne    80e358 <low_level_output+0x68>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80e3bb:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80e3c1:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80e3c8:	00 
  80e3c9:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
  80e3d0:	10 
  80e3d1:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  80e3d8:	00 
  80e3d9:	8b 47 04             	mov    0x4(%edi),%eax
  80e3dc:	89 04 24             	mov    %eax,(%esp)
  80e3df:	e8 a7 3e ff ff       	call   80228b <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80e3e4:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80e3eb:	10 
  80e3ec:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e3f3:	e8 26 38 ff ff       	call   801c1e <sys_page_unmap>

    return ERR_OK;
}
  80e3f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80e3fd:	83 c4 2c             	add    $0x2c,%esp
  80e400:	5b                   	pop    %ebx
  80e401:	5e                   	pop    %esi
  80e402:	5f                   	pop    %edi
  80e403:	5d                   	pop    %ebp
  80e404:	c3                   	ret    

0080e405 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80e405:	55                   	push   %ebp
  80e406:	89 e5                	mov    %esp,%ebp
  80e408:	83 ec 18             	sub    $0x18,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80e40b:	8b 45 10             	mov    0x10(%ebp),%eax
  80e40e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e412:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e415:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e419:	8b 45 08             	mov    0x8(%ebp),%eax
  80e41c:	89 04 24             	mov    %eax,(%esp)
  80e41f:	e8 2b ea ff ff       	call   80ce4f <etharp_output>
}
  80e424:	c9                   	leave  
  80e425:	c3                   	ret    

0080e426 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80e426:	55                   	push   %ebp
  80e427:	89 e5                	mov    %esp,%ebp
  80e429:	57                   	push   %edi
  80e42a:	56                   	push   %esi
  80e42b:	53                   	push   %ebx
  80e42c:	83 ec 2c             	sub    $0x2c,%esp
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80e42f:	8b 45 08             	mov    0x8(%ebp),%eax
  80e432:	8b 40 1c             	mov    0x1c(%eax),%eax
  80e435:	89 45 d8             	mov    %eax,-0x28(%ebp)
 *
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  80e438:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    s16_t len = pkt->jp_len;
  80e43b:	0f b7 33             	movzwl (%ebx),%esi

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80e43e:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  80e445:	00 
  80e446:	0f b7 c6             	movzwl %si,%eax
  80e449:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e44d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80e454:	e8 da 9c ff ff       	call   808133 <pbuf_alloc>
  80e459:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80e45c:	85 c0                	test   %eax,%eax
  80e45e:	0f 84 c6 00 00 00    	je     80e52a <jif_input+0x104>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80e464:	83 c3 04             	add    $0x4,%ebx
  80e467:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80e46a:	89 c3                	mov    %eax,%ebx
  80e46c:	bf 00 00 00 00       	mov    $0x0,%edi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80e471:	0f bf f6             	movswl %si,%esi
  80e474:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80e477:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e47b:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80e47e:	29 fe                	sub    %edi,%esi
  80e480:	39 c6                	cmp    %eax,%esi
  80e482:	7e 02                	jle    80e486 <jif_input+0x60>
  80e484:	89 c6                	mov    %eax,%esi
	if (bytes > (len - copied))
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80e486:	89 74 24 08          	mov    %esi,0x8(%esp)
  80e48a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e48d:	01 f8                	add    %edi,%eax
  80e48f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e493:	8b 43 04             	mov    0x4(%ebx),%eax
  80e496:	89 04 24             	mov    %eax,(%esp)
  80e499:	e8 93 31 ff ff       	call   801631 <memcpy>
	copied += bytes;
  80e49e:	01 f7                	add    %esi,%edi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80e4a0:	8b 1b                	mov    (%ebx),%ebx
  80e4a2:	85 db                	test   %ebx,%ebx
  80e4a4:	75 d1                	jne    80e477 <jif_input+0x51>
  80e4a6:	eb 61                	jmp    80e509 <jif_input+0xe3>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80e4a8:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e4ab:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e4af:	8b 45 08             	mov    0x8(%ebp),%eax
  80e4b2:	89 04 24             	mov    %eax,(%esp)
  80e4b5:	e8 bf ec ff ff       	call   80d179 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80e4ba:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80e4c1:	ff 
  80e4c2:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e4c5:	89 14 24             	mov    %edx,(%esp)
  80e4c8:	e8 36 96 ff ff       	call   807b03 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80e4cd:	8b 45 08             	mov    0x8(%ebp),%eax
  80e4d0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e4d4:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e4d7:	89 14 24             	mov    %edx,(%esp)
  80e4da:	ff 50 10             	call   *0x10(%eax)
	break;
  80e4dd:	eb 4b                	jmp    80e52a <jif_input+0x104>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80e4df:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80e4e2:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e4e6:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80e4e9:	8b 02                	mov    (%edx),%eax
  80e4eb:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e4ef:	8b 45 08             	mov    0x8(%ebp),%eax
  80e4f2:	89 04 24             	mov    %eax,(%esp)
  80e4f5:	e8 cd ec ff ff       	call   80d1c7 <etharp_arp_input>
	break;
  80e4fa:	eb 2e                	jmp    80e52a <jif_input+0x104>

    default:
	pbuf_free(p);
  80e4fc:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e4ff:	89 14 24             	mov    %edx,(%esp)
  80e502:	e8 71 99 ff ff       	call   807e78 <pbuf_free>
  80e507:	eb 21                	jmp    80e52a <jif_input+0x104>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80e509:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e50c:	8b 42 04             	mov    0x4(%edx),%eax
  80e50f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80e513:	89 04 24             	mov    %eax,(%esp)
  80e516:	e8 59 c7 ff ff       	call   80ac74 <htons>
  80e51b:	66 3d 00 08          	cmp    $0x800,%ax
  80e51f:	74 87                	je     80e4a8 <jif_input+0x82>
  80e521:	66 3d 06 08          	cmp    $0x806,%ax
  80e525:	75 d5                	jne    80e4fc <jif_input+0xd6>
  80e527:	90                   	nop
  80e528:	eb b5                	jmp    80e4df <jif_input+0xb9>
	break;

    default:
	pbuf_free(p);
    }
}
  80e52a:	83 c4 2c             	add    $0x2c,%esp
  80e52d:	5b                   	pop    %ebx
  80e52e:	5e                   	pop    %esi
  80e52f:	5f                   	pop    %edi
  80e530:	5d                   	pop    %ebp
  80e531:	c3                   	ret    
	...

0080e540 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80e540:	55                   	push   %ebp
  80e541:	89 e5                	mov    %esp,%ebp
  80e543:	83 ec 18             	sub    $0x18,%esp
  80e546:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80e549:	85 c0                	test   %eax,%eax
  80e54b:	75 1c                	jne    80e569 <netconn_type+0x29>
  80e54d:	c7 44 24 08 19 48 81 	movl   $0x814819,0x8(%esp)
  80e554:	00 
  80e555:	c7 44 24 04 84 00 00 	movl   $0x84,0x4(%esp)
  80e55c:	00 
  80e55d:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e564:	e8 7f 24 ff ff       	call   8009e8 <_panic>
  80e569:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80e56b:	c9                   	leave  
  80e56c:	c3                   	ret    

0080e56d <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80e56d:	55                   	push   %ebp
  80e56e:	89 e5                	mov    %esp,%ebp
  80e570:	53                   	push   %ebx
  80e571:	83 ec 34             	sub    $0x34,%esp
  80e574:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e577:	85 db                	test   %ebx,%ebx
  80e579:	75 1c                	jne    80e597 <netconn_close+0x2a>
  80e57b:	c7 44 24 08 4b 48 81 	movl   $0x81484b,0x8(%esp)
  80e582:	00 
  80e583:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
  80e58a:	00 
  80e58b:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e592:	e8 51 24 ff ff       	call   8009e8 <_panic>

  msg.function = do_close;
  80e597:	c7 45 e4 7f ef 80 00 	movl   $0x80ef7f,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e59e:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80e5a1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e5a4:	89 04 24             	mov    %eax,(%esp)
  80e5a7:	e8 db 6b ff ff       	call   805187 <tcpip_apimsg>
  80e5ac:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e5b0:	83 c4 34             	add    $0x34,%esp
  80e5b3:	5b                   	pop    %ebx
  80e5b4:	5d                   	pop    %ebp
  80e5b5:	c3                   	ret    

0080e5b6 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80e5b6:	55                   	push   %ebp
  80e5b7:	89 e5                	mov    %esp,%ebp
  80e5b9:	53                   	push   %ebx
  80e5ba:	83 ec 34             	sub    $0x34,%esp
  80e5bd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e5c0:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e5c4:	85 db                	test   %ebx,%ebx
  80e5c6:	75 1c                	jne    80e5e4 <netconn_write+0x2e>
  80e5c8:	c7 44 24 08 67 48 81 	movl   $0x814867,0x8(%esp)
  80e5cf:	00 
  80e5d0:	c7 44 24 04 d3 01 00 	movl   $0x1d3,0x4(%esp)
  80e5d7:	00 
  80e5d8:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e5df:	e8 04 24 ff ff       	call   8009e8 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80e5e4:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e5e7:	74 1c                	je     80e605 <netconn_write+0x4f>
  80e5e9:	c7 44 24 08 b4 49 81 	movl   $0x8149b4,0x8(%esp)
  80e5f0:	00 
  80e5f1:	c7 44 24 04 d4 01 00 	movl   $0x1d4,0x4(%esp)
  80e5f8:	00 
  80e5f9:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e600:	e8 e3 23 ff ff       	call   8009e8 <_panic>

  msg.function = do_write;
  80e605:	c7 45 e4 0e f3 80 00 	movl   $0x80f30e,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e60c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80e60f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e612:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80e615:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80e618:	8b 45 10             	mov    0x10(%ebp),%eax
  80e61b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80e61e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e621:	89 04 24             	mov    %eax,(%esp)
  80e624:	e8 5e 6b ff ff       	call   805187 <tcpip_apimsg>
  80e629:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e62d:	83 c4 34             	add    $0x34,%esp
  80e630:	5b                   	pop    %ebx
  80e631:	5d                   	pop    %ebp
  80e632:	c3                   	ret    

0080e633 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80e633:	55                   	push   %ebp
  80e634:	89 e5                	mov    %esp,%ebp
  80e636:	53                   	push   %ebx
  80e637:	83 ec 34             	sub    $0x34,%esp
  80e63a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e63d:	85 db                	test   %ebx,%ebx
  80e63f:	75 1c                	jne    80e65d <netconn_send+0x2a>
  80e641:	c7 44 24 08 83 48 81 	movl   $0x814883,0x8(%esp)
  80e648:	00 
  80e649:	c7 44 24 04 b9 01 00 	movl   $0x1b9,0x4(%esp)
  80e650:	00 
  80e651:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e658:	e8 8b 23 ff ff       	call   8009e8 <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80e65d:	c7 45 e4 9c f3 80 00 	movl   $0x80f39c,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e664:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80e667:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e66a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80e66d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e670:	89 04 24             	mov    %eax,(%esp)
  80e673:	e8 0f 6b ff ff       	call   805187 <tcpip_apimsg>
  80e678:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e67c:	83 c4 34             	add    $0x34,%esp
  80e67f:	5b                   	pop    %ebx
  80e680:	5d                   	pop    %ebp
  80e681:	c3                   	ret    

0080e682 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80e682:	55                   	push   %ebp
  80e683:	89 e5                	mov    %esp,%ebp
  80e685:	83 ec 18             	sub    $0x18,%esp
  80e688:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e68b:	0f b7 4d 14          	movzwl 0x14(%ebp),%ecx
  if (buf != NULL) {
  80e68f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80e694:	85 d2                	test   %edx,%edx
  80e696:	74 19                	je     80e6b1 <netconn_sendto+0x2f>
    buf->addr = addr;
  80e698:	8b 45 10             	mov    0x10(%ebp),%eax
  80e69b:	89 42 08             	mov    %eax,0x8(%edx)
    buf->port = port;
  80e69e:	66 89 4a 0c          	mov    %cx,0xc(%edx)
    return netconn_send(conn, buf);
  80e6a2:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e6a6:	8b 45 08             	mov    0x8(%ebp),%eax
  80e6a9:	89 04 24             	mov    %eax,(%esp)
  80e6ac:	e8 82 ff ff ff       	call   80e633 <netconn_send>
  }
  return ERR_VAL;
}
  80e6b1:	c9                   	leave  
  80e6b2:	c3                   	ret    

0080e6b3 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80e6b3:	55                   	push   %ebp
  80e6b4:	89 e5                	mov    %esp,%ebp
  80e6b6:	53                   	push   %ebx
  80e6b7:	83 ec 34             	sub    $0x34,%esp
  80e6ba:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80e6bd:	85 db                	test   %ebx,%ebx
  80e6bf:	75 1c                	jne    80e6dd <netconn_listen_with_backlog+0x2a>
  80e6c1:	c7 44 24 08 9e 48 81 	movl   $0x81489e,0x8(%esp)
  80e6c8:	00 
  80e6c9:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80e6d0:	00 
  80e6d1:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e6d8:	e8 0b 23 ff ff       	call   8009e8 <_panic>

  msg.function = do_listen;
  80e6dd:	c7 45 e4 5f f4 80 00 	movl   $0x80f45f,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e6e4:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80e6e7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e6ea:	89 04 24             	mov    %eax,(%esp)
  80e6ed:	e8 95 6a ff ff       	call   805187 <tcpip_apimsg>
  80e6f2:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e6f6:	83 c4 34             	add    $0x34,%esp
  80e6f9:	5b                   	pop    %ebx
  80e6fa:	5d                   	pop    %ebp
  80e6fb:	c3                   	ret    

0080e6fc <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80e6fc:	55                   	push   %ebp
  80e6fd:	89 e5                	mov    %esp,%ebp
  80e6ff:	53                   	push   %ebx
  80e700:	83 ec 34             	sub    $0x34,%esp
  80e703:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80e706:	85 db                	test   %ebx,%ebx
  80e708:	75 1c                	jne    80e726 <netconn_disconnect+0x2a>
  80e70a:	c7 44 24 08 d8 49 81 	movl   $0x8149d8,0x8(%esp)
  80e711:	00 
  80e712:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
  80e719:	00 
  80e71a:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e721:	e8 c2 22 ff ff       	call   8009e8 <_panic>

  msg.function = do_disconnect;
  80e726:	c7 45 e4 29 f6 80 00 	movl   $0x80f629,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e72d:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80e730:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e733:	89 04 24             	mov    %eax,(%esp)
  80e736:	e8 4c 6a ff ff       	call   805187 <tcpip_apimsg>
  80e73b:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e73f:	83 c4 34             	add    $0x34,%esp
  80e742:	5b                   	pop    %ebx
  80e743:	5d                   	pop    %ebp
  80e744:	c3                   	ret    

0080e745 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80e745:	55                   	push   %ebp
  80e746:	89 e5                	mov    %esp,%ebp
  80e748:	53                   	push   %ebx
  80e749:	83 ec 34             	sub    $0x34,%esp
  80e74c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e74f:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80e753:	85 db                	test   %ebx,%ebx
  80e755:	75 1c                	jne    80e773 <netconn_connect+0x2e>
  80e757:	c7 44 24 08 bb 48 81 	movl   $0x8148bb,0x8(%esp)
  80e75e:	00 
  80e75f:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
  80e766:	00 
  80e767:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e76e:	e8 75 22 ff ff       	call   8009e8 <_panic>

  msg.function = do_connect;
  80e773:	c7 45 e4 60 f6 80 00 	movl   $0x80f660,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e77a:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80e77d:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e780:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80e783:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80e787:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e78a:	89 04 24             	mov    %eax,(%esp)
  80e78d:	e8 f5 69 ff ff       	call   805187 <tcpip_apimsg>
  80e792:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e796:	83 c4 34             	add    $0x34,%esp
  80e799:	5b                   	pop    %ebx
  80e79a:	5d                   	pop    %ebp
  80e79b:	c3                   	ret    

0080e79c <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80e79c:	55                   	push   %ebp
  80e79d:	89 e5                	mov    %esp,%ebp
  80e79f:	53                   	push   %ebx
  80e7a0:	83 ec 34             	sub    $0x34,%esp
  80e7a3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e7a6:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80e7aa:	85 db                	test   %ebx,%ebx
  80e7ac:	75 1c                	jne    80e7ca <netconn_bind+0x2e>
  80e7ae:	c7 44 24 08 d9 48 81 	movl   $0x8148d9,0x8(%esp)
  80e7b5:	00 
  80e7b6:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80e7bd:	00 
  80e7be:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e7c5:	e8 1e 22 ff ff       	call   8009e8 <_panic>

  msg.function = do_bind;
  80e7ca:	c7 45 e4 28 f7 80 00 	movl   $0x80f728,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e7d1:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80e7d4:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e7d7:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80e7da:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80e7de:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e7e1:	89 04 24             	mov    %eax,(%esp)
  80e7e4:	e8 9e 69 ff ff       	call   805187 <tcpip_apimsg>
  80e7e9:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e7ed:	83 c4 34             	add    $0x34,%esp
  80e7f0:	5b                   	pop    %ebx
  80e7f1:	5d                   	pop    %ebp
  80e7f2:	c3                   	ret    

0080e7f3 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80e7f3:	55                   	push   %ebp
  80e7f4:	89 e5                	mov    %esp,%ebp
  80e7f6:	53                   	push   %ebx
  80e7f7:	83 ec 34             	sub    $0x34,%esp
  80e7fa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e7fd:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e800:	8b 45 10             	mov    0x10(%ebp),%eax
  80e803:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80e807:	85 db                	test   %ebx,%ebx
  80e809:	75 1c                	jne    80e827 <netconn_getaddr+0x34>
  80e80b:	c7 44 24 08 f4 48 81 	movl   $0x8148f4,0x8(%esp)
  80e812:	00 
  80e813:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80e81a:	00 
  80e81b:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e822:	e8 c1 21 ff ff       	call   8009e8 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80e827:	85 d2                	test   %edx,%edx
  80e829:	75 1c                	jne    80e847 <netconn_getaddr+0x54>
  80e82b:	c7 44 24 08 12 49 81 	movl   $0x814912,0x8(%esp)
  80e832:	00 
  80e833:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80e83a:	00 
  80e83b:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e842:	e8 a1 21 ff ff       	call   8009e8 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80e847:	85 c0                	test   %eax,%eax
  80e849:	75 1c                	jne    80e867 <netconn_getaddr+0x74>
  80e84b:	c7 44 24 08 30 49 81 	movl   $0x814930,0x8(%esp)
  80e852:	00 
  80e853:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
  80e85a:	00 
  80e85b:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e862:	e8 81 21 ff ff       	call   8009e8 <_panic>

  msg.function = do_getaddr;
  80e867:	c7 45 e4 10 ec 80 00 	movl   $0x80ec10,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e86e:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80e871:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80e874:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80e877:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80e87a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e87d:	89 04 24             	mov    %eax,(%esp)
  80e880:	e8 02 69 ff ff       	call   805187 <tcpip_apimsg>
  80e885:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax

  return conn->err;
}
  80e889:	83 c4 34             	add    $0x34,%esp
  80e88c:	5b                   	pop    %ebx
  80e88d:	5d                   	pop    %ebp
  80e88e:	c3                   	ret    

0080e88f <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80e88f:	55                   	push   %ebp
  80e890:	89 e5                	mov    %esp,%ebp
  80e892:	53                   	push   %ebx
  80e893:	83 ec 24             	sub    $0x24,%esp
  80e896:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80e899:	85 db                	test   %ebx,%ebx
  80e89b:	75 1c                	jne    80e8b9 <netconn_accept+0x2a>
  80e89d:	c7 44 24 08 4e 49 81 	movl   $0x81494e,0x8(%esp)
  80e8a4:	00 
  80e8a5:	c7 44 24 04 10 01 00 	movl   $0x110,0x4(%esp)
  80e8ac:	00 
  80e8ad:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e8b4:	e8 2f 21 ff ff       	call   8009e8 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80e8b9:	8b 43 18             	mov    0x18(%ebx),%eax
  80e8bc:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e8bf:	75 1c                	jne    80e8dd <netconn_accept+0x4e>
  80e8c1:	c7 44 24 08 fc 49 81 	movl   $0x8149fc,0x8(%esp)
  80e8c8:	00 
  80e8c9:	c7 44 24 04 11 01 00 	movl   $0x111,0x4(%esp)
  80e8d0:	00 
  80e8d1:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e8d8:	e8 0b 21 ff ff       	call   8009e8 <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80e8dd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e8e4:	00 
  80e8e5:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80e8e8:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e8ec:	89 04 24             	mov    %eax,(%esp)
  80e8ef:	e8 da f2 ff ff       	call   80dbce <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80e8f4:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80e8f7:	85 c0                	test   %eax,%eax
  80e8f9:	74 15                	je     80e910 <netconn_accept+0x81>
  80e8fb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e902:	00 
  80e903:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80e90a:	00 
  80e90b:	89 1c 24             	mov    %ebx,(%esp)
  80e90e:	ff d0                	call   *%eax
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80e910:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80e913:	83 c4 24             	add    $0x24,%esp
  80e916:	5b                   	pop    %ebx
  80e917:	5d                   	pop    %ebp
  80e918:	c3                   	ret    

0080e919 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80e919:	55                   	push   %ebp
  80e91a:	89 e5                	mov    %esp,%ebp
  80e91c:	53                   	push   %ebx
  80e91d:	83 ec 34             	sub    $0x34,%esp
  80e920:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80e923:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80e92a:	85 db                	test   %ebx,%ebx
  80e92c:	75 1c                	jne    80e94a <netconn_recv+0x31>
  80e92e:	c7 44 24 08 6b 49 81 	movl   $0x81496b,0x8(%esp)
  80e935:	00 
  80e936:	c7 44 24 04 3a 01 00 	movl   $0x13a,0x4(%esp)
  80e93d:	00 
  80e93e:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80e945:	e8 9e 20 ff ff       	call   8009e8 <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80e94a:	8b 43 14             	mov    0x14(%ebx),%eax
  80e94d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e950:	75 0e                	jne    80e960 <netconn_recv+0x47>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80e952:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
  80e956:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  80e95b:	e9 65 01 00 00       	jmp    80eac5 <netconn_recv+0x1ac>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80e960:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80e964:	0f 8c 56 01 00 00    	jl     80eac0 <netconn_recv+0x1a7>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80e96a:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e96d:	8d 76 00             	lea    0x0(%esi),%esi
  80e970:	0f 85 fc 00 00 00    	jne    80ea72 <netconn_recv+0x159>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80e976:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80e97a:	75 0e                	jne    80e98a <netconn_recv+0x71>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80e97c:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
  80e980:	b8 00 00 00 00       	mov    $0x0,%eax
      return NULL;
  80e985:	e9 3b 01 00 00       	jmp    80eac5 <netconn_recv+0x1ac>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80e98a:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80e991:	e8 8e 8d ff ff       	call   807724 <memp_malloc>
  80e996:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80e999:	85 c0                	test   %eax,%eax
  80e99b:	75 09                	jne    80e9a6 <netconn_recv+0x8d>
      conn->err = ERR_MEM;
  80e99d:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80e9a1:	e9 1f 01 00 00       	jmp    80eac5 <netconn_recv+0x1ac>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80e9a6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e9ad:	00 
  80e9ae:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80e9b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e9b5:	8b 43 14             	mov    0x14(%ebx),%eax
  80e9b8:	89 04 24             	mov    %eax,(%esp)
  80e9bb:	e8 0e f2 ff ff       	call   80dbce <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80e9c0:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e9c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80e9c8:	85 d2                	test   %edx,%edx
  80e9ca:	74 08                	je     80e9d4 <netconn_recv+0xbb>
      len = p->tot_len;
  80e9cc:	0f b7 42 08          	movzwl 0x8(%edx),%eax
      SYS_ARCH_DEC(conn->recv_avail, len);
  80e9d0:	66 29 43 20          	sub    %ax,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80e9d4:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80e9d7:	85 d2                	test   %edx,%edx
  80e9d9:	74 14                	je     80e9ef <netconn_recv+0xd6>
  80e9db:	0f b7 c0             	movzwl %ax,%eax
  80e9de:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e9e2:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80e9e9:	00 
  80e9ea:	89 1c 24             	mov    %ebx,(%esp)
  80e9ed:	ff d2                	call   *%edx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80e9ef:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80e9f2:	85 c0                	test   %eax,%eax
  80e9f4:	75 2b                	jne    80ea21 <netconn_recv+0x108>
      memp_free(MEMP_NETBUF, buf);
  80e9f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e9f9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e9fd:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80ea04:	e8 d7 8c ff ff       	call   8076e0 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80ea09:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80ea0d:	0f 85 ad 00 00 00    	jne    80eac0 <netconn_recv+0x1a7>
        conn->err = ERR_CLSD;
  80ea13:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80ea17:	b8 00 00 00 00       	mov    $0x0,%eax
  80ea1c:	e9 a4 00 00 00       	jmp    80eac5 <netconn_recv+0x1ac>
      }
      return NULL;
    }

    buf->p = p;
  80ea21:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80ea24:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80ea26:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80ea29:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea2c:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80ea2f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea32:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80ea38:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea3b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80ea42:	c7 45 e4 5b f3 80 00 	movl   $0x80f35b,-0x1c(%ebp)
    msg.msg.conn = conn;
  80ea49:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80ea4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea4f:	85 c0                	test   %eax,%eax
  80ea51:	74 0c                	je     80ea5f <netconn_recv+0x146>
      msg.msg.msg.r.len = buf->p->tot_len;
  80ea53:	8b 00                	mov    (%eax),%eax
  80ea55:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80ea59:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80ea5d:	eb 06                	jmp    80ea65 <netconn_recv+0x14c>
    } else {
      msg.msg.msg.r.len = 1;
  80ea5f:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80ea65:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ea68:	89 04 24             	mov    %eax,(%esp)
  80ea6b:	e8 17 67 ff ff       	call   805187 <tcpip_apimsg>
  80ea70:	eb 49                	jmp    80eabb <netconn_recv+0x1a2>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80ea72:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ea79:	00 
  80ea7a:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80ea7d:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ea81:	89 04 24             	mov    %eax,(%esp)
  80ea84:	e8 45 f1 ff ff       	call   80dbce <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80ea89:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea8c:	85 c0                	test   %eax,%eax
  80ea8e:	74 2b                	je     80eabb <netconn_recv+0x1a2>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80ea90:	8b 00                	mov    (%eax),%eax
  80ea92:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80ea96:	66 29 43 20          	sub    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80ea9a:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ea9d:	85 c0                	test   %eax,%eax
  80ea9f:	74 1a                	je     80eabb <netconn_recv+0x1a2>
  80eaa1:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80eaa4:	8b 12                	mov    (%edx),%edx
  80eaa6:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80eaaa:	89 54 24 08          	mov    %edx,0x8(%esp)
  80eaae:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80eab5:	00 
  80eab6:	89 1c 24             	mov    %ebx,(%esp)
  80eab9:	ff d0                	call   *%eax
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80eabb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80eabe:	eb 05                	jmp    80eac5 <netconn_recv+0x1ac>
  80eac0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80eac5:	83 c4 34             	add    $0x34,%esp
  80eac8:	5b                   	pop    %ebx
  80eac9:	5d                   	pop    %ebp
  80eaca:	c3                   	ret    

0080eacb <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80eacb:	55                   	push   %ebp
  80eacc:	89 e5                	mov    %esp,%ebp
  80eace:	53                   	push   %ebx
  80eacf:	83 ec 34             	sub    $0x34,%esp
  80ead2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80ead5:	85 db                	test   %ebx,%ebx
  80ead7:	74 24                	je     80eafd <netconn_delete+0x32>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80ead9:	c7 45 e4 c9 f7 80 00 	movl   $0x80f7c9,-0x1c(%ebp)
  msg.msg.conn = conn;
  80eae0:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80eae3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80eae6:	89 04 24             	mov    %eax,(%esp)
  80eae9:	e8 99 66 ff ff       	call   805187 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80eaee:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80eaf5:	89 1c 24             	mov    %ebx,(%esp)
  80eaf8:	e8 84 0d 00 00       	call   80f881 <netconn_free>

  return ERR_OK;
}
  80eafd:	b8 00 00 00 00       	mov    $0x0,%eax
  80eb02:	83 c4 34             	add    $0x34,%esp
  80eb05:	5b                   	pop    %ebx
  80eb06:	5d                   	pop    %ebp
  80eb07:	c3                   	ret    

0080eb08 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80eb08:	55                   	push   %ebp
  80eb09:	89 e5                	mov    %esp,%ebp
  80eb0b:	56                   	push   %esi
  80eb0c:	53                   	push   %ebx
  80eb0d:	83 ec 30             	sub    $0x30,%esp
  80eb10:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80eb14:	8b 45 10             	mov    0x10(%ebp),%eax
  80eb17:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eb1b:	8b 45 08             	mov    0x8(%ebp),%eax
  80eb1e:	89 04 24             	mov    %eax,(%esp)
  80eb21:	e8 57 0f 00 00       	call   80fa7d <netconn_alloc>
  80eb26:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80eb28:	85 c0                	test   %eax,%eax
  80eb2a:	0f 84 d6 00 00 00    	je     80ec06 <netconn_new_with_proto_and_callback+0xfe>
    msg.function = do_newconn;
  80eb30:	c7 45 e4 ea fb 80 00 	movl   $0x80fbea,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80eb37:	89 f0                	mov    %esi,%eax
  80eb39:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80eb3c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80eb3f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80eb42:	89 04 24             	mov    %eax,(%esp)
  80eb45:	e8 3d 66 ff ff       	call   805187 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80eb4a:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80eb4e:	0f 84 b2 00 00 00    	je     80ec06 <netconn_new_with_proto_and_callback+0xfe>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80eb54:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80eb58:	74 1c                	je     80eb76 <netconn_new_with_proto_and_callback+0x6e>
  80eb5a:	c7 44 24 08 20 4a 81 	movl   $0x814a20,0x8(%esp)
  80eb61:	00 
  80eb62:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  80eb69:	00 
  80eb6a:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80eb71:	e8 72 1e ff ff       	call   8009e8 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80eb76:	8b 43 10             	mov    0x10(%ebx),%eax
  80eb79:	83 f8 ff             	cmp    $0xffffffff,%eax
  80eb7c:	75 1c                	jne    80eb9a <netconn_new_with_proto_and_callback+0x92>
  80eb7e:	c7 44 24 08 86 49 81 	movl   $0x814986,0x8(%esp)
  80eb85:	00 
  80eb86:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  80eb8d:	00 
  80eb8e:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80eb95:	e8 4e 1e ff ff       	call   8009e8 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80eb9a:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80eb9e:	75 1c                	jne    80ebbc <netconn_new_with_proto_and_callback+0xb4>
  80eba0:	c7 44 24 08 9f 49 81 	movl   $0x81499f,0x8(%esp)
  80eba7:	00 
  80eba8:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80ebaf:	00 
  80ebb0:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80ebb7:	e8 2c 1e ff ff       	call   8009e8 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80ebbc:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80ebc0:	74 1c                	je     80ebde <netconn_new_with_proto_and_callback+0xd6>
  80ebc2:	c7 44 24 08 44 4a 81 	movl   $0x814a44,0x8(%esp)
  80ebc9:	00 
  80ebca:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80ebd1:	00 
  80ebd2:	c7 04 24 34 48 81 00 	movl   $0x814834,(%esp)
  80ebd9:	e8 0a 1e ff ff       	call   8009e8 <_panic>
      sys_sem_free(conn->op_completed);
  80ebde:	89 04 24             	mov    %eax,(%esp)
  80ebe1:	e8 1d e9 ff ff       	call   80d503 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80ebe6:	8b 43 14             	mov    0x14(%ebx),%eax
  80ebe9:	89 04 24             	mov    %eax,(%esp)
  80ebec:	e8 94 e9 ff ff       	call   80d585 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80ebf1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ebf5:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80ebfc:	e8 df 8a ff ff       	call   8076e0 <memp_free>
  80ec01:	bb 00 00 00 00       	mov    $0x0,%ebx
      return NULL;
    }
  }
  return conn;
}
  80ec06:	89 d8                	mov    %ebx,%eax
  80ec08:	83 c4 30             	add    $0x30,%esp
  80ec0b:	5b                   	pop    %ebx
  80ec0c:	5e                   	pop    %esi
  80ec0d:	5d                   	pop    %ebp
  80ec0e:	c3                   	ret    
	...

0080ec10 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80ec10:	55                   	push   %ebp
  80ec11:	89 e5                	mov    %esp,%ebp
  80ec13:	83 ec 18             	sub    $0x18,%esp
  80ec16:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80ec19:	8b 08                	mov    (%eax),%ecx
  80ec1b:	8b 51 08             	mov    0x8(%ecx),%edx
  80ec1e:	85 d2                	test   %edx,%edx
  80ec20:	0f 84 9f 00 00 00    	je     80ecc5 <do_getaddr+0xb5>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80ec26:	8b 48 04             	mov    0x4(%eax),%ecx
  80ec29:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ec2d:	74 06                	je     80ec35 <do_getaddr+0x25>
  80ec2f:	8b 12                	mov    (%edx),%edx
  80ec31:	89 11                	mov    %edx,(%ecx)
  80ec33:	eb 05                	jmp    80ec3a <do_getaddr+0x2a>
  80ec35:	8b 52 04             	mov    0x4(%edx),%edx
  80ec38:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80ec3a:	8b 08                	mov    (%eax),%ecx
  80ec3c:	8b 11                	mov    (%ecx),%edx
  80ec3e:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80ec44:	83 fa 20             	cmp    $0x20,%edx
  80ec47:	74 2e                	je     80ec77 <do_getaddr+0x67>
  80ec49:	83 fa 40             	cmp    $0x40,%edx
  80ec4c:	74 0c                	je     80ec5a <do_getaddr+0x4a>
  80ec4e:	83 fa 10             	cmp    $0x10,%edx
  80ec51:	75 76                	jne    80ecc9 <do_getaddr+0xb9>
  80ec53:	90                   	nop
  80ec54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80ec58:	eb 4d                	jmp    80eca7 <do_getaddr+0x97>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80ec5a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ec5e:	66 90                	xchg   %ax,%ax
  80ec60:	74 0f                	je     80ec71 <do_getaddr+0x61>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80ec62:	8b 50 08             	mov    0x8(%eax),%edx
  80ec65:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ec68:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80ec6c:	66 89 0a             	mov    %cx,(%edx)
  80ec6f:	eb 58                	jmp    80ecc9 <do_getaddr+0xb9>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80ec71:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80ec75:	eb 52                	jmp    80ecc9 <do_getaddr+0xb9>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80ec77:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ec7b:	74 0f                	je     80ec8c <do_getaddr+0x7c>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80ec7d:	8b 50 08             	mov    0x8(%eax),%edx
  80ec80:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ec83:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80ec87:	66 89 0a             	mov    %cx,(%edx)
  80ec8a:	eb 3d                	jmp    80ecc9 <do_getaddr+0xb9>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80ec8c:	8b 51 08             	mov    0x8(%ecx),%edx
  80ec8f:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80ec93:	75 06                	jne    80ec9b <do_getaddr+0x8b>
          msg->conn->err = ERR_CONN;
  80ec95:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80ec99:	eb 2e                	jmp    80ecc9 <do_getaddr+0xb9>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80ec9b:	8b 48 08             	mov    0x8(%eax),%ecx
  80ec9e:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80eca2:	66 89 11             	mov    %dx,(%ecx)
  80eca5:	eb 22                	jmp    80ecc9 <do_getaddr+0xb9>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80eca7:	8b 50 08             	mov    0x8(%eax),%edx
  80ecaa:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ecae:	74 09                	je     80ecb9 <do_getaddr+0xa9>
  80ecb0:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ecb3:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  80ecb7:	eb 07                	jmp    80ecc0 <do_getaddr+0xb0>
  80ecb9:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ecbc:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  80ecc0:	66 89 0a             	mov    %cx,(%edx)
  80ecc3:	eb 04                	jmp    80ecc9 <do_getaddr+0xb9>
      break;
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80ecc5:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80ecc9:	8b 00                	mov    (%eax),%eax
  80eccb:	8b 40 10             	mov    0x10(%eax),%eax
  80ecce:	89 04 24             	mov    %eax,(%esp)
  80ecd1:	e8 81 ee ff ff       	call   80db57 <sys_sem_signal>
}
  80ecd6:	c9                   	leave  
  80ecd7:	c3                   	ret    

0080ecd8 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80ecd8:	55                   	push   %ebp
  80ecd9:	89 e5                	mov    %esp,%ebp
  80ecdb:	53                   	push   %ebx
  80ecdc:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80ecdf:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80ece2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ece6:	89 1c 24             	mov    %ebx,(%esp)
  80ece9:	e8 f8 9a ff ff       	call   8087e6 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80ecee:	c7 44 24 04 50 f5 80 	movl   $0x80f550,0x4(%esp)
  80ecf5:	00 
  80ecf6:	89 1c 24             	mov    %ebx,(%esp)
  80ecf9:	e8 f6 9a ff ff       	call   8087f4 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80ecfe:	c7 44 24 04 5c f2 80 	movl   $0x80f25c,0x4(%esp)
  80ed05:	00 
  80ed06:	89 1c 24             	mov    %ebx,(%esp)
  80ed09:	e8 f7 9a ff ff       	call   808805 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80ed0e:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80ed15:	00 
  80ed16:	c7 44 24 04 07 f2 80 	movl   $0x80f207,0x4(%esp)
  80ed1d:	00 
  80ed1e:	89 1c 24             	mov    %ebx,(%esp)
  80ed21:	e8 0f 9b ff ff       	call   808835 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80ed26:	c7 44 24 04 b8 ef 80 	movl   $0x80efb8,0x4(%esp)
  80ed2d:	00 
  80ed2e:	89 1c 24             	mov    %ebx,(%esp)
  80ed31:	e8 e0 9a ff ff       	call   808816 <tcp_err>
}
  80ed36:	83 c4 14             	add    $0x14,%esp
  80ed39:	5b                   	pop    %ebx
  80ed3a:	5d                   	pop    %ebp
  80ed3b:	c3                   	ret    

0080ed3c <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80ed3c:	55                   	push   %ebp
  80ed3d:	89 e5                	mov    %esp,%ebp
  80ed3f:	53                   	push   %ebx
  80ed40:	83 ec 14             	sub    $0x14,%esp
  80ed43:	0f b6 55 10          	movzbl 0x10(%ebp),%edx
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  80ed47:	8b 5d 08             	mov    0x8(%ebp),%ebx

  if (conn == NULL) {
  80ed4a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80ed4f:	85 db                	test   %ebx,%ebx
  80ed51:	74 2a                	je     80ed7d <do_connected+0x41>
    return ERR_VAL;
  }

  conn->err = err;
  80ed53:	88 53 0c             	mov    %dl,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80ed56:	83 3b 10             	cmpl   $0x10,(%ebx)
  80ed59:	75 0b                	jne    80ed66 <do_connected+0x2a>
  80ed5b:	84 d2                	test   %dl,%dl
  80ed5d:	75 07                	jne    80ed66 <do_connected+0x2a>
    setup_tcp(conn);
  80ed5f:	89 d8                	mov    %ebx,%eax
  80ed61:	e8 72 ff ff ff       	call   80ecd8 <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80ed66:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80ed6d:	8b 43 10             	mov    0x10(%ebx),%eax
  80ed70:	89 04 24             	mov    %eax,(%esp)
  80ed73:	e8 df ed ff ff       	call   80db57 <sys_sem_signal>
  80ed78:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  80ed7d:	83 c4 14             	add    $0x14,%esp
  80ed80:	5b                   	pop    %ebx
  80ed81:	5d                   	pop    %ebp
  80ed82:	c3                   	ret    

0080ed83 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80ed83:	55                   	push   %ebp
  80ed84:	89 e5                	mov    %esp,%ebp
  80ed86:	53                   	push   %ebx
  80ed87:	83 ec 14             	sub    $0x14,%esp
  80ed8a:	89 c3                	mov    %eax,%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80ed8c:	85 c0                	test   %eax,%eax
  80ed8e:	75 1c                	jne    80edac <do_close_internal+0x29>
  80ed90:	c7 44 24 08 91 48 81 	movl   $0x814891,0x8(%esp)
  80ed97:	00 
  80ed98:	c7 44 24 04 53 02 00 	movl   $0x253,0x4(%esp)
  80ed9f:	00 
  80eda0:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80eda7:	e8 3c 1c ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80edac:	83 38 10             	cmpl   $0x10,(%eax)
  80edaf:	74 1c                	je     80edcd <do_close_internal+0x4a>
  80edb1:	c7 44 24 08 7c 4a 81 	movl   $0x814a7c,0x8(%esp)
  80edb8:	00 
  80edb9:	c7 44 24 04 54 02 00 	movl   $0x254,0x4(%esp)
  80edc0:	00 
  80edc1:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80edc8:	e8 1b 1c ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80edcd:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80edd1:	74 1c                	je     80edef <do_close_internal+0x6c>
  80edd3:	c7 44 24 08 48 4b 81 	movl   $0x814b48,0x8(%esp)
  80edda:	00 
  80eddb:	c7 44 24 04 55 02 00 	movl   $0x255,0x4(%esp)
  80ede2:	00 
  80ede3:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80edea:	e8 f9 1b ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80edef:	8b 40 08             	mov    0x8(%eax),%eax
  80edf2:	85 c0                	test   %eax,%eax
  80edf4:	75 1c                	jne    80ee12 <do_close_internal+0x8f>
  80edf6:	c7 44 24 08 9a 4a 81 	movl   $0x814a9a,0x8(%esp)
  80edfd:	00 
  80edfe:	c7 44 24 04 56 02 00 	movl   $0x256,0x4(%esp)
  80ee05:	00 
  80ee06:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80ee0d:	e8 d6 1b ff ff       	call   8009e8 <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80ee12:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ee19:	00 
  80ee1a:	89 04 24             	mov    %eax,(%esp)
  80ee1d:	e8 c4 99 ff ff       	call   8087e6 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80ee22:	8b 43 08             	mov    0x8(%ebx),%eax
  80ee25:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80ee29:	75 12                	jne    80ee3d <do_close_internal+0xba>
    tcp_accept(conn->pcb.tcp, NULL);
  80ee2b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ee32:	00 
  80ee33:	89 04 24             	mov    %eax,(%esp)
  80ee36:	e8 ec 99 ff ff       	call   808827 <tcp_accept>
  80ee3b:	eb 64                	jmp    80eea1 <do_close_internal+0x11e>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80ee3d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ee44:	00 
  80ee45:	89 04 24             	mov    %eax,(%esp)
  80ee48:	e8 a7 99 ff ff       	call   8087f4 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80ee4d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ee54:	00 
  80ee55:	8b 43 08             	mov    0x8(%ebx),%eax
  80ee58:	89 04 24             	mov    %eax,(%esp)
  80ee5b:	e8 c7 99 ff ff       	call   808827 <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80ee60:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ee67:	00 
  80ee68:	8b 43 08             	mov    0x8(%ebx),%eax
  80ee6b:	89 04 24             	mov    %eax,(%esp)
  80ee6e:	e8 92 99 ff ff       	call   808805 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80ee73:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80ee7a:	00 
  80ee7b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ee82:	00 
  80ee83:	8b 43 08             	mov    0x8(%ebx),%eax
  80ee86:	89 04 24             	mov    %eax,(%esp)
  80ee89:	e8 a7 99 ff ff       	call   808835 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80ee8e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ee95:	00 
  80ee96:	8b 43 08             	mov    0x8(%ebx),%eax
  80ee99:	89 04 24             	mov    %eax,(%esp)
  80ee9c:	e8 75 99 ff ff       	call   808816 <tcp_err>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80eea1:	8b 43 08             	mov    0x8(%ebx),%eax
  80eea4:	89 04 24             	mov    %eax,(%esp)
  80eea7:	e8 31 a8 ff ff       	call   8096dd <tcp_close>
  if (err == ERR_OK) {
  80eeac:	84 c0                	test   %al,%al
  80eeae:	75 57                	jne    80ef07 <do_close_internal+0x184>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80eeb0:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80eeb7:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80eebe:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80eec2:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80eec5:	85 c0                	test   %eax,%eax
  80eec7:	74 31                	je     80eefa <do_close_internal+0x177>
  80eec9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80eed0:	00 
  80eed1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eed8:	00 
  80eed9:	89 1c 24             	mov    %ebx,(%esp)
  80eedc:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80eede:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80eee1:	85 c0                	test   %eax,%eax
  80eee3:	74 15                	je     80eefa <do_close_internal+0x177>
  80eee5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80eeec:	00 
  80eeed:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80eef4:	00 
  80eef5:	89 1c 24             	mov    %ebx,(%esp)
  80eef8:	ff d0                	call   *%eax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80eefa:	8b 43 10             	mov    0x10(%ebx),%eax
  80eefd:	89 04 24             	mov    %eax,(%esp)
  80ef00:	e8 52 ec ff ff       	call   80db57 <sys_sem_signal>
  80ef05:	eb 72                	jmp    80ef79 <do_close_internal+0x1f6>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80ef07:	8b 43 08             	mov    0x8(%ebx),%eax
  80ef0a:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80ef0e:	75 1c                	jne    80ef2c <do_close_internal+0x1a9>
  80ef10:	c7 44 24 08 6c 4b 81 	movl   $0x814b6c,0x8(%esp)
  80ef17:	00 
  80ef18:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80ef1f:	00 
  80ef20:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80ef27:	e8 bc 1a ff ff       	call   8009e8 <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80ef2c:	c7 44 24 04 5c f2 80 	movl   $0x80f25c,0x4(%esp)
  80ef33:	00 
  80ef34:	89 04 24             	mov    %eax,(%esp)
  80ef37:	e8 c9 98 ff ff       	call   808805 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80ef3c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80ef43:	00 
  80ef44:	c7 44 24 04 07 f2 80 	movl   $0x80f207,0x4(%esp)
  80ef4b:	00 
  80ef4c:	8b 43 08             	mov    0x8(%ebx),%eax
  80ef4f:	89 04 24             	mov    %eax,(%esp)
  80ef52:	e8 de 98 ff ff       	call   808835 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80ef57:	c7 44 24 04 b8 ef 80 	movl   $0x80efb8,0x4(%esp)
  80ef5e:	00 
  80ef5f:	8b 43 08             	mov    0x8(%ebx),%eax
  80ef62:	89 04 24             	mov    %eax,(%esp)
  80ef65:	e8 ac 98 ff ff       	call   808816 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80ef6a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ef6e:	8b 43 08             	mov    0x8(%ebx),%eax
  80ef71:	89 04 24             	mov    %eax,(%esp)
  80ef74:	e8 6d 98 ff ff       	call   8087e6 <tcp_arg>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80ef79:	83 c4 14             	add    $0x14,%esp
  80ef7c:	5b                   	pop    %ebx
  80ef7d:	5d                   	pop    %ebp
  80ef7e:	c3                   	ret    

0080ef7f <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80ef7f:	55                   	push   %ebp
  80ef80:	89 e5                	mov    %esp,%ebp
  80ef82:	83 ec 18             	sub    $0x18,%esp
  80ef85:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80ef88:	8b 02                	mov    (%edx),%eax
  80ef8a:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80ef8e:	74 15                	je     80efa5 <do_close+0x26>
  80ef90:	83 38 10             	cmpl   $0x10,(%eax)
  80ef93:	75 10                	jne    80efa5 <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80ef95:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80ef9c:	8b 02                	mov    (%edx),%eax
  80ef9e:	e8 e0 fd ff ff       	call   80ed83 <do_close_internal>
 */
void
do_close(struct api_msg_msg *msg)
{
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80efa3:	eb 11                	jmp    80efb6 <do_close+0x37>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80efa5:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80efa9:	8b 02                	mov    (%edx),%eax
  80efab:	8b 40 10             	mov    0x10(%eax),%eax
  80efae:	89 04 24             	mov    %eax,(%esp)
  80efb1:	e8 a1 eb ff ff       	call   80db57 <sys_sem_signal>
  }
}
  80efb6:	c9                   	leave  
  80efb7:	c3                   	ret    

0080efb8 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80efb8:	55                   	push   %ebp
  80efb9:	89 e5                	mov    %esp,%ebp
  80efbb:	53                   	push   %ebx
  80efbc:	83 ec 14             	sub    $0x14,%esp
  80efbf:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  80efc3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80efc6:	85 db                	test   %ebx,%ebx
  80efc8:	75 1c                	jne    80efe6 <err_tcp+0x2e>
  80efca:	c7 44 24 08 ad 4a 81 	movl   $0x814aad,0x8(%esp)
  80efd1:	00 
  80efd2:	c7 44 24 04 22 01 00 	movl   $0x122,0x4(%esp)
  80efd9:	00 
  80efda:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80efe1:	e8 02 1a ff ff       	call   8009e8 <_panic>

  conn->pcb.tcp = NULL;
  80efe6:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80efed:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80eff0:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80eff4:	74 2f                	je     80f025 <err_tcp+0x6d>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80eff6:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80eff9:	85 c0                	test   %eax,%eax
  80effb:	74 15                	je     80f012 <err_tcp+0x5a>
  80effd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f004:	00 
  80f005:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f00c:	00 
  80f00d:	89 1c 24             	mov    %ebx,(%esp)
  80f010:	ff d0                	call   *%eax
    sys_mbox_post(conn->recvmbox, NULL);
  80f012:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f019:	00 
  80f01a:	8b 43 14             	mov    0x14(%ebx),%eax
  80f01d:	89 04 24             	mov    %eax,(%esp)
  80f020:	e8 9b ed ff ff       	call   80ddc0 <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80f025:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%ebx)
  80f029:	74 18                	je     80f043 <err_tcp+0x8b>
  80f02b:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80f02f:	75 12                	jne    80f043 <err_tcp+0x8b>
    conn->state = NETCONN_NONE;
  80f031:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80f038:	8b 43 10             	mov    0x10(%ebx),%eax
  80f03b:	89 04 24             	mov    %eax,(%esp)
  80f03e:	e8 14 eb ff ff       	call   80db57 <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80f043:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80f047:	74 2f                	je     80f078 <err_tcp+0xc0>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80f049:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f04c:	85 c0                	test   %eax,%eax
  80f04e:	74 15                	je     80f065 <err_tcp+0xad>
  80f050:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f057:	00 
  80f058:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f05f:	00 
  80f060:	89 1c 24             	mov    %ebx,(%esp)
  80f063:	ff d0                	call   *%eax
    sys_mbox_post(conn->acceptmbox, NULL);
  80f065:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f06c:	00 
  80f06d:	8b 43 18             	mov    0x18(%ebx),%eax
  80f070:	89 04 24             	mov    %eax,(%esp)
  80f073:	e8 48 ed ff ff       	call   80ddc0 <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80f078:	8b 43 04             	mov    0x4(%ebx),%eax
  80f07b:	83 f8 01             	cmp    $0x1,%eax
  80f07e:	74 05                	je     80f085 <err_tcp+0xcd>
  80f080:	83 f8 04             	cmp    $0x4,%eax
  80f083:	75 12                	jne    80f097 <err_tcp+0xdf>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80f085:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80f08c:	8b 43 10             	mov    0x10(%ebx),%eax
  80f08f:	89 04 24             	mov    %eax,(%esp)
  80f092:	e8 c0 ea ff ff       	call   80db57 <sys_sem_signal>
  }
}
  80f097:	83 c4 14             	add    $0x14,%esp
  80f09a:	5b                   	pop    %ebx
  80f09b:	5d                   	pop    %ebp
  80f09c:	c3                   	ret    

0080f09d <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80f09d:	55                   	push   %ebp
  80f09e:	89 e5                	mov    %esp,%ebp
  80f0a0:	57                   	push   %edi
  80f0a1:	56                   	push   %esi
  80f0a2:	53                   	push   %ebx
  80f0a3:	83 ec 2c             	sub    $0x2c,%esp
  80f0a6:	89 c3                	mov    %eax,%ebx
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80f0a8:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80f0ac:	74 1c                	je     80f0ca <do_writemore+0x2d>
  80f0ae:	c7 44 24 08 ba 4a 81 	movl   $0x814aba,0x8(%esp)
  80f0b5:	00 
  80f0b6:	c7 44 24 04 b8 03 00 	movl   $0x3b8,0x4(%esp)
  80f0bd:	00 
  80f0be:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80f0c5:	e8 1e 19 ff ff       	call   8009e8 <_panic>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80f0ca:	8b 50 24             	mov    0x24(%eax),%edx
  80f0cd:	8b 42 04             	mov    0x4(%edx),%eax
  80f0d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80f0d3:	8b 43 28             	mov    0x28(%ebx),%eax
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80f0d6:	8b 72 08             	mov    0x8(%edx),%esi
  80f0d9:	89 f1                	mov    %esi,%ecx
  80f0db:	29 c1                	sub    %eax,%ecx
  80f0dd:	66 29 c6             	sub    %ax,%si
  80f0e0:	66 89 75 e2          	mov    %si,-0x1e(%ebp)
  80f0e4:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80f0ea:	0f 9c c1             	setl   %cl
  80f0ed:	0f b6 f1             	movzbl %cl,%esi
  80f0f0:	83 ee 01             	sub    $0x1,%esi
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80f0f3:	8b 4b 08             	mov    0x8(%ebx),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80f0f6:	0f b7 79 6e          	movzwl 0x6e(%ecx),%edi
  80f0fa:	66 0b 75 e2          	or     -0x1e(%ebp),%si
  80f0fe:	66 39 fe             	cmp    %di,%si
  80f101:	76 02                	jbe    80f105 <do_writemore+0x68>
  80f103:	89 fe                	mov    %edi,%esi
  80f105:	0f b7 f6             	movzwl %si,%esi
  80f108:	0f b6 52 0c          	movzbl 0xc(%edx),%edx
  80f10c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f110:	89 74 24 08          	mov    %esi,0x8(%esp)
  80f114:	03 45 e4             	add    -0x1c(%ebp),%eax
  80f117:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f11b:	89 0c 24             	mov    %ecx,(%esp)
  80f11e:	e8 16 ce ff ff       	call   80bf39 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80f123:	89 f2                	mov    %esi,%edx
  80f125:	03 53 28             	add    0x28(%ebx),%edx
  80f128:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80f12b:	3b 51 08             	cmp    0x8(%ecx),%edx
  80f12e:	7e 1c                	jle    80f14c <do_writemore+0xaf>
  80f130:	c7 44 24 08 d7 4a 81 	movl   $0x814ad7,0x8(%esp)
  80f137:	00 
  80f138:	c7 44 24 04 cd 03 00 	movl   $0x3cd,0x4(%esp)
  80f13f:	00 
  80f140:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80f147:	e8 9c 18 ff ff       	call   8009e8 <_panic>
  if (err == ERR_OK) {
  80f14c:	84 c0                	test   %al,%al
  80f14e:	75 72                	jne    80f1c2 <do_writemore+0x125>
    conn->write_offset += len;
  80f150:	89 53 28             	mov    %edx,0x28(%ebx)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80f153:	8b 43 24             	mov    0x24(%ebx),%eax
  80f156:	bf 00 00 00 00       	mov    $0x0,%edi
  80f15b:	3b 50 08             	cmp    0x8(%eax),%edx
  80f15e:	75 13                	jne    80f173 <do_writemore+0xd6>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80f160:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80f167:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
  80f16e:	bf 01 00 00 00       	mov    $0x1,%edi
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80f173:	8b 43 08             	mov    0x8(%ebx),%eax
  80f176:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80f17a:	74 12                	je     80f18e <do_writemore+0xf1>
  80f17c:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80f180:	75 0c                	jne    80f18e <do_writemore+0xf1>
  80f182:	8b 50 74             	mov    0x74(%eax),%edx
  80f185:	85 d2                	test   %edx,%edx
  80f187:	74 78                	je     80f201 <do_writemore+0x164>
  80f189:	83 3a 00             	cmpl   $0x0,(%edx)
  80f18c:	74 73                	je     80f201 <do_writemore+0x164>
  80f18e:	89 04 24             	mov    %eax,(%esp)
  80f191:	e8 65 c1 ff ff       	call   80b2fb <tcp_output>
    conn->err = err;
  80f196:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80f199:	84 c0                	test   %al,%al
  80f19b:	75 3f                	jne    80f1dc <do_writemore+0x13f>
  80f19d:	8b 43 08             	mov    0x8(%ebx),%eax
  80f1a0:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80f1a6:	77 34                	ja     80f1dc <do_writemore+0x13f>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80f1a8:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f1ab:	85 c0                	test   %eax,%eax
  80f1ad:	74 2d                	je     80f1dc <do_writemore+0x13f>
  80f1af:	89 74 24 08          	mov    %esi,0x8(%esp)
  80f1b3:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80f1ba:	00 
  80f1bb:	89 1c 24             	mov    %ebx,(%esp)
  80f1be:	ff d0                	call   *%eax
  80f1c0:	eb 1a                	jmp    80f1dc <do_writemore+0x13f>
    }
  } else if (err == ERR_MEM) {
  80f1c2:	3c ff                	cmp    $0xff,%al
  80f1c4:	75 11                	jne    80f1d7 <do_writemore+0x13a>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80f1c6:	8b 43 08             	mov    0x8(%ebx),%eax
  80f1c9:	89 04 24             	mov    %eax,(%esp)
  80f1cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f1d0:	e8 26 c1 ff ff       	call   80b2fb <tcp_output>
  80f1d5:	eb 1d                	jmp    80f1f4 <do_writemore+0x157>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80f1d7:	88 43 0c             	mov    %al,0xc(%ebx)
  80f1da:	eb 06                	jmp    80f1e2 <do_writemore+0x145>
    write_finished = 1;
  }

  if (write_finished) {
  80f1dc:	89 f8                	mov    %edi,%eax
  80f1de:	84 c0                	test   %al,%al
  80f1e0:	74 12                	je     80f1f4 <do_writemore+0x157>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80f1e2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80f1e9:	8b 43 10             	mov    0x10(%ebx),%eax
  80f1ec:	89 04 24             	mov    %eax,(%esp)
  80f1ef:	e8 63 e9 ff ff       	call   80db57 <sys_sem_signal>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80f1f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80f1f9:	83 c4 2c             	add    $0x2c,%esp
  80f1fc:	5b                   	pop    %ebx
  80f1fd:	5e                   	pop    %esi
  80f1fe:	5f                   	pop    %edi
  80f1ff:	5d                   	pop    %ebp
  80f200:	c3                   	ret    
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80f201:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80f205:	eb 96                	jmp    80f19d <do_writemore+0x100>

0080f207 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80f207:	55                   	push   %ebp
  80f208:	89 e5                	mov    %esp,%ebp
  80f20a:	83 ec 18             	sub    $0x18,%esp
  struct netconn *conn = arg;
  80f20d:	8b 45 08             	mov    0x8(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80f210:	85 c0                	test   %eax,%eax
  80f212:	75 1c                	jne    80f230 <poll_tcp+0x29>
  80f214:	c7 44 24 08 ad 4a 81 	movl   $0x814aad,0x8(%esp)
  80f21b:	00 
  80f21c:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
  80f223:	00 
  80f224:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80f22b:	e8 b8 17 ff ff       	call   8009e8 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80f230:	8b 50 04             	mov    0x4(%eax),%edx
  80f233:	83 fa 01             	cmp    $0x1,%edx
  80f236:	75 0a                	jne    80f242 <poll_tcp+0x3b>
    do_writemore(conn);
  80f238:	e8 60 fe ff ff       	call   80f09d <do_writemore>
  80f23d:	8d 76 00             	lea    0x0(%esi),%esi
  80f240:	eb 13                	jmp    80f255 <poll_tcp+0x4e>
  } else if (conn->state == NETCONN_CLOSE) {
  80f242:	83 fa 04             	cmp    $0x4,%edx
  80f245:	75 0e                	jne    80f255 <poll_tcp+0x4e>
    do_close_internal(conn);
  80f247:	89 f6                	mov    %esi,%esi
  80f249:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  80f250:	e8 2e fb ff ff       	call   80ed83 <do_close_internal>
  }

  return ERR_OK;
}
  80f255:	b8 00 00 00 00       	mov    $0x0,%eax
  80f25a:	c9                   	leave  
  80f25b:	c3                   	ret    

0080f25c <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80f25c:	55                   	push   %ebp
  80f25d:	89 e5                	mov    %esp,%ebp
  80f25f:	83 ec 18             	sub    $0x18,%esp
  80f262:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f265:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f268:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct netconn *conn = arg;
  80f26c:	8b 5d 08             	mov    0x8(%ebp),%ebx

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80f26f:	85 db                	test   %ebx,%ebx
  80f271:	75 1c                	jne    80f28f <sent_tcp+0x33>
  80f273:	c7 44 24 08 ad 4a 81 	movl   $0x814aad,0x8(%esp)
  80f27a:	00 
  80f27b:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
  80f282:	00 
  80f283:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80f28a:	e8 59 17 ff ff       	call   8009e8 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80f28f:	8b 43 04             	mov    0x4(%ebx),%eax
  80f292:	83 f8 01             	cmp    $0x1,%eax
  80f295:	75 2b                	jne    80f2c2 <sent_tcp+0x66>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80f297:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80f29b:	75 1c                	jne    80f2b9 <sent_tcp+0x5d>
  80f29d:	c7 44 24 08 f5 4a 81 	movl   $0x814af5,0x8(%esp)
  80f2a4:	00 
  80f2a5:	c7 44 24 04 06 01 00 	movl   $0x106,0x4(%esp)
  80f2ac:	00 
  80f2ad:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80f2b4:	e8 2f 17 ff ff       	call   8009e8 <_panic>
    do_writemore(conn);
  80f2b9:	89 d8                	mov    %ebx,%eax
  80f2bb:	e8 dd fd ff ff       	call   80f09d <do_writemore>
  80f2c0:	eb 13                	jmp    80f2d5 <sent_tcp+0x79>
  } else if (conn->state == NETCONN_CLOSE) {
  80f2c2:	83 f8 04             	cmp    $0x4,%eax
  80f2c5:	75 0e                	jne    80f2d5 <sent_tcp+0x79>
    do_close_internal(conn);
  80f2c7:	89 d8                	mov    %ebx,%eax
  80f2c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80f2d0:	e8 ae fa ff ff       	call   80ed83 <do_close_internal>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80f2d5:	8b 43 08             	mov    0x8(%ebx),%eax
  80f2d8:	85 c0                	test   %eax,%eax
  80f2da:	74 23                	je     80f2ff <sent_tcp+0xa3>
  80f2dc:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80f2e2:	76 1b                	jbe    80f2ff <sent_tcp+0xa3>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80f2e4:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f2e7:	85 c0                	test   %eax,%eax
  80f2e9:	74 14                	je     80f2ff <sent_tcp+0xa3>
  80f2eb:	0f b7 f6             	movzwl %si,%esi
  80f2ee:	89 74 24 08          	mov    %esi,0x8(%esp)
  80f2f2:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80f2f9:	00 
  80f2fa:	89 1c 24             	mov    %ebx,(%esp)
  80f2fd:	ff d0                	call   *%eax
    }
  }
  
  return ERR_OK;
}
  80f2ff:	b8 00 00 00 00       	mov    $0x0,%eax
  80f304:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f307:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f30a:	89 ec                	mov    %ebp,%esp
  80f30c:	5d                   	pop    %ebp
  80f30d:	c3                   	ret    

0080f30e <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80f30e:	55                   	push   %ebp
  80f30f:	89 e5                	mov    %esp,%ebp
  80f311:	83 ec 18             	sub    $0x18,%esp
  80f314:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f317:	8b 02                	mov    (%edx),%eax
  80f319:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80f31d:	7c 2d                	jl     80f34c <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80f31f:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80f323:	74 23                	je     80f348 <do_write+0x3a>
  80f325:	83 38 10             	cmpl   $0x10,(%eax)
  80f328:	75 1e                	jne    80f348 <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80f32a:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80f331:	8b 02                	mov    (%edx),%eax
  80f333:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80f336:	8b 02                	mov    (%edx),%eax
  80f338:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80f33f:	8b 02                	mov    (%edx),%eax
  80f341:	e8 57 fd ff ff       	call   80f09d <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80f346:	eb 11                	jmp    80f359 <do_write+0x4b>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80f348:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f34c:	8b 02                	mov    (%edx),%eax
  80f34e:	8b 40 10             	mov    0x10(%eax),%eax
  80f351:	89 04 24             	mov    %eax,(%esp)
  80f354:	e8 fe e7 ff ff       	call   80db57 <sys_sem_signal>
}
  80f359:	c9                   	leave  
  80f35a:	c3                   	ret    

0080f35b <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80f35b:	55                   	push   %ebp
  80f35c:	89 e5                	mov    %esp,%ebp
  80f35e:	53                   	push   %ebx
  80f35f:	83 ec 14             	sub    $0x14,%esp
  80f362:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f365:	8b 03                	mov    (%ebx),%eax
  80f367:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80f36b:	7c 1c                	jl     80f389 <do_recv+0x2e>
    if (msg->conn->pcb.tcp != NULL) {
  80f36d:	8b 50 08             	mov    0x8(%eax),%edx
  80f370:	85 d2                	test   %edx,%edx
  80f372:	74 15                	je     80f389 <do_recv+0x2e>
      if (msg->conn->type == NETCONN_TCP) {
  80f374:	83 38 10             	cmpl   $0x10,(%eax)
  80f377:	75 10                	jne    80f389 <do_recv+0x2e>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80f379:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80f37d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f381:	89 14 24             	mov    %edx,(%esp)
  80f384:	e8 0d 95 ff ff       	call   808896 <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80f389:	8b 03                	mov    (%ebx),%eax
  80f38b:	8b 40 10             	mov    0x10(%eax),%eax
  80f38e:	89 04 24             	mov    %eax,(%esp)
  80f391:	e8 c1 e7 ff ff       	call   80db57 <sys_sem_signal>
}
  80f396:	83 c4 14             	add    $0x14,%esp
  80f399:	5b                   	pop    %ebx
  80f39a:	5d                   	pop    %ebp
  80f39b:	c3                   	ret    

0080f39c <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80f39c:	55                   	push   %ebp
  80f39d:	89 e5                	mov    %esp,%ebp
  80f39f:	83 ec 28             	sub    $0x28,%esp
  80f3a2:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f3a5:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f3a8:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f3ab:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f3ae:	8b 1e                	mov    (%esi),%ebx
  80f3b0:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80f3b4:	0f 8c 8b 00 00 00    	jl     80f445 <do_send+0xa9>
    if (msg->conn->pcb.tcp != NULL) {
  80f3ba:	8b 43 08             	mov    0x8(%ebx),%eax
  80f3bd:	85 c0                	test   %eax,%eax
  80f3bf:	0f 84 80 00 00 00    	je     80f445 <do_send+0xa9>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f3c5:	8b 13                	mov    (%ebx),%edx
  80f3c7:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80f3cd:	83 fa 20             	cmp    $0x20,%edx
  80f3d0:	74 39                	je     80f40b <do_send+0x6f>
  80f3d2:	83 fa 40             	cmp    $0x40,%edx
  80f3d5:	75 6e                	jne    80f445 <do_send+0xa9>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80f3d7:	8b 56 04             	mov    0x4(%esi),%edx
  80f3da:	8b 4a 08             	mov    0x8(%edx),%ecx
  80f3dd:	85 c9                	test   %ecx,%ecx
  80f3df:	75 13                	jne    80f3f4 <do_send+0x58>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80f3e1:	8b 12                	mov    (%edx),%edx
  80f3e3:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f3e7:	89 04 24             	mov    %eax,(%esp)
  80f3ea:	e8 43 27 00 00       	call   811b32 <raw_send>
  80f3ef:	88 43 0c             	mov    %al,0xc(%ebx)
  80f3f2:	eb 51                	jmp    80f445 <do_send+0xa9>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80f3f4:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80f3f8:	8b 12                	mov    (%edx),%edx
  80f3fa:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f3fe:	89 04 24             	mov    %eax,(%esp)
  80f401:	e8 22 26 00 00       	call   811a28 <raw_sendto>
  80f406:	88 43 0c             	mov    %al,0xc(%ebx)
  80f409:	eb 3a                	jmp    80f445 <do_send+0xa9>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80f40b:	8b 56 04             	mov    0x4(%esi),%edx
  80f40e:	8b 4a 08             	mov    0x8(%edx),%ecx
  80f411:	85 c9                	test   %ecx,%ecx
  80f413:	75 13                	jne    80f428 <do_send+0x8c>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80f415:	8b 12                	mov    (%edx),%edx
  80f417:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f41b:	89 04 24             	mov    %eax,(%esp)
  80f41e:	e8 db cf ff ff       	call   80c3fe <udp_send>
  80f423:	88 43 0c             	mov    %al,0xc(%ebx)
  80f426:	eb 1d                	jmp    80f445 <do_send+0xa9>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80f428:	0f b7 7a 0c          	movzwl 0xc(%edx),%edi
  80f42c:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80f430:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80f434:	8b 12                	mov    (%edx),%edx
  80f436:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f43a:	89 04 24             	mov    %eax,(%esp)
  80f43d:	e8 6b cf ff ff       	call   80c3ad <udp_sendto>
  80f442:	88 43 0c             	mov    %al,0xc(%ebx)
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f445:	8b 06                	mov    (%esi),%eax
  80f447:	8b 40 10             	mov    0x10(%eax),%eax
  80f44a:	89 04 24             	mov    %eax,(%esp)
  80f44d:	e8 05 e7 ff ff       	call   80db57 <sys_sem_signal>
}
  80f452:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f455:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f458:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f45b:	89 ec                	mov    %ebp,%esp
  80f45d:	5d                   	pop    %ebp
  80f45e:	c3                   	ret    

0080f45f <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80f45f:	55                   	push   %ebp
  80f460:	89 e5                	mov    %esp,%ebp
  80f462:	83 ec 28             	sub    $0x28,%esp
  80f465:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f468:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f46b:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f46e:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f471:	8b 03                	mov    (%ebx),%eax
  80f473:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80f477:	0f 8c b9 00 00 00    	jl     80f536 <do_listen+0xd7>
    if (msg->conn->pcb.tcp != NULL) {
  80f47d:	8b 50 08             	mov    0x8(%eax),%edx
  80f480:	85 d2                	test   %edx,%edx
  80f482:	0f 84 ae 00 00 00    	je     80f536 <do_listen+0xd7>
      if (msg->conn->type == NETCONN_TCP) {
  80f488:	83 38 10             	cmpl   $0x10,(%eax)
  80f48b:	0f 85 a5 00 00 00    	jne    80f536 <do_listen+0xd7>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80f491:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80f495:	0f 85 97 00 00 00    	jne    80f532 <do_listen+0xd3>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80f49b:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80f4a2:	00 
  80f4a3:	89 14 24             	mov    %edx,(%esp)
  80f4a6:	e8 2e 97 ff ff       	call   808bd9 <tcp_listen_with_backlog>
  80f4ab:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80f4ad:	85 c0                	test   %eax,%eax
  80f4af:	75 08                	jne    80f4b9 <do_listen+0x5a>
            msg->conn->err = ERR_MEM;
  80f4b1:	8b 03                	mov    (%ebx),%eax
  80f4b3:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80f4b7:	eb 7d                	jmp    80f536 <do_listen+0xd7>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80f4b9:	8b 03                	mov    (%ebx),%eax
  80f4bb:	8b 40 14             	mov    0x14(%eax),%eax
  80f4be:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f4c1:	74 11                	je     80f4d4 <do_listen+0x75>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80f4c3:	89 04 24             	mov    %eax,(%esp)
  80f4c6:	e8 ba e0 ff ff       	call   80d585 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80f4cb:	8b 03                	mov    (%ebx),%eax
  80f4cd:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80f4d4:	8b 3b                	mov    (%ebx),%edi
  80f4d6:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80f4da:	75 1a                	jne    80f4f6 <do_listen+0x97>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80f4dc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f4e3:	e8 57 e5 ff ff       	call   80da3f <sys_mbox_new>
  80f4e8:	89 47 18             	mov    %eax,0x18(%edi)
  80f4eb:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f4ee:	75 06                	jne    80f4f6 <do_listen+0x97>
                msg->conn->err = ERR_MEM;
  80f4f0:	8b 03                	mov    (%ebx),%eax
  80f4f2:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80f4f6:	8b 03                	mov    (%ebx),%eax
  80f4f8:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80f4fc:	75 38                	jne    80f536 <do_listen+0xd7>
              msg->conn->state = NETCONN_LISTEN;
  80f4fe:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80f505:	8b 03                	mov    (%ebx),%eax
  80f507:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80f50a:	8b 03                	mov    (%ebx),%eax
  80f50c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f510:	8b 40 08             	mov    0x8(%eax),%eax
  80f513:	89 04 24             	mov    %eax,(%esp)
  80f516:	e8 cb 92 ff ff       	call   8087e6 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80f51b:	c7 44 24 04 34 fb 80 	movl   $0x80fb34,0x4(%esp)
  80f522:	00 
  80f523:	8b 03                	mov    (%ebx),%eax
  80f525:	8b 40 08             	mov    0x8(%eax),%eax
  80f528:	89 04 24             	mov    %eax,(%esp)
  80f52b:	e8 f7 92 ff ff       	call   808827 <tcp_accept>
  80f530:	eb 04                	jmp    80f536 <do_listen+0xd7>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80f532:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80f536:	8b 03                	mov    (%ebx),%eax
  80f538:	8b 40 10             	mov    0x10(%eax),%eax
  80f53b:	89 04 24             	mov    %eax,(%esp)
  80f53e:	e8 14 e6 ff ff       	call   80db57 <sys_sem_signal>
}
  80f543:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f546:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f549:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f54c:	89 ec                	mov    %ebp,%esp
  80f54e:	5d                   	pop    %ebp
  80f54f:	c3                   	ret    

0080f550 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80f550:	55                   	push   %ebp
  80f551:	89 e5                	mov    %esp,%ebp
  80f553:	83 ec 18             	sub    $0x18,%esp
  80f556:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f559:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f55c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80f55f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f562:	8b 75 10             	mov    0x10(%ebp),%esi
  80f565:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80f569:	85 c0                	test   %eax,%eax
  80f56b:	75 1c                	jne    80f589 <recv_tcp+0x39>
  80f56d:	c7 44 24 08 90 4b 81 	movl   $0x814b90,0x8(%esp)
  80f574:	00 
  80f575:	c7 44 24 04 c1 00 00 	movl   $0xc1,0x4(%esp)
  80f57c:	00 
  80f57d:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80f584:	e8 5f 14 ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80f589:	85 db                	test   %ebx,%ebx
  80f58b:	75 1c                	jne    80f5a9 <recv_tcp+0x59>
  80f58d:	c7 44 24 08 b4 4b 81 	movl   $0x814bb4,0x8(%esp)
  80f594:	00 
  80f595:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  80f59c:	00 
  80f59d:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80f5a4:	e8 3f 14 ff ff       	call   8009e8 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80f5a9:	39 43 08             	cmp    %eax,0x8(%ebx)
  80f5ac:	74 1c                	je     80f5ca <recv_tcp+0x7a>
  80f5ae:	c7 44 24 08 0b 4b 81 	movl   $0x814b0b,0x8(%esp)
  80f5b5:	00 
  80f5b6:	c7 44 24 04 c4 00 00 	movl   $0xc4,0x4(%esp)
  80f5bd:	00 
  80f5be:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80f5c5:	e8 1e 14 ff ff       	call   8009e8 <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80f5ca:	85 db                	test   %ebx,%ebx
  80f5cc:	74 4c                	je     80f61a <recv_tcp+0xca>
  80f5ce:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f5d2:	74 46                	je     80f61a <recv_tcp+0xca>
    return ERR_VAL;
  }

  conn->err = err;
  80f5d4:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80f5d7:	b8 00 00 00 00       	mov    $0x0,%eax
  80f5dc:	85 f6                	test   %esi,%esi
  80f5de:	74 08                	je     80f5e8 <recv_tcp+0x98>
    len = p->tot_len;
  80f5e0:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80f5e4:	66 01 43 20          	add    %ax,0x20(%ebx)
  } else {
    len = 0;
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80f5e8:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80f5eb:	85 d2                	test   %edx,%edx
  80f5ed:	74 14                	je     80f603 <recv_tcp+0xb3>
  80f5ef:	0f b7 c0             	movzwl %ax,%eax
  80f5f2:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f5f6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f5fd:	00 
  80f5fe:	89 1c 24             	mov    %ebx,(%esp)
  80f601:	ff d2                	call   *%edx
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80f603:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f607:	8b 43 14             	mov    0x14(%ebx),%eax
  80f60a:	89 04 24             	mov    %eax,(%esp)
  80f60d:	e8 e0 e6 ff ff       	call   80dcf2 <sys_mbox_trypost>
  80f612:	3c 01                	cmp    $0x1,%al
  80f614:	19 c0                	sbb    %eax,%eax
  80f616:	f7 d0                	not    %eax
  80f618:	eb 05                	jmp    80f61f <recv_tcp+0xcf>
  80f61a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80f61f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f622:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f625:	89 ec                	mov    %ebp,%esp
  80f627:	5d                   	pop    %ebp
  80f628:	c3                   	ret    

0080f629 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80f629:	55                   	push   %ebp
  80f62a:	89 e5                	mov    %esp,%ebp
  80f62c:	53                   	push   %ebx
  80f62d:	83 ec 14             	sub    $0x14,%esp
  80f630:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80f633:	8b 03                	mov    (%ebx),%eax
  80f635:	8b 10                	mov    (%eax),%edx
  80f637:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80f63d:	83 fa 20             	cmp    $0x20,%edx
  80f640:	75 0b                	jne    80f64d <do_disconnect+0x24>
    udp_disconnect(msg->conn->pcb.udp);
  80f642:	8b 40 08             	mov    0x8(%eax),%eax
  80f645:	89 04 24             	mov    %eax,(%esp)
  80f648:	e8 b3 c9 ff ff       	call   80c000 <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80f64d:	8b 03                	mov    (%ebx),%eax
  80f64f:	8b 40 10             	mov    0x10(%eax),%eax
  80f652:	89 04 24             	mov    %eax,(%esp)
  80f655:	e8 fd e4 ff ff       	call   80db57 <sys_sem_signal>
}
  80f65a:	83 c4 14             	add    $0x14,%esp
  80f65d:	5b                   	pop    %ebx
  80f65e:	5d                   	pop    %ebp
  80f65f:	c3                   	ret    

0080f660 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80f660:	55                   	push   %ebp
  80f661:	89 e5                	mov    %esp,%ebp
  80f663:	56                   	push   %esi
  80f664:	53                   	push   %ebx
  80f665:	83 ec 10             	sub    $0x10,%esp
  80f668:	8b 75 08             	mov    0x8(%ebp),%esi
  if (msg->conn->pcb.tcp == NULL) {
  80f66b:	8b 1e                	mov    (%esi),%ebx
  80f66d:	8b 53 08             	mov    0x8(%ebx),%edx
  80f670:	85 d2                	test   %edx,%edx
  80f672:	75 10                	jne    80f684 <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80f674:	8b 43 10             	mov    0x10(%ebx),%eax
  80f677:	89 04 24             	mov    %eax,(%esp)
  80f67a:	e8 d8 e4 ff ff       	call   80db57 <sys_sem_signal>
    return;
  80f67f:	e9 9d 00 00 00       	jmp    80f721 <do_connect+0xc1>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f684:	8b 03                	mov    (%ebx),%eax
  80f686:	25 f0 00 00 00       	and    $0xf0,%eax
  80f68b:	83 f8 20             	cmp    $0x20,%eax
  80f68e:	74 33                	je     80f6c3 <do_connect+0x63>
  80f690:	83 f8 40             	cmp    $0x40,%eax
  80f693:	74 0d                	je     80f6a2 <do_connect+0x42>
  80f695:	83 f8 10             	cmp    $0x10,%eax
  80f698:	0f 85 83 00 00 00    	jne    80f721 <do_connect+0xc1>
  80f69e:	66 90                	xchg   %ax,%ax
  80f6a0:	eb 4a                	jmp    80f6ec <do_connect+0x8c>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80f6a2:	8b 46 04             	mov    0x4(%esi),%eax
  80f6a5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f6a9:	89 14 24             	mov    %edx,(%esp)
  80f6ac:	e8 9c 22 00 00       	call   81194d <raw_connect>
  80f6b1:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80f6b4:	8b 06                	mov    (%esi),%eax
  80f6b6:	8b 40 10             	mov    0x10(%eax),%eax
  80f6b9:	89 04 24             	mov    %eax,(%esp)
  80f6bc:	e8 96 e4 ff ff       	call   80db57 <sys_sem_signal>
    break;
  80f6c1:	eb 5e                	jmp    80f721 <do_connect+0xc1>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f6c3:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f6c7:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f6cb:	8b 46 04             	mov    0x4(%esi),%eax
  80f6ce:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f6d2:	89 14 24             	mov    %edx,(%esp)
  80f6d5:	e8 a4 ca ff ff       	call   80c17e <udp_connect>
  80f6da:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80f6dd:	8b 06                	mov    (%esi),%eax
  80f6df:	8b 40 10             	mov    0x10(%eax),%eax
  80f6e2:	89 04 24             	mov    %eax,(%esp)
  80f6e5:	e8 6d e4 ff ff       	call   80db57 <sys_sem_signal>
    break;
  80f6ea:	eb 35                	jmp    80f721 <do_connect+0xc1>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80f6ec:	c7 43 04 03 00 00 00 	movl   $0x3,0x4(%ebx)
    setup_tcp(msg->conn);
  80f6f3:	8b 06                	mov    (%esi),%eax
  80f6f5:	e8 de f5 ff ff       	call   80ecd8 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80f6fa:	8b 1e                	mov    (%esi),%ebx
  80f6fc:	c7 44 24 0c 3c ed 80 	movl   $0x80ed3c,0xc(%esp)
  80f703:	00 
  80f704:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f708:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f70c:	8b 46 04             	mov    0x4(%esi),%eax
  80f70f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f713:	8b 43 08             	mov    0x8(%ebx),%eax
  80f716:	89 04 24             	mov    %eax,(%esp)
  80f719:	e8 05 97 ff ff       	call   808e23 <tcp_connect>
  80f71e:	88 43 0c             	mov    %al,0xc(%ebx)
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80f721:	83 c4 10             	add    $0x10,%esp
  80f724:	5b                   	pop    %ebx
  80f725:	5e                   	pop    %esi
  80f726:	5d                   	pop    %ebp
  80f727:	c3                   	ret    

0080f728 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80f728:	55                   	push   %ebp
  80f729:	89 e5                	mov    %esp,%ebp
  80f72b:	83 ec 18             	sub    $0x18,%esp
  80f72e:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f731:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f734:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f737:	8b 1e                	mov    (%esi),%ebx
  80f739:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80f73d:	7c 73                	jl     80f7b2 <do_bind+0x8a>
    if (msg->conn->pcb.tcp != NULL) {
  80f73f:	8b 53 08             	mov    0x8(%ebx),%edx
  80f742:	85 d2                	test   %edx,%edx
  80f744:	74 68                	je     80f7ae <do_bind+0x86>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f746:	8b 03                	mov    (%ebx),%eax
  80f748:	25 f0 00 00 00       	and    $0xf0,%eax
  80f74d:	83 f8 20             	cmp    $0x20,%eax
  80f750:	74 24                	je     80f776 <do_bind+0x4e>
  80f752:	83 f8 40             	cmp    $0x40,%eax
  80f755:	74 0b                	je     80f762 <do_bind+0x3a>
  80f757:	83 f8 10             	cmp    $0x10,%eax
  80f75a:	75 56                	jne    80f7b2 <do_bind+0x8a>
  80f75c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f760:	eb 30                	jmp    80f792 <do_bind+0x6a>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80f762:	8b 46 04             	mov    0x4(%esi),%eax
  80f765:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f769:	89 14 24             	mov    %edx,(%esp)
  80f76c:	e8 bf 21 00 00       	call   811930 <raw_bind>
  80f771:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80f774:	eb 3c                	jmp    80f7b2 <do_bind+0x8a>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f776:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f77a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f77e:	8b 46 04             	mov    0x4(%esi),%eax
  80f781:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f785:	89 14 24             	mov    %edx,(%esp)
  80f788:	e8 2b c9 ff ff       	call   80c0b8 <udp_bind>
  80f78d:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80f790:	eb 20                	jmp    80f7b2 <do_bind+0x8a>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f792:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f796:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f79a:	8b 46 04             	mov    0x4(%esi),%eax
  80f79d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f7a1:	89 14 24             	mov    %edx,(%esp)
  80f7a4:	e8 35 95 ff ff       	call   808cde <tcp_bind>
  80f7a9:	88 43 0c             	mov    %al,0xc(%ebx)
  80f7ac:	eb 04                	jmp    80f7b2 <do_bind+0x8a>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80f7ae:	c6 43 0c f7          	movb   $0xf7,0xc(%ebx)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f7b2:	8b 06                	mov    (%esi),%eax
  80f7b4:	8b 40 10             	mov    0x10(%eax),%eax
  80f7b7:	89 04 24             	mov    %eax,(%esp)
  80f7ba:	e8 98 e3 ff ff       	call   80db57 <sys_sem_signal>
}
  80f7bf:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f7c2:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f7c5:	89 ec                	mov    %ebp,%esp
  80f7c7:	5d                   	pop    %ebp
  80f7c8:	c3                   	ret    

0080f7c9 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80f7c9:	55                   	push   %ebp
  80f7ca:	89 e5                	mov    %esp,%ebp
  80f7cc:	53                   	push   %ebx
  80f7cd:	83 ec 14             	sub    $0x14,%esp
  80f7d0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80f7d3:	8b 03                	mov    (%ebx),%eax
  80f7d5:	8b 48 08             	mov    0x8(%eax),%ecx
  80f7d8:	85 c9                	test   %ecx,%ecx
  80f7da:	74 51                	je     80f82d <do_delconn+0x64>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f7dc:	8b 10                	mov    (%eax),%edx
  80f7de:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80f7e4:	83 fa 20             	cmp    $0x20,%edx
  80f7e7:	74 1e                	je     80f807 <do_delconn+0x3e>
  80f7e9:	83 fa 40             	cmp    $0x40,%edx
  80f7ec:	74 0c                	je     80f7fa <do_delconn+0x31>
  80f7ee:	83 fa 10             	cmp    $0x10,%edx
  80f7f1:	75 3a                	jne    80f82d <do_delconn+0x64>
  80f7f3:	90                   	nop
  80f7f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f7f8:	eb 23                	jmp    80f81d <do_delconn+0x54>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80f7fa:	89 0c 24             	mov    %ecx,(%esp)
  80f7fd:	8d 76 00             	lea    0x0(%esi),%esi
  80f800:	e8 d7 21 00 00       	call   8119dc <raw_remove>
      break;
  80f805:	eb 26                	jmp    80f82d <do_delconn+0x64>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80f807:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80f80e:	8b 03                	mov    (%ebx),%eax
  80f810:	8b 40 08             	mov    0x8(%eax),%eax
  80f813:	89 04 24             	mov    %eax,(%esp)
  80f816:	e8 51 c8 ff ff       	call   80c06c <udp_remove>
      break;
  80f81b:	eb 10                	jmp    80f82d <do_delconn+0x64>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80f81d:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80f824:	8b 03                	mov    (%ebx),%eax
  80f826:	e8 58 f5 ff ff       	call   80ed83 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80f82b:	eb 4e                	jmp    80f87b <do_delconn+0xb2>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80f82d:	8b 13                	mov    (%ebx),%edx
  80f82f:	8b 42 2c             	mov    0x2c(%edx),%eax
  80f832:	85 c0                	test   %eax,%eax
  80f834:	74 33                	je     80f869 <do_delconn+0xa0>
  80f836:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f83d:	00 
  80f83e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f845:	00 
  80f846:	89 14 24             	mov    %edx,(%esp)
  80f849:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80f84b:	8b 13                	mov    (%ebx),%edx
  80f84d:	8b 42 2c             	mov    0x2c(%edx),%eax
  80f850:	85 c0                	test   %eax,%eax
  80f852:	74 15                	je     80f869 <do_delconn+0xa0>
  80f854:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f85b:	00 
  80f85c:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80f863:	00 
  80f864:	89 14 24             	mov    %edx,(%esp)
  80f867:	ff d0                	call   *%eax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80f869:	8b 03                	mov    (%ebx),%eax
  80f86b:	8b 40 10             	mov    0x10(%eax),%eax
  80f86e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f871:	74 08                	je     80f87b <do_delconn+0xb2>
    sys_sem_signal(msg->conn->op_completed);
  80f873:	89 04 24             	mov    %eax,(%esp)
  80f876:	e8 dc e2 ff ff       	call   80db57 <sys_sem_signal>
  }
}
  80f87b:	83 c4 14             	add    $0x14,%esp
  80f87e:	5b                   	pop    %ebx
  80f87f:	5d                   	pop    %ebp
  80f880:	c3                   	ret    

0080f881 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80f881:	55                   	push   %ebp
  80f882:	89 e5                	mov    %esp,%ebp
  80f884:	56                   	push   %esi
  80f885:	53                   	push   %ebx
  80f886:	83 ec 20             	sub    $0x20,%esp
  80f889:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80f88c:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80f890:	74 1c                	je     80f8ae <netconn_free+0x2d>
  80f892:	c7 44 24 08 d4 4b 81 	movl   $0x814bd4,0x8(%esp)
  80f899:	00 
  80f89a:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
  80f8a1:	00 
  80f8a2:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80f8a9:	e8 3a 11 ff ff       	call   8009e8 <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80f8ae:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80f8b1:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f8b5:	75 27                	jne    80f8de <netconn_free+0x5d>
  80f8b7:	eb 4b                	jmp    80f904 <netconn_free+0x83>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80f8b9:	83 3b 10             	cmpl   $0x10,(%ebx)
  80f8bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f8c0:	75 11                	jne    80f8d3 <netconn_free+0x52>
        if(mem != NULL) {
  80f8c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f8c5:	85 c0                	test   %eax,%eax
  80f8c7:	74 15                	je     80f8de <netconn_free+0x5d>
          pbuf_free((struct pbuf *)mem);
  80f8c9:	89 04 24             	mov    %eax,(%esp)
  80f8cc:	e8 a7 85 ff ff       	call   807e78 <pbuf_free>
  80f8d1:	eb 0b                	jmp    80f8de <netconn_free+0x5d>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80f8d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f8d6:	89 04 24             	mov    %eax,(%esp)
  80f8d9:	e8 c0 5c ff ff       	call   80559e <netbuf_delete>
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80f8de:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f8e2:	8b 43 14             	mov    0x14(%ebx),%eax
  80f8e5:	89 04 24             	mov    %eax,(%esp)
  80f8e8:	e8 e3 e3 ff ff       	call   80dcd0 <sys_arch_mbox_tryfetch>
  80f8ed:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f8f0:	75 c7                	jne    80f8b9 <netconn_free+0x38>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80f8f2:	8b 43 14             	mov    0x14(%ebx),%eax
  80f8f5:	89 04 24             	mov    %eax,(%esp)
  80f8f8:	e8 88 dc ff ff       	call   80d585 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80f8fd:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80f904:	8d 75 f4             	lea    -0xc(%ebp),%esi
    sys_mbox_free(conn->recvmbox);
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80f907:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80f90b:	75 0d                	jne    80f91a <netconn_free+0x99>
  80f90d:	eb 31                	jmp    80f940 <netconn_free+0xbf>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80f90f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f912:	89 04 24             	mov    %eax,(%esp)
  80f915:	e8 b1 f1 ff ff       	call   80eacb <netconn_delete>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80f91a:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f91e:	8b 43 18             	mov    0x18(%ebx),%eax
  80f921:	89 04 24             	mov    %eax,(%esp)
  80f924:	e8 a7 e3 ff ff       	call   80dcd0 <sys_arch_mbox_tryfetch>
  80f929:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f92c:	75 e1                	jne    80f90f <netconn_free+0x8e>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80f92e:	8b 43 18             	mov    0x18(%ebx),%eax
  80f931:	89 04 24             	mov    %eax,(%esp)
  80f934:	e8 4c dc ff ff       	call   80d585 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80f939:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  }

  sys_sem_free(conn->op_completed);
  80f940:	8b 43 10             	mov    0x10(%ebx),%eax
  80f943:	89 04 24             	mov    %eax,(%esp)
  80f946:	e8 b8 db ff ff       	call   80d503 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80f94b:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80f952:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f956:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f95d:	e8 7e 7d ff ff       	call   8076e0 <memp_free>
}
  80f962:	83 c4 20             	add    $0x20,%esp
  80f965:	5b                   	pop    %ebx
  80f966:	5e                   	pop    %esi
  80f967:	5d                   	pop    %ebp
  80f968:	c3                   	ret    

0080f969 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80f969:	55                   	push   %ebp
  80f96a:	89 e5                	mov    %esp,%ebp
  80f96c:	83 ec 38             	sub    $0x38,%esp
  80f96f:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f972:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f975:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f978:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80f97b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f97e:	8b 7d 10             	mov    0x10(%ebp),%edi
  80f981:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80f985:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80f989:	85 c0                	test   %eax,%eax
  80f98b:	75 1c                	jne    80f9a9 <recv_udp+0x40>
  80f98d:	c7 44 24 08 04 4c 81 	movl   $0x814c04,0x8(%esp)
  80f994:	00 
  80f995:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80f99c:	00 
  80f99d:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80f9a4:	e8 3f 10 ff ff       	call   8009e8 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80f9a9:	85 db                	test   %ebx,%ebx
  80f9ab:	75 1c                	jne    80f9c9 <recv_udp+0x60>
  80f9ad:	c7 44 24 08 28 4c 81 	movl   $0x814c28,0x8(%esp)
  80f9b4:	00 
  80f9b5:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  80f9bc:	00 
  80f9bd:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80f9c4:	e8 1f 10 ff ff       	call   8009e8 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80f9c9:	39 43 08             	cmp    %eax,0x8(%ebx)
  80f9cc:	74 1c                	je     80f9ea <recv_udp+0x81>
  80f9ce:	c7 44 24 08 29 4b 81 	movl   $0x814b29,0x8(%esp)
  80f9d5:	00 
  80f9d6:	c7 44 24 04 91 00 00 	movl   $0x91,0x4(%esp)
  80f9dd:	00 
  80f9de:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80f9e5:	e8 fe 0f ff ff       	call   8009e8 <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80f9ea:	85 db                	test   %ebx,%ebx
  80f9ec:	74 06                	je     80f9f4 <recv_udp+0x8b>
  80f9ee:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f9f2:	75 0e                	jne    80fa02 <recv_udp+0x99>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80f9f4:	89 3c 24             	mov    %edi,(%esp)
  80f9f7:	e8 7c 84 ff ff       	call   807e78 <pbuf_free>
    return;
  80f9fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80fa00:	eb 6e                	jmp    80fa70 <recv_udp+0x107>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80fa02:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80fa09:	e8 16 7d ff ff       	call   807724 <memp_malloc>
  80fa0e:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80fa10:	85 c0                	test   %eax,%eax
  80fa12:	75 0a                	jne    80fa1e <recv_udp+0xb5>
    pbuf_free(p);
  80fa14:	89 3c 24             	mov    %edi,(%esp)
  80fa17:	e8 5c 84 ff ff       	call   807e78 <pbuf_free>
    return;
  80fa1c:	eb 52                	jmp    80fa70 <recv_udp+0x107>
  } else {
    buf->p = p;
  80fa1e:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80fa20:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80fa23:	8b 45 14             	mov    0x14(%ebp),%eax
  80fa26:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80fa29:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80fa2d:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80fa31:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80fa35:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80fa39:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80fa3c:	85 c0                	test   %eax,%eax
  80fa3e:	74 15                	je     80fa55 <recv_udp+0xec>
  80fa40:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80fa44:	89 54 24 08          	mov    %edx,0x8(%esp)
  80fa48:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80fa4f:	00 
  80fa50:	89 1c 24             	mov    %ebx,(%esp)
  80fa53:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80fa55:	89 74 24 04          	mov    %esi,0x4(%esp)
  80fa59:	8b 43 14             	mov    0x14(%ebx),%eax
  80fa5c:	89 04 24             	mov    %eax,(%esp)
  80fa5f:	e8 8e e2 ff ff       	call   80dcf2 <sys_mbox_trypost>
  80fa64:	84 c0                	test   %al,%al
  80fa66:	74 08                	je     80fa70 <recv_udp+0x107>
    netbuf_delete(buf);
  80fa68:	89 34 24             	mov    %esi,(%esp)
  80fa6b:	e8 2e 5b ff ff       	call   80559e <netbuf_delete>
    return;
  }
}
  80fa70:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80fa73:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80fa76:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80fa79:	89 ec                	mov    %ebp,%esp
  80fa7b:	5d                   	pop    %ebp
  80fa7c:	c3                   	ret    

0080fa7d <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80fa7d:	55                   	push   %ebp
  80fa7e:	89 e5                	mov    %esp,%ebp
  80fa80:	53                   	push   %ebx
  80fa81:	83 ec 14             	sub    $0x14,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80fa84:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80fa8b:	e8 94 7c ff ff       	call   807724 <memp_malloc>
  80fa90:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80fa92:	85 c0                	test   %eax,%eax
  80fa94:	0f 84 92 00 00 00    	je     80fb2c <netconn_alloc+0xaf>
    return NULL;
  }

  conn->err = ERR_OK;
  80fa9a:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80fa9e:	8b 45 08             	mov    0x8(%ebp),%eax
  80faa1:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80faa3:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80faaa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fab1:	e8 ff de ff ff       	call   80d9b5 <sys_sem_new>
  80fab6:	89 43 10             	mov    %eax,0x10(%ebx)
  80fab9:	83 f8 ff             	cmp    $0xffffffff,%eax
  80fabc:	75 17                	jne    80fad5 <netconn_alloc+0x58>
    memp_free(MEMP_NETCONN, conn);
  80fabe:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80fac2:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80fac9:	e8 12 7c ff ff       	call   8076e0 <memp_free>
  80face:	bb 00 00 00 00       	mov    $0x0,%ebx
    return NULL;
  80fad3:	eb 57                	jmp    80fb2c <netconn_alloc+0xaf>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80fad5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fadc:	e8 5e df ff ff       	call   80da3f <sys_mbox_new>
  80fae1:	89 43 14             	mov    %eax,0x14(%ebx)
  80fae4:	83 f8 ff             	cmp    $0xffffffff,%eax
  80fae7:	75 22                	jne    80fb0b <netconn_alloc+0x8e>
    sys_sem_free(conn->op_completed);
  80fae9:	8b 43 10             	mov    0x10(%ebx),%eax
  80faec:	89 04 24             	mov    %eax,(%esp)
  80faef:	e8 0f da ff ff       	call   80d503 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80faf4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80faf8:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80faff:	e8 dc 7b ff ff       	call   8076e0 <memp_free>
  80fb04:	bb 00 00 00 00       	mov    $0x0,%ebx
    return NULL;
  80fb09:	eb 21                	jmp    80fb2c <netconn_alloc+0xaf>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80fb0b:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80fb12:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80fb19:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80fb20:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fb23:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80fb26:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80fb2c:	89 d8                	mov    %ebx,%eax
  80fb2e:	83 c4 14             	add    $0x14,%esp
  80fb31:	5b                   	pop    %ebx
  80fb32:	5d                   	pop    %ebp
  80fb33:	c3                   	ret    

0080fb34 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80fb34:	55                   	push   %ebp
  80fb35:	89 e5                	mov    %esp,%ebp
  80fb37:	83 ec 28             	sub    $0x28,%esp
  80fb3a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80fb3d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80fb40:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80fb43:	0f b6 7d 10          	movzbl 0x10(%ebp),%edi
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  80fb47:	8b 5d 08             	mov    0x8(%ebp),%ebx

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80fb4a:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80fb4e:	75 1c                	jne    80fb6c <accept_function+0x38>
  80fb50:	c7 44 24 08 48 4c 81 	movl   $0x814c48,0x8(%esp)
  80fb57:	00 
  80fb58:	c7 44 24 04 65 01 00 	movl   $0x165,0x4(%esp)
  80fb5f:	00 
  80fb60:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80fb67:	e8 7c 0e ff ff       	call   8009e8 <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80fb6c:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80fb6f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80fb73:	8b 03                	mov    (%ebx),%eax
  80fb75:	89 04 24             	mov    %eax,(%esp)
  80fb78:	e8 00 ff ff ff       	call   80fa7d <netconn_alloc>
  80fb7d:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80fb7f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80fb84:	85 f6                	test   %esi,%esi
  80fb86:	74 55                	je     80fbdd <accept_function+0xa9>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80fb88:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fb8b:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80fb8e:	89 f0                	mov    %esi,%eax
  80fb90:	e8 43 f1 ff ff       	call   80ecd8 <setup_tcp>
  newconn->err = err;
  80fb95:	89 f8                	mov    %edi,%eax
  80fb97:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80fb9a:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80fb9d:	85 c0                	test   %eax,%eax
  80fb9f:	74 15                	je     80fbb6 <accept_function+0x82>
  80fba1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80fba8:	00 
  80fba9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80fbb0:	00 
  80fbb1:	89 1c 24             	mov    %ebx,(%esp)
  80fbb4:	ff d0                	call   *%eax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80fbb6:	89 74 24 04          	mov    %esi,0x4(%esp)
  80fbba:	8b 43 18             	mov    0x18(%ebx),%eax
  80fbbd:	89 04 24             	mov    %eax,(%esp)
  80fbc0:	e8 2d e1 ff ff       	call   80dcf2 <sys_mbox_trypost>
  80fbc5:	84 c0                	test   %al,%al
  80fbc7:	74 14                	je     80fbdd <accept_function+0xa9>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80fbc9:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80fbd0:	89 34 24             	mov    %esi,(%esp)
  80fbd3:	e8 a9 fc ff ff       	call   80f881 <netconn_free>
  80fbd8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  }
  return ERR_OK;
}
  80fbdd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80fbe0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80fbe3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80fbe6:	89 ec                	mov    %ebp,%esp
  80fbe8:	5d                   	pop    %ebp
  80fbe9:	c3                   	ret    

0080fbea <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80fbea:	55                   	push   %ebp
  80fbeb:	89 e5                	mov    %esp,%ebp
  80fbed:	83 ec 18             	sub    $0x18,%esp
  80fbf0:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80fbf3:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80fbf6:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80fbf9:	8b 03                	mov    (%ebx),%eax
  80fbfb:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80fbff:	0f 85 d5 00 00 00    	jne    80fcda <do_newconn+0xf0>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80fc05:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80fc09:	8b 33                	mov    (%ebx),%esi
  80fc0b:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80fc0f:	74 1c                	je     80fc2d <do_newconn+0x43>
  80fc11:	c7 44 24 08 74 4c 81 	movl   $0x814c74,0x8(%esp)
  80fc18:	00 
  80fc19:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80fc20:	00 
  80fc21:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  80fc28:	e8 bb 0d ff ff       	call   8009e8 <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80fc2d:	8b 06                	mov    (%esi),%eax
  80fc2f:	25 f0 00 00 00       	and    $0xf0,%eax
  80fc34:	83 f8 20             	cmp    $0x20,%eax
  80fc37:	74 45                	je     80fc7e <do_newconn+0x94>
  80fc39:	83 f8 40             	cmp    $0x40,%eax
  80fc3c:	74 0c                	je     80fc4a <do_newconn+0x60>
  80fc3e:	83 f8 10             	cmp    $0x10,%eax
  80fc41:	0f 85 8f 00 00 00    	jne    80fcd6 <do_newconn+0xec>
  80fc47:	90                   	nop
  80fc48:	eb 6f                	jmp    80fcb9 <do_newconn+0xcf>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80fc4a:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80fc4e:	89 04 24             	mov    %eax,(%esp)
  80fc51:	e8 29 1d 00 00       	call   81197f <raw_new>
  80fc56:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80fc59:	8b 03                	mov    (%ebx),%eax
  80fc5b:	8b 50 08             	mov    0x8(%eax),%edx
  80fc5e:	85 d2                	test   %edx,%edx
  80fc60:	75 06                	jne    80fc68 <do_newconn+0x7e>
       msg->conn->err = ERR_MEM;
  80fc62:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80fc66:	eb 72                	jmp    80fcda <do_newconn+0xf0>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80fc68:	89 44 24 08          	mov    %eax,0x8(%esp)
  80fc6c:	c7 44 24 04 f1 fc 80 	movl   $0x80fcf1,0x4(%esp)
  80fc73:	00 
  80fc74:	89 14 24             	mov    %edx,(%esp)
  80fc77:	e8 ef 1c 00 00       	call   81196b <raw_recv>
  80fc7c:	eb 5c                	jmp    80fcda <do_newconn+0xf0>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80fc7e:	e8 ac c3 ff ff       	call   80c02f <udp_new>
  80fc83:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80fc86:	8b 03                	mov    (%ebx),%eax
  80fc88:	8b 50 08             	mov    0x8(%eax),%edx
  80fc8b:	85 d2                	test   %edx,%edx
  80fc8d:	75 06                	jne    80fc95 <do_newconn+0xab>
       msg->conn->err = ERR_MEM;
  80fc8f:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80fc93:	eb 45                	jmp    80fcda <do_newconn+0xf0>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80fc95:	83 38 22             	cmpl   $0x22,(%eax)
  80fc98:	75 04                	jne    80fc9e <do_newconn+0xb4>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80fc9a:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80fc9e:	8b 03                	mov    (%ebx),%eax
  80fca0:	89 44 24 08          	mov    %eax,0x8(%esp)
  80fca4:	c7 44 24 04 69 f9 80 	movl   $0x80f969,0x4(%esp)
  80fcab:	00 
  80fcac:	8b 40 08             	mov    0x8(%eax),%eax
  80fcaf:	89 04 24             	mov    %eax,(%esp)
  80fcb2:	e8 64 c3 ff ff       	call   80c01b <udp_recv>
  80fcb7:	eb 21                	jmp    80fcda <do_newconn+0xf0>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80fcb9:	e8 8c 95 ff ff       	call   80924a <tcp_new>
  80fcbe:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80fcc1:	8b 03                	mov    (%ebx),%eax
  80fcc3:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80fcc7:	75 06                	jne    80fccf <do_newconn+0xe5>
       msg->conn->err = ERR_MEM;
  80fcc9:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80fccd:	eb 0b                	jmp    80fcda <do_newconn+0xf0>
       break;
     }
     setup_tcp(msg->conn);
  80fccf:	e8 04 f0 ff ff       	call   80ecd8 <setup_tcp>
  80fcd4:	eb 04                	jmp    80fcda <do_newconn+0xf0>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80fcd6:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80fcda:	8b 03                	mov    (%ebx),%eax
  80fcdc:	8b 40 10             	mov    0x10(%eax),%eax
  80fcdf:	89 04 24             	mov    %eax,(%esp)
  80fce2:	e8 70 de ff ff       	call   80db57 <sys_sem_signal>
}
  80fce7:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80fcea:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80fced:	89 ec                	mov    %ebp,%esp
  80fcef:	5d                   	pop    %ebp
  80fcf0:	c3                   	ret    

0080fcf1 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80fcf1:	55                   	push   %ebp
  80fcf2:	89 e5                	mov    %esp,%ebp
  80fcf4:	83 ec 28             	sub    $0x28,%esp
  80fcf7:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80fcfa:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80fcfd:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80fd00:	8b 7d 10             	mov    0x10(%ebp),%edi
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  80fd03:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80fd06:	85 db                	test   %ebx,%ebx
  80fd08:	0f 84 b0 00 00 00    	je     80fdbe <recv_raw+0xcd>
  80fd0e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80fd12:	0f 84 a6 00 00 00    	je     80fdbe <recv_raw+0xcd>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80fd18:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80fd1f:	00 
  80fd20:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80fd24:	89 44 24 04          	mov    %eax,0x4(%esp)
  80fd28:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80fd2f:	e8 ff 83 ff ff       	call   808133 <pbuf_alloc>
  80fd34:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80fd36:	85 c0                	test   %eax,%eax
  80fd38:	0f 84 80 00 00 00    	je     80fdbe <recv_raw+0xcd>
      if (pbuf_copy(q, p) != ERR_OK) {
  80fd3e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80fd42:	89 04 24             	mov    %eax,(%esp)
  80fd45:	e8 7b 7f ff ff       	call   807cc5 <pbuf_copy>
  80fd4a:	84 c0                	test   %al,%al
  80fd4c:	0f 84 7e 00 00 00    	je     80fdd0 <recv_raw+0xdf>
        pbuf_free(q);
  80fd52:	89 34 24             	mov    %esi,(%esp)
  80fd55:	e8 1e 81 ff ff       	call   807e78 <pbuf_free>
  80fd5a:	eb 62                	jmp    80fdbe <recv_raw+0xcd>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80fd5c:	89 34 24             	mov    %esi,(%esp)
  80fd5f:	e8 14 81 ff ff       	call   807e78 <pbuf_free>
        return 0;
  80fd64:	eb 58                	jmp    80fdbe <recv_raw+0xcd>
      }

      buf->p = q;
  80fd66:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80fd68:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80fd6b:	8b 46 04             	mov    0x4(%esi),%eax
  80fd6e:	83 c0 0c             	add    $0xc,%eax
  80fd71:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80fd74:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fd77:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80fd7b:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80fd7f:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80fd83:	66 01 43 20          	add    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80fd87:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80fd8a:	85 c0                	test   %eax,%eax
  80fd8c:	74 15                	je     80fda3 <recv_raw+0xb2>
  80fd8e:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80fd92:	89 54 24 08          	mov    %edx,0x8(%esp)
  80fd96:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80fd9d:	00 
  80fd9e:	89 1c 24             	mov    %ebx,(%esp)
  80fda1:	ff d0                	call   *%eax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80fda3:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80fda7:	8b 43 14             	mov    0x14(%ebx),%eax
  80fdaa:	89 04 24             	mov    %eax,(%esp)
  80fdad:	e8 40 df ff ff       	call   80dcf2 <sys_mbox_trypost>
  80fdb2:	84 c0                	test   %al,%al
  80fdb4:	74 08                	je     80fdbe <recv_raw+0xcd>
        netbuf_delete(buf);
  80fdb6:	89 3c 24             	mov    %edi,(%esp)
  80fdb9:	e8 e0 57 ff ff       	call   80559e <netbuf_delete>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80fdbe:	b8 00 00 00 00       	mov    $0x0,%eax
  80fdc3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80fdc6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80fdc9:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80fdcc:	89 ec                	mov    %ebp,%esp
  80fdce:	5d                   	pop    %ebp
  80fdcf:	c3                   	ret    
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80fdd0:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80fdd7:	e8 48 79 ff ff       	call   807724 <memp_malloc>
  80fddc:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80fdde:	85 c0                	test   %eax,%eax
  80fde0:	75 84                	jne    80fd66 <recv_raw+0x75>
  80fde2:	e9 75 ff ff ff       	jmp    80fd5c <recv_raw+0x6b>
	...

0080fdf0 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80fdf0:	55                   	push   %ebp
  80fdf1:	89 e5                	mov    %esp,%ebp
  80fdf3:	57                   	push   %edi
  80fdf4:	56                   	push   %esi
  80fdf5:	53                   	push   %ebx
  80fdf6:	83 ec 1c             	sub    $0x1c,%esp
  80fdf9:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80fdfb:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  80fe00:	8d 70 14             	lea    0x14(%eax),%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80fe03:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fe07:	89 04 24             	mov    %eax,(%esp)
  80fe0a:	e8 72 ae ff ff       	call   80ac81 <ntohs>
  80fe0f:	66 c1 e8 0c          	shr    $0xc,%ax
  80fe13:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fe18:	66 83 f8 05          	cmp    $0x5,%ax
  80fe1c:	77 53                	ja     80fe71 <tcp_parseopt+0x81>
  80fe1e:	eb 77                	jmp    80fe97 <tcp_parseopt+0xa7>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80fe20:	0f b6 d3             	movzbl %bl,%edx
  80fe23:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80fe27:	84 c0                	test   %al,%al
  80fe29:	74 6c                	je     80fe97 <tcp_parseopt+0xa7>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80fe2b:	3c 01                	cmp    $0x1,%al
  80fe2d:	8d 76 00             	lea    0x0(%esi),%esi
  80fe30:	75 05                	jne    80fe37 <tcp_parseopt+0x47>
        ++c;
  80fe32:	83 c3 01             	add    $0x1,%ebx
  80fe35:	eb 3a                	jmp    80fe71 <tcp_parseopt+0x81>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80fe37:	3c 02                	cmp    $0x2,%al
  80fe39:	75 2b                	jne    80fe66 <tcp_parseopt+0x76>
        opts[c + 1] == 0x04) {
  80fe3b:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80fe40:	75 24                	jne    80fe66 <tcp_parseopt+0x76>
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80fe42:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80fe47:	c1 e0 08             	shl    $0x8,%eax
  80fe4a:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80fe4f:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80fe51:	8d 50 ff             	lea    -0x1(%eax),%edx
  80fe54:	66 81 fa b3 05       	cmp    $0x5b3,%dx
  80fe59:	76 05                	jbe    80fe60 <tcp_parseopt+0x70>
  80fe5b:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  80fe60:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80fe64:	eb 31                	jmp    80fe97 <tcp_parseopt+0xa7>
      } else {
        if (opts[c + 1] == 0) {
  80fe66:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80fe6b:	84 c0                	test   %al,%al
  80fe6d:	74 28                	je     80fe97 <tcp_parseopt+0xa7>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80fe6f:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80fe71:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  80fe76:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fe7a:	89 04 24             	mov    %eax,(%esp)
  80fe7d:	e8 ff ad ff ff       	call   80ac81 <ntohs>
  80fe82:	0f b6 d3             	movzbl %bl,%edx
  80fe85:	66 c1 e8 0c          	shr    $0xc,%ax
  80fe89:	0f b7 c0             	movzwl %ax,%eax
  80fe8c:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80fe93:	39 c2                	cmp    %eax,%edx
  80fe95:	7c 89                	jl     80fe20 <tcp_parseopt+0x30>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80fe97:	83 c4 1c             	add    $0x1c,%esp
  80fe9a:	5b                   	pop    %ebx
  80fe9b:	5e                   	pop    %esi
  80fe9c:	5f                   	pop    %edi
  80fe9d:	5d                   	pop    %ebp
  80fe9e:	c3                   	ret    

0080fe9f <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80fe9f:	55                   	push   %ebp
  80fea0:	89 e5                	mov    %esp,%ebp
  80fea2:	57                   	push   %edi
  80fea3:	56                   	push   %esi
  80fea4:	53                   	push   %ebx
  80fea5:	83 ec 2c             	sub    $0x2c,%esp
  80fea8:	89 c3                	mov    %eax,%ebx
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80feaa:	f6 05 00 c2 b3 00 10 	testb  $0x10,0xb3c200
  80feb1:	0f 84 6d 04 00 00    	je     810324 <tcp_receive+0x485>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80feb7:	0f b7 70 5c          	movzwl 0x5c(%eax),%esi
  80febb:	8b 50 60             	mov    0x60(%eax),%edx

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80febe:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  80fec3:	39 c2                	cmp    %eax,%edx
  80fec5:	78 24                	js     80feeb <tcp_receive+0x4c>
  80fec7:	39 c2                	cmp    %eax,%edx
  80fec9:	75 0a                	jne    80fed5 <tcp_receive+0x36>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80fecb:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  80fed0:	39 43 64             	cmp    %eax,0x64(%ebx)
  80fed3:	78 16                	js     80feeb <tcp_receive+0x4c>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80fed5:	8b 43 64             	mov    0x64(%ebx),%eax
  80fed8:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  80fede:	75 3f                	jne    80ff1f <tcp_receive+0x80>
  80fee0:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  80fee5:	66 3b 70 0e          	cmp    0xe(%eax),%si
  80fee9:	73 34                	jae    80ff1f <tcp_receive+0x80>
      pcb->snd_wnd = tcphdr->wnd;
  80feeb:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  80fef0:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  80fef4:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
      pcb->snd_wl1 = seqno;
  80fef8:	8b 0d f8 c1 b3 00    	mov    0xb3c1f8,%ecx
  80fefe:	89 4b 60             	mov    %ecx,0x60(%ebx)
      pcb->snd_wl2 = ackno;
  80ff01:	8b 0d fc c1 b3 00    	mov    0xb3c1fc,%ecx
  80ff07:	89 4b 64             	mov    %ecx,0x64(%ebx)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80ff0a:	66 85 c0             	test   %ax,%ax
  80ff0d:	74 10                	je     80ff1f <tcp_receive+0x80>
  80ff0f:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  80ff16:	74 07                	je     80ff1f <tcp_receive+0x80>
          pcb->persist_backoff = 0;
  80ff18:	c6 83 a4 00 00 00 00 	movb   $0x0,0xa4(%ebx)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80ff1f:	8b 4b 48             	mov    0x48(%ebx),%ecx
  80ff22:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  80ff27:	39 c1                	cmp    %eax,%ecx
  80ff29:	0f 85 ac 00 00 00    	jne    80ffdb <tcp_receive+0x13c>
      pcb->acked = 0;
  80ff2f:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80ff35:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  80ff39:	03 43 60             	add    0x60(%ebx),%eax
  80ff3c:	0f b7 f6             	movzwl %si,%esi
  80ff3f:	8d 14 16             	lea    (%esi,%edx,1),%edx
  80ff42:	39 d0                	cmp    %edx,%eax
  80ff44:	0f 85 ff 02 00 00    	jne    810249 <tcp_receive+0x3aa>
        ++pcb->dupacks;
  80ff4a:	0f b6 43 4c          	movzbl 0x4c(%ebx),%eax
  80ff4e:	83 c0 01             	add    $0x1,%eax
  80ff51:	88 43 4c             	mov    %al,0x4c(%ebx)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80ff54:	3c 02                	cmp    $0x2,%al
  80ff56:	0f 86 ed 02 00 00    	jbe    810249 <tcp_receive+0x3aa>
  80ff5c:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80ff60:	0f 84 e3 02 00 00    	je     810249 <tcp_receive+0x3aa>
          if (!(pcb->flags & TF_INFR)) {
  80ff66:	f6 43 20 04          	testb  $0x4,0x20(%ebx)
  80ff6a:	75 53                	jne    80ffbf <tcp_receive+0x120>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80ff6c:	89 1c 24             	mov    %ebx,(%esp)
  80ff6f:	90                   	nop
  80ff70:	e8 33 b8 ff ff       	call   80b7a8 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80ff75:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  80ff79:	0f b7 53 5c          	movzwl 0x5c(%ebx),%edx
  80ff7d:	66 39 d0             	cmp    %dx,%ax
  80ff80:	76 09                	jbe    80ff8b <tcp_receive+0xec>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80ff82:	66 d1 ea             	shr    %dx
  80ff85:	66 89 53 50          	mov    %dx,0x50(%ebx)
  80ff89:	eb 07                	jmp    80ff92 <tcp_receive+0xf3>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80ff8b:	66 d1 e8             	shr    %ax
  80ff8e:	66 89 43 50          	mov    %ax,0x50(%ebx)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80ff92:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80ff96:	0f b7 4b 50          	movzwl 0x50(%ebx),%ecx
  80ff9a:	0f b7 d0             	movzwl %ax,%edx
  80ff9d:	01 d2                	add    %edx,%edx
  80ff9f:	39 d1                	cmp    %edx,%ecx
  80ffa1:	7d 06                	jge    80ffa9 <tcp_receive+0x10a>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80ffa3:	01 c0                	add    %eax,%eax
  80ffa5:	66 89 43 50          	mov    %ax,0x50(%ebx)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80ffa9:	66 6b 43 34 03       	imul   $0x3,0x34(%ebx),%ax
  80ffae:	66 03 43 50          	add    0x50(%ebx),%ax
  80ffb2:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
            pcb->flags |= TF_INFR;
  80ffb6:	80 4b 20 04          	orb    $0x4,0x20(%ebx)
  80ffba:	e9 8a 02 00 00       	jmp    810249 <tcp_receive+0x3aa>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80ffbf:	0f b7 53 4e          	movzwl 0x4e(%ebx),%edx
  80ffc3:	89 d0                	mov    %edx,%eax
  80ffc5:	66 03 43 34          	add    0x34(%ebx),%ax
  80ffc9:	66 39 c2             	cmp    %ax,%dx
  80ffcc:	0f 83 77 02 00 00    	jae    810249 <tcp_receive+0x3aa>
              pcb->cwnd += pcb->mss;
  80ffd2:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80ffd6:	e9 6e 02 00 00       	jmp    810249 <tcp_receive+0x3aa>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80ffdb:	f7 d1                	not    %ecx
  80ffdd:	01 c1                	add    %eax,%ecx
  80ffdf:	0f 88 b2 01 00 00    	js     810197 <tcp_receive+0x2f8>
  80ffe5:	2b 43 58             	sub    0x58(%ebx),%eax
  80ffe8:	85 c0                	test   %eax,%eax
  80ffea:	0f 8f a7 01 00 00    	jg     810197 <tcp_receive+0x2f8>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80fff0:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  80fff4:	a8 04                	test   $0x4,%al
  80fff6:	74 0e                	je     810006 <tcp_receive+0x167>
        pcb->flags &= ~TF_INFR;
  80fff8:	83 e0 fb             	and    $0xfffffffb,%eax
  80fffb:	88 43 20             	mov    %al,0x20(%ebx)
        pcb->cwnd = pcb->ssthresh;
  80fffe:	0f b7 43 50          	movzwl 0x50(%ebx),%eax
  810002:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  810006:	c6 43 46 00          	movb   $0x0,0x46(%ebx)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81000a:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  81000e:	66 c1 f8 03          	sar    $0x3,%ax
  810012:	66 03 43 42          	add    0x42(%ebx),%ax
  810016:	66 89 43 44          	mov    %ax,0x44(%ebx)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  81001a:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  81001f:	66 2b 43 48          	sub    0x48(%ebx),%ax
  810023:	66 89 43 6c          	mov    %ax,0x6c(%ebx)

      pcb->snd_buf += pcb->acked;
  810027:	66 01 43 6e          	add    %ax,0x6e(%ebx)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  81002b:	c6 43 4c 00          	movb   $0x0,0x4c(%ebx)
      pcb->lastack = ackno;
  81002f:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  810034:	89 43 48             	mov    %eax,0x48(%ebx)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  810037:	83 7b 10 03          	cmpl   $0x3,0x10(%ebx)
  81003b:	0f 86 d3 00 00 00    	jbe    810114 <tcp_receive+0x275>
        if (pcb->cwnd < pcb->ssthresh) {
  810041:	0f b7 4b 4e          	movzwl 0x4e(%ebx),%ecx
  810045:	66 3b 4b 50          	cmp    0x50(%ebx),%cx
  810049:	73 18                	jae    810063 <tcp_receive+0x1c4>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81004b:	89 c8                	mov    %ecx,%eax
  81004d:	66 03 43 34          	add    0x34(%ebx),%ax
  810051:	66 39 c1             	cmp    %ax,%cx
  810054:	0f 83 ba 00 00 00    	jae    810114 <tcp_receive+0x275>
            pcb->cwnd += pcb->mss;
  81005a:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  81005e:	e9 b1 00 00 00       	jmp    810114 <tcp_receive+0x275>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  810063:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  810067:	0f af d2             	imul   %edx,%edx
  81006a:	0f b7 f1             	movzwl %cx,%esi
  81006d:	89 d0                	mov    %edx,%eax
  81006f:	c1 fa 1f             	sar    $0x1f,%edx
  810072:	f7 fe                	idiv   %esi
  810074:	8d 04 01             	lea    (%ecx,%eax,1),%eax
          if (new_cwnd > pcb->cwnd) {
  810077:	66 39 c1             	cmp    %ax,%cx
  81007a:	0f 83 94 00 00 00    	jae    810114 <tcp_receive+0x275>
            pcb->cwnd = new_cwnd;
  810080:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  810084:	e9 8b 00 00 00       	jmp    810114 <tcp_receive+0x275>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  810089:	8b 73 78             	mov    0x78(%ebx),%esi
        pcb->unacked = pcb->unacked->next;
  81008c:	8b 06                	mov    (%esi),%eax
  81008e:	89 43 78             	mov    %eax,0x78(%ebx)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  810091:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  810095:	8b 46 04             	mov    0x4(%esi),%eax
  810098:	89 04 24             	mov    %eax,(%esp)
  81009b:	e8 70 79 ff ff       	call   807a10 <pbuf_clen>
  8100a0:	0f b6 c0             	movzbl %al,%eax
  8100a3:	66 39 c7             	cmp    %ax,%di
  8100a6:	73 1c                	jae    8100c4 <tcp_receive+0x225>
  8100a8:	c7 44 24 08 94 4c 81 	movl   $0x814c94,0x8(%esp)
  8100af:	00 
  8100b0:	c7 44 24 04 55 03 00 	movl   $0x355,0x4(%esp)
  8100b7:	00 
  8100b8:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  8100bf:	e8 24 09 ff ff       	call   8009e8 <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  8100c4:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  8100c8:	8b 46 04             	mov    0x4(%esi),%eax
  8100cb:	89 04 24             	mov    %eax,(%esp)
  8100ce:	e8 3d 79 ff ff       	call   807a10 <pbuf_clen>
  8100d3:	0f b6 c0             	movzbl %al,%eax
  8100d6:	66 29 c7             	sub    %ax,%di
  8100d9:	66 89 7b 70          	mov    %di,0x70(%ebx)
        tcp_seg_free(next);
  8100dd:	89 34 24             	mov    %esi,(%esp)
  8100e0:	e8 0c 89 ff ff       	call   8089f1 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  8100e5:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  8100ea:	74 28                	je     810114 <tcp_receive+0x275>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  8100ec:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  8100f0:	75 22                	jne    810114 <tcp_receive+0x275>
  8100f2:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  8100f6:	75 1c                	jne    810114 <tcp_receive+0x275>
  8100f8:	c7 44 24 08 bc 4c 81 	movl   $0x814cbc,0x8(%esp)
  8100ff:	00 
  810100:	c7 44 24 04 5c 03 00 	movl   $0x35c,0x4(%esp)
  810107:	00 
  810108:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  81010f:	e8 d4 08 ff ff       	call   8009e8 <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  810114:	8b 43 78             	mov    0x78(%ebx),%eax
  810117:	85 c0                	test   %eax,%eax
  810119:	74 65                	je     810180 <tcp_receive+0x2e1>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  81011b:	8b 40 10             	mov    0x10(%eax),%eax
  81011e:	8b 40 04             	mov    0x4(%eax),%eax
  810121:	89 04 24             	mov    %eax,(%esp)
  810124:	e8 91 ad ff ff       	call   80aeba <ntohl>
  810129:	89 c6                	mov    %eax,%esi
  81012b:	8b 43 78             	mov    0x78(%ebx),%eax
  81012e:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  810132:	8b 40 10             	mov    0x10(%eax),%eax
  810135:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810139:	89 04 24             	mov    %eax,(%esp)
  81013c:	e8 40 ab ff ff       	call   80ac81 <ntohs>
  810141:	a8 01                	test   $0x1,%al
  810143:	75 1b                	jne    810160 <tcp_receive+0x2c1>
  810145:	8b 43 78             	mov    0x78(%ebx),%eax
  810148:	8b 40 10             	mov    0x10(%eax),%eax
  81014b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81014f:	89 04 24             	mov    %eax,(%esp)
  810152:	e8 2a ab ff ff       	call   80ac81 <ntohs>
  810157:	ba 00 00 00 00       	mov    $0x0,%edx
  81015c:	a8 02                	test   $0x2,%al
  81015e:	74 05                	je     810165 <tcp_receive+0x2c6>
  810160:	ba 01 00 00 00       	mov    $0x1,%edx
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  810165:	2b 35 fc c1 b3 00    	sub    0xb3c1fc,%esi
  81016b:	0f b7 ff             	movzwl %di,%edi
  81016e:	01 fa                	add    %edi,%edx
  810170:	01 d6                	add    %edx,%esi
  810172:	85 f6                	test   %esi,%esi
  810174:	0f 8e 0f ff ff ff    	jle    810089 <tcp_receive+0x1ea>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81017a:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  81017e:	75 08                	jne    810188 <tcp_receive+0x2e9>
        pcb->rtime = -1;
  810180:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  810186:	eb 06                	jmp    81018e <tcp_receive+0x2ef>
      else
        pcb->rtime = 0;
  810188:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

      pcb->polltmr = 0;
  81018e:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  810192:	e9 b2 00 00 00       	jmp    810249 <tcp_receive+0x3aa>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  810197:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)
  81019d:	8d 76 00             	lea    0x0(%esi),%esi
  8101a0:	e9 a4 00 00 00       	jmp    810249 <tcp_receive+0x3aa>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  8101a5:	8b 73 74             	mov    0x74(%ebx),%esi
      pcb->unsent = pcb->unsent->next;
  8101a8:	8b 06                	mov    (%esi),%eax
  8101aa:	89 43 74             	mov    %eax,0x74(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  8101ad:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  8101b1:	8b 46 04             	mov    0x4(%esi),%eax
  8101b4:	89 04 24             	mov    %eax,(%esp)
  8101b7:	e8 54 78 ff ff       	call   807a10 <pbuf_clen>
  8101bc:	0f b6 c0             	movzbl %al,%eax
  8101bf:	66 39 c7             	cmp    %ax,%di
  8101c2:	73 1c                	jae    8101e0 <tcp_receive+0x341>
  8101c4:	c7 44 24 08 94 4c 81 	movl   $0x814c94,0x8(%esp)
  8101cb:	00 
  8101cc:	c7 44 24 04 7f 03 00 	movl   $0x37f,0x4(%esp)
  8101d3:	00 
  8101d4:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  8101db:	e8 08 08 ff ff       	call   8009e8 <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  8101e0:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  8101e4:	8b 46 04             	mov    0x4(%esi),%eax
  8101e7:	89 04 24             	mov    %eax,(%esp)
  8101ea:	e8 21 78 ff ff       	call   807a10 <pbuf_clen>
  8101ef:	0f b6 c0             	movzbl %al,%eax
  8101f2:	66 29 c7             	sub    %ax,%di
  8101f5:	66 89 7b 70          	mov    %di,0x70(%ebx)
      tcp_seg_free(next);
  8101f9:	89 34 24             	mov    %esi,(%esp)
  8101fc:	e8 f0 87 ff ff       	call   8089f1 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  810201:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  810206:	74 29                	je     810231 <tcp_receive+0x392>
        LWIP_ASSERT("tcp_receive: valid queue length",
  810208:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  81020c:	75 23                	jne    810231 <tcp_receive+0x392>
  81020e:	8b 43 74             	mov    0x74(%ebx),%eax
  810211:	85 c0                	test   %eax,%eax
  810213:	75 23                	jne    810238 <tcp_receive+0x399>
  810215:	c7 44 24 08 bc 4c 81 	movl   $0x814cbc,0x8(%esp)
  81021c:	00 
  81021d:	c7 44 24 04 85 03 00 	movl   $0x385,0x4(%esp)
  810224:	00 
  810225:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  81022c:	e8 b7 07 ff ff       	call   8009e8 <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  810231:	8b 43 74             	mov    0x74(%ebx),%eax
  810234:	85 c0                	test   %eax,%eax
  810236:	74 11                	je     810249 <tcp_receive+0x3aa>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  810238:	8b 40 10             	mov    0x10(%eax),%eax
  81023b:	8b 40 04             	mov    0x4(%eax),%eax
  81023e:	89 04 24             	mov    %eax,(%esp)
  810241:	e8 4f aa ff ff       	call   80ac95 <htonl>
  810246:	89 43 54             	mov    %eax,0x54(%ebx)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  810249:	8b 43 74             	mov    0x74(%ebx),%eax
  81024c:	85 c0                	test   %eax,%eax
  81024e:	74 70                	je     8102c0 <tcp_receive+0x421>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  810250:	8b 35 fc c1 b3 00    	mov    0xb3c1fc,%esi
  810256:	8b 40 10             	mov    0x10(%eax),%eax
  810259:	8b 40 04             	mov    0x4(%eax),%eax
  81025c:	89 04 24             	mov    %eax,(%esp)
  81025f:	e8 56 ac ff ff       	call   80aeba <ntohl>
  810264:	89 c7                	mov    %eax,%edi
  810266:	8b 43 74             	mov    0x74(%ebx),%eax
  810269:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  81026d:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  810271:	8b 40 10             	mov    0x10(%eax),%eax
  810274:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810278:	89 04 24             	mov    %eax,(%esp)
  81027b:	e8 01 aa ff ff       	call   80ac81 <ntohs>
  810280:	a8 01                	test   $0x1,%al
  810282:	75 1b                	jne    81029f <tcp_receive+0x400>
  810284:	8b 43 74             	mov    0x74(%ebx),%eax
  810287:	8b 40 10             	mov    0x10(%eax),%eax
  81028a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81028e:	89 04 24             	mov    %eax,(%esp)
  810291:	e8 eb a9 ff ff       	call   80ac81 <ntohs>
  810296:	ba 00 00 00 00       	mov    $0x0,%edx
  81029b:	a8 02                	test   $0x2,%al
  81029d:	74 05                	je     8102a4 <tcp_receive+0x405>
  81029f:	ba 01 00 00 00       	mov    $0x1,%edx
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  8102a4:	29 fe                	sub    %edi,%esi
  8102a6:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8102aa:	01 c2                	add    %eax,%edx
  8102ac:	39 d6                	cmp    %edx,%esi
  8102ae:	78 10                	js     8102c0 <tcp_receive+0x421>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  8102b0:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  8102b5:	2b 43 58             	sub    0x58(%ebx),%eax
  8102b8:	85 c0                	test   %eax,%eax
  8102ba:	0f 8e e5 fe ff ff    	jle    8101a5 <tcp_receive+0x306>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  8102c0:	8b 43 38             	mov    0x38(%ebx),%eax
  8102c3:	85 c0                	test   %eax,%eax
  8102c5:	74 5d                	je     810324 <tcp_receive+0x485>
  8102c7:	8b 35 fc c1 b3 00    	mov    0xb3c1fc,%esi
  8102cd:	39 73 3c             	cmp    %esi,0x3c(%ebx)
  8102d0:	79 52                	jns    810324 <tcp_receive+0x485>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  8102d2:	0f b7 53 40          	movzwl 0x40(%ebx),%edx
  8102d6:	8b 0d 10 f0 b3 00    	mov    0xb3f010,%ecx
  8102dc:	66 29 c1             	sub    %ax,%cx
  8102df:	89 c8                	mov    %ecx,%eax
  8102e1:	89 d1                	mov    %edx,%ecx
  8102e3:	66 c1 f9 03          	sar    $0x3,%cx
  8102e7:	66 29 c8             	sub    %cx,%ax
      pcb->sa += m;
  8102ea:	8d 14 10             	lea    (%eax,%edx,1),%edx
  8102ed:	66 89 53 40          	mov    %dx,0x40(%ebx)
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
  8102f1:	0f b7 4b 42          	movzwl 0x42(%ebx),%ecx
      pcb->sv += m;
  8102f5:	89 ce                	mov    %ecx,%esi
  8102f7:	66 c1 fe 02          	sar    $0x2,%si
  8102fb:	66 29 f1             	sub    %si,%cx
  8102fe:	89 ce                	mov    %ecx,%esi
  810300:	89 c1                	mov    %eax,%ecx
  810302:	66 c1 f9 0f          	sar    $0xf,%cx
  810306:	31 c8                	xor    %ecx,%eax
  810308:	66 29 c8             	sub    %cx,%ax
  81030b:	8d 04 06             	lea    (%esi,%eax,1),%eax
  81030e:	66 89 43 42          	mov    %ax,0x42(%ebx)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  810312:	66 c1 fa 03          	sar    $0x3,%dx
  810316:	8d 04 02             	lea    (%edx,%eax,1),%eax
  810319:	66 89 43 44          	mov    %ax,0x44(%ebx)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  81031d:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  810324:	0f b7 0d 02 c2 b3 00 	movzwl 0xb3c202,%ecx
  81032b:	66 85 c9             	test   %cx,%cx
  81032e:	0f 84 a5 07 00 00    	je     810ad9 <tcp_receive+0xc3a>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  810334:	8b 53 24             	mov    0x24(%ebx),%edx
  810337:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  81033c:	89 c6                	mov    %eax,%esi
  81033e:	f7 d6                	not    %esi
  810340:	01 d6                	add    %edx,%esi
  810342:	0f 88 3a 01 00 00    	js     810482 <tcp_receive+0x5e3>
  810348:	8d 7a 01             	lea    0x1(%edx),%edi
  81034b:	29 c7                	sub    %eax,%edi
  81034d:	0f b7 f1             	movzwl %cx,%esi
  810350:	89 f9                	mov    %edi,%ecx
  810352:	29 f1                	sub    %esi,%ecx
  810354:	85 c9                	test   %ecx,%ecx
  810356:	0f 8f 26 01 00 00    	jg     810482 <tcp_receive+0x5e3>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
  81035c:	8b 35 e0 c1 b3 00    	mov    0xb3c1e0,%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  810362:	85 f6                	test   %esi,%esi
  810364:	75 1c                	jne    810382 <tcp_receive+0x4e3>
  810366:	c7 44 24 08 17 4e 81 	movl   $0x814e17,0x8(%esp)
  81036d:	00 
  81036e:	c7 44 24 04 e5 03 00 	movl   $0x3e5,0x4(%esp)
  810375:	00 
  810376:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  81037d:	e8 66 06 ff ff       	call   8009e8 <_panic>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  810382:	29 c2                	sub    %eax,%edx
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  810384:	81 fa fe 7f 00 00    	cmp    $0x7ffe,%edx
  81038a:	7e 1c                	jle    8103a8 <tcp_receive+0x509>
  81038c:	c7 44 24 08 27 4e 81 	movl   $0x814e27,0x8(%esp)
  810393:	00 
  810394:	c7 44 24 04 e6 03 00 	movl   $0x3e6,0x4(%esp)
  81039b:	00 
  81039c:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  8103a3:	e8 40 06 ff ff       	call   8009e8 <_panic>
      if (inseg.p->len < off) {
  8103a8:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  8103ac:	39 c2                	cmp    %eax,%edx
  8103ae:	7e 71                	jle    810421 <tcp_receive+0x582>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  8103b0:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  8103b4:	0f b7 f9             	movzwl %cx,%edi
  8103b7:	39 fa                	cmp    %edi,%edx
  8103b9:	7e 1c                	jle    8103d7 <tcp_receive+0x538>
  8103bb:	c7 44 24 08 36 4e 81 	movl   $0x814e36,0x8(%esp)
  8103c2:	00 
  8103c3:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  8103ca:	00 
  8103cb:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  8103d2:	e8 11 06 ff ff       	call   8009e8 <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  8103d7:	66 29 d1             	sub    %dx,%cx
        while (p->len < off) {
          off -= p->len;
  8103da:	29 c2                	sub    %eax,%edx
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  8103dc:	66 89 4e 08          	mov    %cx,0x8(%esi)
          p->len = 0;
  8103e0:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
          p = p->next;
  8103e6:	8b 36                	mov    (%esi),%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  8103e8:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  8103ec:	39 d0                	cmp    %edx,%eax
  8103ee:	7c ea                	jl     8103da <tcp_receive+0x53b>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  8103f0:	f7 da                	neg    %edx
  8103f2:	0f bf c2             	movswl %dx,%eax
  8103f5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8103f9:	89 34 24             	mov    %esi,(%esp)
  8103fc:	e8 02 77 ff ff       	call   807b03 <pbuf_header>
  810401:	84 c0                	test   %al,%al
  810403:	74 4d                	je     810452 <tcp_receive+0x5b3>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  810405:	c7 44 24 08 46 4e 81 	movl   $0x814e46,0x8(%esp)
  81040c:	00 
  81040d:	c7 44 24 04 f5 03 00 	movl   $0x3f5,0x4(%esp)
  810414:	00 
  810415:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  81041c:	e8 c7 05 ff ff       	call   8009e8 <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  810421:	f7 da                	neg    %edx
  810423:	0f bf c2             	movswl %dx,%eax
  810426:	89 44 24 04          	mov    %eax,0x4(%esp)
  81042a:	89 34 24             	mov    %esi,(%esp)
  81042d:	e8 d1 76 ff ff       	call   807b03 <pbuf_header>
  810432:	84 c0                	test   %al,%al
  810434:	74 1c                	je     810452 <tcp_receive+0x5b3>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  810436:	c7 44 24 08 46 4e 81 	movl   $0x814e46,0x8(%esp)
  81043d:	00 
  81043e:	c7 44 24 04 fa 03 00 	movl   $0x3fa,0x4(%esp)
  810445:	00 
  810446:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  81044d:	e8 96 05 ff ff       	call   8009e8 <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  810452:	8b 46 04             	mov    0x4(%esi),%eax
  810455:	a3 e4 c1 b3 00       	mov    %eax,0xb3c1e4
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  81045a:	b8 e8 c1 b3 00       	mov    $0xb3c1e8,%eax
  81045f:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  810465:	66 03 10             	add    (%eax),%dx
  810468:	66 2b 53 24          	sub    0x24(%ebx),%dx
  81046c:	66 89 10             	mov    %dx,(%eax)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  81046f:	8b 43 24             	mov    0x24(%ebx),%eax
  810472:	a3 f8 c1 b3 00       	mov    %eax,0xb3c1f8
  810477:	8b 15 ec c1 b3 00    	mov    0xb3c1ec,%edx
  81047d:	89 42 04             	mov    %eax,0x4(%edx)
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  810480:	eb 10                	jmp    810492 <tcp_receive+0x5f3>
      inseg.dataptr = p->payload;
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  810482:	39 d0                	cmp    %edx,%eax
  810484:	79 1c                	jns    8104a2 <tcp_receive+0x603>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  810486:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81048a:	89 1c 24             	mov    %ebx,(%esp)
  81048d:	e8 69 ae ff ff       	call   80b2fb <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  810492:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  810497:	8b 53 24             	mov    0x24(%ebx),%edx
  81049a:	39 d0                	cmp    %edx,%eax
  81049c:	0f 88 24 06 00 00    	js     810ac6 <tcp_receive+0xc27>
  8104a2:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  8104a6:	89 c7                	mov    %eax,%edi
  8104a8:	29 cf                	sub    %ecx,%edi
  8104aa:	8d 4f 01             	lea    0x1(%edi),%ecx
  8104ad:	29 d1                	sub    %edx,%ecx
  8104af:	85 c9                	test   %ecx,%ecx
  8104b1:	0f 8f 0f 06 00 00    	jg     810ac6 <tcp_receive+0xc27>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  8104b7:	39 d0                	cmp    %edx,%eax
  8104b9:	0f 85 95 03 00 00    	jne    810854 <tcp_receive+0x9b5>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  8104bf:	8b 53 7c             	mov    0x7c(%ebx),%edx
  8104c2:	85 d2                	test   %edx,%edx
  8104c4:	0f 84 86 00 00 00    	je     810550 <tcp_receive+0x6b1>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  8104ca:	8b 4a 10             	mov    0x10(%edx),%ecx
  8104cd:	8b 49 04             	mov    0x4(%ecx),%ecx
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  8104d0:	0f b7 35 e8 c1 b3 00 	movzwl 0xb3c1e8,%esi
  8104d7:	89 cf                	mov    %ecx,%edi
  8104d9:	29 f7                	sub    %esi,%edi
  8104db:	89 fe                	mov    %edi,%esi
  8104dd:	29 c6                	sub    %eax,%esi
  8104df:	85 f6                	test   %esi,%esi
  8104e1:	7f 6d                	jg     810550 <tcp_receive+0x6b1>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  8104e3:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
  8104e8:	74 20                	je     81050a <tcp_receive+0x66b>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  8104ea:	66 29 c1             	sub    %ax,%cx
  8104ed:	66 89 0d e8 c1 b3 00 	mov    %cx,0xb3c1e8
            pbuf_realloc(inseg.p, inseg.len);
  8104f4:	0f b7 c1             	movzwl %cx,%eax
  8104f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8104fb:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  810500:	89 04 24             	mov    %eax,(%esp)
  810503:	e8 f8 7a ff ff       	call   808000 <pbuf_realloc>
  810508:	eb 46                	jmp    810550 <tcp_receive+0x6b1>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81050a:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  81050f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810513:	89 04 24             	mov    %eax,(%esp)
  810516:	e8 66 a7 ff ff       	call   80ac81 <ntohs>
  81051b:	89 c6                	mov    %eax,%esi
  81051d:	8b 43 7c             	mov    0x7c(%ebx),%eax
  810520:	8b 40 10             	mov    0x10(%eax),%eax
  810523:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810527:	89 04 24             	mov    %eax,(%esp)
  81052a:	e8 52 a7 ff ff       	call   80ac81 <ntohs>
  81052f:	31 c6                	xor    %eax,%esi
  810531:	66 f7 c6 03 00       	test   $0x3,%si
  810536:	75 18                	jne    810550 <tcp_receive+0x6b1>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  810538:	8b 43 7c             	mov    0x7c(%ebx),%eax
              pcb->ooseq = pcb->ooseq->next;
  81053b:	8b 10                	mov    (%eax),%edx
  81053d:	89 53 7c             	mov    %edx,0x7c(%ebx)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  810540:	89 44 24 04          	mov    %eax,0x4(%esp)
  810544:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  81054b:	e8 90 71 ff ff       	call   8076e0 <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  810550:	0f b7 35 e8 c1 b3 00 	movzwl 0xb3c1e8,%esi
  810557:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  81055c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810560:	89 04 24             	mov    %eax,(%esp)
  810563:	e8 19 a7 ff ff       	call   80ac81 <ntohs>
  810568:	a8 01                	test   $0x1,%al
  81056a:	75 1a                	jne    810586 <tcp_receive+0x6e7>
  81056c:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  810571:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810575:	89 04 24             	mov    %eax,(%esp)
  810578:	e8 04 a7 ff ff       	call   80ac81 <ntohs>
  81057d:	ba 00 00 00 00       	mov    $0x0,%edx
  810582:	a8 02                	test   $0x2,%al
  810584:	74 05                	je     81058b <tcp_receive+0x6ec>
  810586:	ba 01 00 00 00       	mov    $0x1,%edx
  81058b:	01 d6                	add    %edx,%esi
  81058d:	66 89 35 02 c2 b3 00 	mov    %si,0xb3c202

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  810594:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  810598:	74 06                	je     8105a0 <tcp_receive+0x701>
          pcb->rcv_nxt += tcplen;
  81059a:	0f b7 f6             	movzwl %si,%esi
  81059d:	01 73 24             	add    %esi,0x24(%ebx)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  8105a0:	0f b7 53 28          	movzwl 0x28(%ebx),%edx
  8105a4:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  8105ab:	66 39 c2             	cmp    %ax,%dx
  8105ae:	73 08                	jae    8105b8 <tcp_receive+0x719>
          pcb->rcv_wnd = 0;
  8105b0:	66 c7 43 28 00 00    	movw   $0x0,0x28(%ebx)
  8105b6:	eb 07                	jmp    8105bf <tcp_receive+0x720>
        } else {
          pcb->rcv_wnd -= tcplen;
  8105b8:	66 29 c2             	sub    %ax,%dx
  8105bb:	66 89 53 28          	mov    %dx,0x28(%ebx)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  8105bf:	0f b7 53 2a          	movzwl 0x2a(%ebx),%edx
  8105c3:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  8105ca:	66 39 c2             	cmp    %ax,%dx
  8105cd:	73 08                	jae    8105d7 <tcp_receive+0x738>
          pcb->rcv_ann_wnd = 0;
  8105cf:	66 c7 43 2a 00 00    	movw   $0x0,0x2a(%ebx)
  8105d5:	eb 07                	jmp    8105de <tcp_receive+0x73f>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  8105d7:	66 29 c2             	sub    %ax,%dx
  8105da:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  8105de:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  8105e3:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  8105e8:	74 0f                	je     8105f9 <tcp_receive+0x75a>
          recv_data = inseg.p;
  8105ea:	a3 08 c2 b3 00       	mov    %eax,0xb3c208
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  8105ef:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  8105f6:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  8105f9:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  8105fe:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810602:	89 04 24             	mov    %eax,(%esp)
  810605:	e8 77 a6 ff ff       	call   80ac81 <ntohs>
  81060a:	a8 01                	test   $0x1,%al
  81060c:	74 07                	je     810615 <tcp_receive+0x776>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  81060e:	c6 05 04 c2 b3 00 20 	movb   $0x20,0xb3c204
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  810615:	8b 73 7c             	mov    0x7c(%ebx),%esi
  810618:	85 f6                	test   %esi,%esi
  81061a:	0f 84 01 02 00 00    	je     810821 <tcp_receive+0x982>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  810620:	8b 46 10             	mov    0x10(%esi),%eax
  810623:	8b 40 04             	mov    0x4(%eax),%eax
  810626:	3b 43 24             	cmp    0x24(%ebx),%eax
  810629:	0f 85 f2 01 00 00    	jne    810821 <tcp_receive+0x982>

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  81062f:	a3 f8 c1 b3 00       	mov    %eax,0xb3c1f8

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  810634:	8b 43 24             	mov    0x24(%ebx),%eax
  810637:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  81063a:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  81063e:	8b 46 10             	mov    0x10(%esi),%eax
  810641:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810645:	89 04 24             	mov    %eax,(%esp)
  810648:	e8 34 a6 ff ff       	call   80ac81 <ntohs>
  81064d:	a8 01                	test   $0x1,%al
  81064f:	75 18                	jne    810669 <tcp_receive+0x7ca>
  810651:	8b 46 10             	mov    0x10(%esi),%eax
  810654:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810658:	89 04 24             	mov    %eax,(%esp)
  81065b:	e8 21 a6 ff ff       	call   80ac81 <ntohs>
  810660:	ba 00 00 00 00       	mov    $0x0,%edx
  810665:	a8 02                	test   $0x2,%al
  810667:	74 05                	je     81066e <tcp_receive+0x7cf>
  810669:	ba 01 00 00 00       	mov    $0x1,%edx
  81066e:	0f b7 ff             	movzwl %di,%edi
  810671:	01 fa                	add    %edi,%edx
  810673:	03 55 e4             	add    -0x1c(%ebp),%edx
  810676:	89 53 24             	mov    %edx,0x24(%ebx)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  810679:	0f b7 7b 28          	movzwl 0x28(%ebx),%edi
  81067d:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  810681:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  810685:	8b 46 10             	mov    0x10(%esi),%eax
  810688:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81068c:	89 04 24             	mov    %eax,(%esp)
  81068f:	e8 ed a5 ff ff       	call   80ac81 <ntohs>
  810694:	a8 01                	test   $0x1,%al
  810696:	75 18                	jne    8106b0 <tcp_receive+0x811>
  810698:	8b 46 10             	mov    0x10(%esi),%eax
  81069b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81069f:	89 04 24             	mov    %eax,(%esp)
  8106a2:	e8 da a5 ff ff       	call   80ac81 <ntohs>
  8106a7:	ba 00 00 00 00       	mov    $0x0,%edx
  8106ac:	a8 02                	test   $0x2,%al
  8106ae:	74 05                	je     8106b5 <tcp_receive+0x816>
  8106b0:	ba 01 00 00 00       	mov    $0x1,%edx
  8106b5:	0f b7 ff             	movzwl %di,%edi
  8106b8:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8106bc:	01 c2                	add    %eax,%edx
  8106be:	39 d7                	cmp    %edx,%edi
  8106c0:	7d 08                	jge    8106ca <tcp_receive+0x82b>
            pcb->rcv_wnd = 0;
  8106c2:	66 c7 43 28 00 00    	movw   $0x0,0x28(%ebx)
  8106c8:	eb 47                	jmp    810711 <tcp_receive+0x872>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  8106ca:	0f b7 7b 28          	movzwl 0x28(%ebx),%edi
  8106ce:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8106d2:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  8106d6:	8b 46 10             	mov    0x10(%esi),%eax
  8106d9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8106dd:	89 04 24             	mov    %eax,(%esp)
  8106e0:	e8 9c a5 ff ff       	call   80ac81 <ntohs>
  8106e5:	a8 01                	test   $0x1,%al
  8106e7:	75 18                	jne    810701 <tcp_receive+0x862>
  8106e9:	8b 46 10             	mov    0x10(%esi),%eax
  8106ec:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8106f0:	89 04 24             	mov    %eax,(%esp)
  8106f3:	e8 89 a5 ff ff       	call   80ac81 <ntohs>
  8106f8:	ba 00 00 00 00       	mov    $0x0,%edx
  8106fd:	a8 02                	test   $0x2,%al
  8106ff:	74 05                	je     810706 <tcp_receive+0x867>
  810701:	ba 01 00 00 00       	mov    $0x1,%edx
  810706:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  81070a:	66 29 d7             	sub    %dx,%di
  81070d:	66 89 7b 28          	mov    %di,0x28(%ebx)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  810711:	0f b7 7b 2a          	movzwl 0x2a(%ebx),%edi
  810715:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  810719:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  81071d:	8b 46 10             	mov    0x10(%esi),%eax
  810720:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810724:	89 04 24             	mov    %eax,(%esp)
  810727:	e8 55 a5 ff ff       	call   80ac81 <ntohs>
  81072c:	a8 01                	test   $0x1,%al
  81072e:	75 18                	jne    810748 <tcp_receive+0x8a9>
  810730:	8b 46 10             	mov    0x10(%esi),%eax
  810733:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810737:	89 04 24             	mov    %eax,(%esp)
  81073a:	e8 42 a5 ff ff       	call   80ac81 <ntohs>
  81073f:	ba 00 00 00 00       	mov    $0x0,%edx
  810744:	a8 02                	test   $0x2,%al
  810746:	74 05                	je     81074d <tcp_receive+0x8ae>
  810748:	ba 01 00 00 00       	mov    $0x1,%edx
  81074d:	0f b7 ff             	movzwl %di,%edi
  810750:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  810754:	01 c2                	add    %eax,%edx
  810756:	39 d7                	cmp    %edx,%edi
  810758:	7d 08                	jge    810762 <tcp_receive+0x8c3>
            pcb->rcv_ann_wnd = 0;
  81075a:	66 c7 43 2a 00 00    	movw   $0x0,0x2a(%ebx)
  810760:	eb 47                	jmp    8107a9 <tcp_receive+0x90a>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  810762:	0f b7 7b 2a          	movzwl 0x2a(%ebx),%edi
  810766:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  81076a:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  81076e:	8b 46 10             	mov    0x10(%esi),%eax
  810771:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810775:	89 04 24             	mov    %eax,(%esp)
  810778:	e8 04 a5 ff ff       	call   80ac81 <ntohs>
  81077d:	a8 01                	test   $0x1,%al
  81077f:	75 18                	jne    810799 <tcp_receive+0x8fa>
  810781:	8b 46 10             	mov    0x10(%esi),%eax
  810784:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810788:	89 04 24             	mov    %eax,(%esp)
  81078b:	e8 f1 a4 ff ff       	call   80ac81 <ntohs>
  810790:	ba 00 00 00 00       	mov    $0x0,%edx
  810795:	a8 02                	test   $0x2,%al
  810797:	74 05                	je     81079e <tcp_receive+0x8ff>
  810799:	ba 01 00 00 00       	mov    $0x1,%edx
  81079e:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  8107a2:	66 29 d7             	sub    %dx,%di
  8107a5:	66 89 7b 2a          	mov    %di,0x2a(%ebx)
          }

          if (cseg->p->tot_len > 0) {
  8107a9:	8b 46 04             	mov    0x4(%esi),%eax
  8107ac:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  8107b1:	74 24                	je     8107d7 <tcp_receive+0x938>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  8107b3:	8b 15 08 c2 b3 00    	mov    0xb3c208,%edx
  8107b9:	85 d2                	test   %edx,%edx
  8107bb:	74 0e                	je     8107cb <tcp_receive+0x92c>
              pbuf_cat(recv_data, cseg->p);
  8107bd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8107c1:	89 14 24             	mov    %edx,(%esp)
  8107c4:	e8 72 72 ff ff       	call   807a3b <pbuf_cat>
  8107c9:	eb 05                	jmp    8107d0 <tcp_receive+0x931>
            } else {
              recv_data = cseg->p;
  8107cb:	a3 08 c2 b3 00       	mov    %eax,0xb3c208
            }
            cseg->p = NULL;
  8107d0:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  8107d7:	8b 46 10             	mov    0x10(%esi),%eax
  8107da:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8107de:	89 04 24             	mov    %eax,(%esp)
  8107e1:	e8 9b a4 ff ff       	call   80ac81 <ntohs>
  8107e6:	a8 01                	test   $0x1,%al
  8107e8:	74 14                	je     8107fe <tcp_receive+0x95f>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  8107ea:	c6 05 04 c2 b3 00 20 	movb   $0x20,0xb3c204
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  8107f1:	83 7b 10 04          	cmpl   $0x4,0x10(%ebx)
  8107f5:	75 07                	jne    8107fe <tcp_receive+0x95f>
              pcb->state = CLOSE_WAIT;
  8107f7:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
            } 
          }


          pcb->ooseq = cseg->next;
  8107fe:	8b 06                	mov    (%esi),%eax
  810800:	89 43 7c             	mov    %eax,0x7c(%ebx)
          tcp_seg_free(cseg);
  810803:	89 34 24             	mov    %esi,(%esp)
  810806:	e8 e6 81 ff ff       	call   8089f1 <tcp_seg_free>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81080b:	8b 73 7c             	mov    0x7c(%ebx),%esi
  81080e:	85 f6                	test   %esi,%esi
  810810:	74 0f                	je     810821 <tcp_receive+0x982>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  810812:	8b 46 10             	mov    0x10(%esi),%eax
  810815:	8b 40 04             	mov    0x4(%eax),%eax
  810818:	3b 43 24             	cmp    0x24(%ebx),%eax
  81081b:	0f 84 0e fe ff ff    	je     81062f <tcp_receive+0x790>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  810821:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  810825:	a8 01                	test   $0x1,%al
  810827:	74 1b                	je     810844 <tcp_receive+0x9a5>
  810829:	83 e0 fe             	and    $0xfffffffe,%eax
  81082c:	83 c8 02             	or     $0x2,%eax
  81082f:	88 43 20             	mov    %al,0x20(%ebx)
  810832:	89 1c 24             	mov    %ebx,(%esp)
  810835:	e8 c1 aa ff ff       	call   80b2fb <tcp_output>
  81083a:	b8 01 00 00 00       	mov    $0x1,%eax
  81083f:	e9 cb 02 00 00       	jmp    810b0f <tcp_receive+0xc70>
  810844:	83 c8 01             	or     $0x1,%eax
  810847:	88 43 20             	mov    %al,0x20(%ebx)
  81084a:	b8 01 00 00 00       	mov    $0x1,%eax
  81084f:	e9 bb 02 00 00       	jmp    810b0f <tcp_receive+0xc70>

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  810854:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810858:	89 1c 24             	mov    %ebx,(%esp)
  81085b:	e8 9b aa ff ff       	call   80b2fb <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  810860:	8b 73 7c             	mov    0x7c(%ebx),%esi
  810863:	85 f6                	test   %esi,%esi
  810865:	74 31                	je     810898 <tcp_receive+0x9f9>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  810867:	8b 46 10             	mov    0x10(%esi),%eax
  81086a:	8b 40 04             	mov    0x4(%eax),%eax
  81086d:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  810873:	39 d0                	cmp    %edx,%eax
  810875:	74 18                	je     81088f <tcp_receive+0x9f0>
  810877:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  81087a:	bf 00 00 00 00       	mov    $0x0,%edi
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  81087f:	8d 72 01             	lea    0x1(%edx),%esi
  810882:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  810885:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  810888:	89 f3                	mov    %esi,%ebx
  81088a:	e9 b7 00 00 00       	jmp    810946 <tcp_receive+0xaa7>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  81088f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  810896:	eb 1f                	jmp    8108b7 <tcp_receive+0xa18>
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
          pcb->ooseq = tcp_seg_copy(&inseg);
  810898:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  81089f:	e8 0a 81 ff ff       	call   8089ae <tcp_seg_copy>
  8108a4:	89 43 7c             	mov    %eax,0x7c(%ebx)
  8108a7:	b8 00 00 00 00       	mov    $0x0,%eax
  8108ac:	e9 5e 02 00 00       	jmp    810b0f <tcp_receive+0xc70>
  8108b1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8108b4:	8b 5d e0             	mov    -0x20(%ebp),%ebx
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  8108b7:	0f b7 05 e8 c1 b3 00 	movzwl 0xb3c1e8,%eax
  8108be:	66 3b 46 0c          	cmp    0xc(%esi),%ax
  8108c2:	0f 86 42 02 00 00    	jbe    810b0a <tcp_receive+0xc6b>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  8108c8:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  8108cf:	e8 da 80 ff ff       	call   8089ae <tcp_seg_copy>
  8108d4:	89 c7                	mov    %eax,%edi
                if (cseg != NULL) {
  8108d6:	85 c0                	test   %eax,%eax
  8108d8:	0f 84 2c 02 00 00    	je     810b0a <tcp_receive+0xc6b>
                  cseg->next = next->next;
  8108de:	8b 06                	mov    (%esi),%eax
  8108e0:	89 07                	mov    %eax,(%edi)
                  if (prev != NULL) {
  8108e2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  8108e6:	74 07                	je     8108ef <tcp_receive+0xa50>
                    prev->next = cseg;
  8108e8:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  8108eb:	89 3b                	mov    %edi,(%ebx)
  8108ed:	eb 03                	jmp    8108f2 <tcp_receive+0xa53>
                  } else {
                    pcb->ooseq = cseg;
  8108ef:	89 7b 7c             	mov    %edi,0x7c(%ebx)
                  }
                  tcp_seg_free(next);
  8108f2:	89 34 24             	mov    %esi,(%esp)
  8108f5:	e8 f7 80 ff ff       	call   8089f1 <tcp_seg_free>
                  if (cseg->next != NULL) {
  8108fa:	8b 17                	mov    (%edi),%edx
  8108fc:	85 d2                	test   %edx,%edx
  8108fe:	0f 84 06 02 00 00    	je     810b0a <tcp_receive+0xc6b>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  810904:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  810909:	8b 52 10             	mov    0x10(%edx),%edx
  81090c:	8b 52 04             	mov    0x4(%edx),%edx
  81090f:	0f b7 4f 0c          	movzwl 0xc(%edi),%ecx
  810913:	29 d1                	sub    %edx,%ecx
  810915:	01 c1                	add    %eax,%ecx
  810917:	85 c9                	test   %ecx,%ecx
  810919:	0f 8e eb 01 00 00    	jle    810b0a <tcp_receive+0xc6b>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  81091f:	66 29 c2             	sub    %ax,%dx
  810922:	66 89 57 0c          	mov    %dx,0xc(%edi)
                      pbuf_realloc(cseg->p, cseg->len);
  810926:	0f b7 c2             	movzwl %dx,%eax
  810929:	89 44 24 04          	mov    %eax,0x4(%esp)
  81092d:	8b 47 04             	mov    0x4(%edi),%eax
  810930:	89 04 24             	mov    %eax,(%esp)
  810933:	e8 c8 76 ff ff       	call   808000 <pbuf_realloc>
  810938:	b8 00 00 00 00       	mov    $0x0,%eax
  81093d:	e9 cd 01 00 00       	jmp    810b0f <tcp_receive+0xc70>
  810942:	89 cf                	mov    %ecx,%edi
  810944:	89 f1                	mov    %esi,%ecx
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  810946:	85 ff                	test   %edi,%edi
  810948:	75 60                	jne    8109aa <tcp_receive+0xb0b>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  81094a:	39 c2                	cmp    %eax,%edx
  81094c:	0f 89 fd 00 00 00    	jns    810a4f <tcp_receive+0xbb0>
  810952:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  810955:	8b 5d e0             	mov    -0x20(%ebp),%ebx
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  810958:	0f b7 0d e8 c1 b3 00 	movzwl 0xb3c1e8,%ecx
  81095f:	01 d1                	add    %edx,%ecx
  810961:	29 c1                	sub    %eax,%ecx
  810963:	85 c9                	test   %ecx,%ecx
  810965:	7e 1d                	jle    810984 <tcp_receive+0xae5>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  810967:	66 29 d0             	sub    %dx,%ax
  81096a:	66 a3 e8 c1 b3 00    	mov    %ax,0xb3c1e8
                    pbuf_realloc(inseg.p, inseg.len);
  810970:	0f b7 c0             	movzwl %ax,%eax
  810973:	89 44 24 04          	mov    %eax,0x4(%esp)
  810977:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  81097c:	89 04 24             	mov    %eax,(%esp)
  81097f:	e8 7c 76 ff ff       	call   808000 <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
  810984:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  81098b:	e8 1e 80 ff ff       	call   8089ae <tcp_seg_copy>
                  if (cseg != NULL) {
  810990:	85 c0                	test   %eax,%eax
  810992:	0f 84 72 01 00 00    	je     810b0a <tcp_receive+0xc6b>
                    cseg->next = next;
  810998:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  81099b:	89 30                	mov    %esi,(%eax)
                    pcb->ooseq = cseg;
  81099d:	89 43 7c             	mov    %eax,0x7c(%ebx)
  8109a0:	b8 00 00 00 00       	mov    $0x0,%eax
  8109a5:	e9 65 01 00 00       	jmp    810b0f <tcp_receive+0xc70>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  8109aa:	8b 77 10             	mov    0x10(%edi),%esi
  8109ad:	8b 76 04             	mov    0x4(%esi),%esi
  8109b0:	f7 d6                	not    %esi
  8109b2:	01 d6                	add    %edx,%esi
  8109b4:	0f 88 95 00 00 00    	js     810a4f <tcp_receive+0xbb0>
  8109ba:	89 de                	mov    %ebx,%esi
  8109bc:	29 c6                	sub    %eax,%esi
  8109be:	85 f6                	test   %esi,%esi
  8109c0:	0f 8f 89 00 00 00    	jg     810a4f <tcp_receive+0xbb0>
  8109c6:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  8109c9:	0f b7 0d e8 c1 b3 00 	movzwl 0xb3c1e8,%ecx
  8109d0:	01 d1                	add    %edx,%ecx
  8109d2:	29 c1                	sub    %eax,%ecx
  8109d4:	85 c9                	test   %ecx,%ecx
  8109d6:	7e 1d                	jle    8109f5 <tcp_receive+0xb56>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  8109d8:	66 29 d0             	sub    %dx,%ax
  8109db:	66 a3 e8 c1 b3 00    	mov    %ax,0xb3c1e8
                  pbuf_realloc(inseg.p, inseg.len);
  8109e1:	0f b7 c0             	movzwl %ax,%eax
  8109e4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8109e8:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  8109ed:	89 04 24             	mov    %eax,(%esp)
  8109f0:	e8 0b 76 ff ff       	call   808000 <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
  8109f5:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  8109fc:	e8 ad 7f ff ff       	call   8089ae <tcp_seg_copy>
                if (cseg != NULL) {
  810a01:	85 c0                	test   %eax,%eax
  810a03:	0f 84 01 01 00 00    	je     810b0a <tcp_receive+0xc6b>
                  cseg->next = next;
  810a09:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  810a0c:	89 10                	mov    %edx,(%eax)
                  prev->next = cseg;
  810a0e:	89 07                	mov    %eax,(%edi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  810a10:	8b 47 10             	mov    0x10(%edi),%eax
  810a13:	8b 40 04             	mov    0x4(%eax),%eax
  810a16:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  810a1c:	0f b7 4f 0c          	movzwl 0xc(%edi),%ecx
  810a20:	29 d1                	sub    %edx,%ecx
  810a22:	01 c1                	add    %eax,%ecx
  810a24:	85 c9                	test   %ecx,%ecx
  810a26:	0f 8e de 00 00 00    	jle    810b0a <tcp_receive+0xc6b>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  810a2c:	66 29 c2             	sub    %ax,%dx
  810a2f:	66 89 57 0c          	mov    %dx,0xc(%edi)
                    pbuf_realloc(prev->p, prev->len);
  810a33:	0f b7 c2             	movzwl %dx,%eax
  810a36:	89 44 24 04          	mov    %eax,0x4(%esp)
  810a3a:	8b 47 04             	mov    0x4(%edi),%eax
  810a3d:	89 04 24             	mov    %eax,(%esp)
  810a40:	e8 bb 75 ff ff       	call   808000 <pbuf_realloc>
  810a45:	b8 00 00 00 00       	mov    $0x0,%eax
  810a4a:	e9 c0 00 00 00       	jmp    810b0f <tcp_receive+0xc70>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  810a4f:	8b 31                	mov    (%ecx),%esi
  810a51:	85 f6                	test   %esi,%esi
  810a53:	75 5e                	jne    810ab3 <tcp_receive+0xc14>
  810a55:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  810a58:	29 c2                	sub    %eax,%edx
  810a5a:	85 d2                	test   %edx,%edx
  810a5c:	0f 8e a8 00 00 00    	jle    810b0a <tcp_receive+0xc6b>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  810a62:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  810a69:	e8 40 7f ff ff       	call   8089ae <tcp_seg_copy>
  810a6e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  810a71:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  810a73:	85 c0                	test   %eax,%eax
  810a75:	0f 84 8f 00 00 00    	je     810b0a <tcp_receive+0xc6b>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  810a7b:	8b 43 10             	mov    0x10(%ebx),%eax
  810a7e:	8b 40 04             	mov    0x4(%eax),%eax
  810a81:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  810a87:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  810a8b:	29 d1                	sub    %edx,%ecx
  810a8d:	01 c1                	add    %eax,%ecx
  810a8f:	85 c9                	test   %ecx,%ecx
  810a91:	7e 77                	jle    810b0a <tcp_receive+0xc6b>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  810a93:	66 29 c2             	sub    %ax,%dx
  810a96:	66 89 53 0c          	mov    %dx,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  810a9a:	0f b7 c2             	movzwl %dx,%eax
  810a9d:	89 44 24 04          	mov    %eax,0x4(%esp)
  810aa1:	8b 43 04             	mov    0x4(%ebx),%eax
  810aa4:	89 04 24             	mov    %eax,(%esp)
  810aa7:	e8 54 75 ff ff       	call   808000 <pbuf_realloc>
  810aac:	b8 00 00 00 00       	mov    $0x0,%eax
  810ab1:	eb 5c                	jmp    810b0f <tcp_receive+0xc70>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  810ab3:	8b 46 10             	mov    0x10(%esi),%eax
  810ab6:	8b 40 04             	mov    0x4(%eax),%eax
  810ab9:	39 d0                	cmp    %edx,%eax
  810abb:	0f 85 81 fe ff ff    	jne    810942 <tcp_receive+0xaa3>
  810ac1:	e9 eb fd ff ff       	jmp    8108b1 <tcp_receive+0xa12>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  810ac6:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810aca:	89 1c 24             	mov    %ebx,(%esp)
  810acd:	e8 29 a8 ff ff       	call   80b2fb <tcp_output>
  810ad2:	b8 00 00 00 00       	mov    $0x0,%eax
  810ad7:	eb 36                	jmp    810b0f <tcp_receive+0xc70>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  810ad9:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  810adf:	8b 43 24             	mov    0x24(%ebx),%eax
  810ae2:	39 c2                	cmp    %eax,%edx
  810ae4:	78 11                	js     810af7 <tcp_receive+0xc58>
  810ae6:	83 c2 01             	add    $0x1,%edx
  810ae9:	29 c2                	sub    %eax,%edx
  810aeb:	89 d0                	mov    %edx,%eax
  810aed:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  810af1:	29 c8                	sub    %ecx,%eax
  810af3:	85 c0                	test   %eax,%eax
  810af5:	7e 13                	jle    810b0a <tcp_receive+0xc6b>
      tcp_ack_now(pcb);
  810af7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810afb:	89 1c 24             	mov    %ebx,(%esp)
  810afe:	e8 f8 a7 ff ff       	call   80b2fb <tcp_output>
  810b03:	b8 00 00 00 00       	mov    $0x0,%eax
  810b08:	eb 05                	jmp    810b0f <tcp_receive+0xc70>
  810b0a:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }
  return accepted_inseq;
}
  810b0f:	83 c4 2c             	add    $0x2c,%esp
  810b12:	5b                   	pop    %ebx
  810b13:	5e                   	pop    %esi
  810b14:	5f                   	pop    %edi
  810b15:	5d                   	pop    %ebp
  810b16:	c3                   	ret    

00810b17 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  810b17:	55                   	push   %ebp
  810b18:	89 e5                	mov    %esp,%ebp
  810b1a:	57                   	push   %edi
  810b1b:	56                   	push   %esi
  810b1c:	53                   	push   %ebx
  810b1d:	83 ec 5c             	sub    $0x5c,%esp
  810b20:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  810b23:	8b 46 04             	mov    0x4(%esi),%eax
  810b26:	a3 f4 c1 b3 00       	mov    %eax,0xb3c1f4
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  810b2b:	8b 5e 04             	mov    0x4(%esi),%ebx
  810b2e:	0f b7 00             	movzwl (%eax),%eax
  810b31:	89 04 24             	mov    %eax,(%esp)
  810b34:	e8 48 a1 ff ff       	call   80ac81 <ntohs>
  810b39:	c1 e8 06             	shr    $0x6,%eax
  810b3c:	83 e0 3c             	and    $0x3c,%eax
  810b3f:	01 c3                	add    %eax,%ebx
  810b41:	89 1d f0 c1 b3 00    	mov    %ebx,0xb3c1f0
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  810b47:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  810b4c:	0f b7 00             	movzwl (%eax),%eax
  810b4f:	89 04 24             	mov    %eax,(%esp)
  810b52:	e8 2a a1 ff ff       	call   80ac81 <ntohs>
  810b57:	66 c1 e8 06          	shr    $0x6,%ax
  810b5b:	83 e0 3c             	and    $0x3c,%eax
  810b5e:	f7 d8                	neg    %eax
  810b60:	98                   	cwtl   
  810b61:	89 44 24 04          	mov    %eax,0x4(%esp)
  810b65:	89 34 24             	mov    %esi,(%esp)
  810b68:	e8 96 6f ff ff       	call   807b03 <pbuf_header>
  810b6d:	84 c0                	test   %al,%al
  810b6f:	75 07                	jne    810b78 <tcp_input+0x61>
  810b71:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  810b76:	77 12                	ja     810b8a <tcp_input+0x73>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810b78:	89 34 24             	mov    %esi,(%esp)
  810b7b:	90                   	nop
  810b7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810b80:	e8 f3 72 ff ff       	call   807e78 <pbuf_free>
    return;
  810b85:	e9 9a 0d 00 00       	jmp    811924 <tcp_input+0xe0d>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  810b8a:	8b 45 0c             	mov    0xc(%ebp),%eax
  810b8d:	89 44 24 04          	mov    %eax,0x4(%esp)
  810b91:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  810b96:	83 c0 10             	add    $0x10,%eax
  810b99:	89 04 24             	mov    %eax,(%esp)
  810b9c:	e8 c7 8c ff ff       	call   809868 <ip_addr_isbroadcast>
  810ba1:	84 c0                	test   %al,%al
  810ba3:	75 28                	jne    810bcd <tcp_input+0xb6>
      ip_addr_ismulticast(&(iphdr->dest))) {
  810ba5:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  810baa:	8b 78 10             	mov    0x10(%eax),%edi
  810bad:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  810bb4:	e8 01 a3 ff ff       	call   80aeba <ntohl>
  810bb9:	89 c3                	mov    %eax,%ebx
  810bbb:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  810bc2:	e8 f3 a2 ff ff       	call   80aeba <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  810bc7:	21 fb                	and    %edi,%ebx
  810bc9:	39 c3                	cmp    %eax,%ebx
  810bcb:	75 0d                	jne    810bda <tcp_input+0xc3>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810bcd:	89 34 24             	mov    %esi,(%esp)
  810bd0:	e8 a3 72 ff ff       	call   807e78 <pbuf_free>
    return;
  810bd5:	e9 4a 0d 00 00       	jmp    811924 <tcp_input+0xe0d>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  810bda:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  810bdf:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  810be3:	89 54 24 10          	mov    %edx,0x10(%esp)
  810be7:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  810bee:	00 
  810bef:	8d 50 10             	lea    0x10(%eax),%edx
  810bf2:	89 54 24 08          	mov    %edx,0x8(%esp)
  810bf6:	83 c0 0c             	add    $0xc,%eax
  810bf9:	89 44 24 04          	mov    %eax,0x4(%esp)
  810bfd:	89 34 24             	mov    %esi,(%esp)
  810c00:	e8 6b 9d ff ff       	call   80a970 <inet_chksum_pseudo>
  810c05:	66 85 c0             	test   %ax,%ax
  810c08:	74 0d                	je     810c17 <tcp_input+0x100>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810c0a:	89 34 24             	mov    %esi,(%esp)
  810c0d:	e8 66 72 ff ff       	call   807e78 <pbuf_free>
    return;
  810c12:	e9 0d 0d 00 00       	jmp    811924 <tcp_input+0xe0d>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  810c17:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  810c1c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810c20:	89 04 24             	mov    %eax,(%esp)
  810c23:	e8 59 a0 ff ff       	call   80ac81 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  810c28:	66 c1 e8 0c          	shr    $0xc,%ax
  810c2c:	c1 e0 02             	shl    $0x2,%eax
  810c2f:	f7 d8                	neg    %eax
  810c31:	98                   	cwtl   
  810c32:	89 44 24 04          	mov    %eax,0x4(%esp)
  810c36:	89 34 24             	mov    %esi,(%esp)
  810c39:	e8 c5 6e ff ff       	call   807b03 <pbuf_header>
  810c3e:	84 c0                	test   %al,%al
  810c40:	74 0d                	je     810c4f <tcp_input+0x138>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810c42:	89 34 24             	mov    %esi,(%esp)
  810c45:	e8 2e 72 ff ff       	call   807e78 <pbuf_free>
    return;
  810c4a:	e9 d5 0c 00 00       	jmp    811924 <tcp_input+0xe0d>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  810c4f:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  810c55:	0f b7 03             	movzwl (%ebx),%eax
  810c58:	89 04 24             	mov    %eax,(%esp)
  810c5b:	e8 21 a0 ff ff       	call   80ac81 <ntohs>
  810c60:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  810c63:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  810c69:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  810c6d:	89 04 24             	mov    %eax,(%esp)
  810c70:	e8 0c a0 ff ff       	call   80ac81 <ntohs>
  810c75:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  810c79:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  810c7f:	8b 43 04             	mov    0x4(%ebx),%eax
  810c82:	89 04 24             	mov    %eax,(%esp)
  810c85:	e8 30 a2 ff ff       	call   80aeba <ntohl>
  810c8a:	89 43 04             	mov    %eax,0x4(%ebx)
  810c8d:	a3 f8 c1 b3 00       	mov    %eax,0xb3c1f8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  810c92:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  810c98:	8b 43 08             	mov    0x8(%ebx),%eax
  810c9b:	89 04 24             	mov    %eax,(%esp)
  810c9e:	e8 17 a2 ff ff       	call   80aeba <ntohl>
  810ca3:	89 43 08             	mov    %eax,0x8(%ebx)
  810ca6:	a3 fc c1 b3 00       	mov    %eax,0xb3c1fc
  tcphdr->wnd = ntohs(tcphdr->wnd);
  810cab:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  810cb1:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  810cb5:	89 04 24             	mov    %eax,(%esp)
  810cb8:	e8 c4 9f ff ff       	call   80ac81 <ntohs>
  810cbd:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  810cc1:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  810cc6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810cca:	89 04 24             	mov    %eax,(%esp)
  810ccd:	e8 af 9f ff ff       	call   80ac81 <ntohs>
  810cd2:	83 e0 3f             	and    $0x3f,%eax
  810cd5:	a2 00 c2 b3 00       	mov    %al,0xb3c200
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  810cda:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  810cde:	ba 01 00 00 00       	mov    $0x1,%edx
  810ce3:	a8 01                	test   $0x1,%al
  810ce5:	75 07                	jne    810cee <tcp_input+0x1d7>
  810ce7:	d1 e8                	shr    %eax
  810ce9:	89 c2                	mov    %eax,%edx
  810ceb:	83 e2 01             	and    $0x1,%edx
  810cee:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  810cf1:	66 89 15 02 c2 b3 00 	mov    %dx,0xb3c202
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810cf8:	8b 1d 0c f0 b3 00    	mov    0xb3f00c,%ebx
  810cfe:	85 db                	test   %ebx,%ebx
  810d00:	0f 84 32 01 00 00    	je     810e38 <tcp_input+0x321>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  810d06:	8b 43 10             	mov    0x10(%ebx),%eax
  810d09:	85 c0                	test   %eax,%eax
  810d0b:	74 15                	je     810d22 <tcp_input+0x20b>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  810d0d:	83 f8 0a             	cmp    $0xa,%eax
  810d10:	74 31                	je     810d43 <tcp_input+0x22c>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  810d12:	83 f8 01             	cmp    $0x1,%eax
  810d15:	75 6f                	jne    810d86 <tcp_input+0x26f>
  810d17:	90                   	nop
  810d18:	eb 50                	jmp    810d6a <tcp_input+0x253>
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  810d1a:	8b 50 10             	mov    0x10(%eax),%edx
  810d1d:	85 d2                	test   %edx,%edx
  810d1f:	90                   	nop
  810d20:	75 1c                	jne    810d3e <tcp_input+0x227>
  810d22:	c7 44 24 08 dc 4c 81 	movl   $0x814cdc,0x8(%esp)
  810d29:	00 
  810d2a:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  810d31:	00 
  810d32:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  810d39:	e8 aa fc fe ff       	call   8009e8 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  810d3e:	83 fa 0a             	cmp    $0xa,%edx
  810d41:	75 1c                	jne    810d5f <tcp_input+0x248>
  810d43:	c7 44 24 08 04 4d 81 	movl   $0x814d04,0x8(%esp)
  810d4a:	00 
  810d4b:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
  810d52:	00 
  810d53:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  810d5a:	e8 89 fc fe ff       	call   8009e8 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  810d5f:	83 fa 01             	cmp    $0x1,%edx
  810d62:	74 06                	je     810d6a <tcp_input+0x253>
  810d64:	89 da                	mov    %ebx,%edx
  810d66:	89 c3                	mov    %eax,%ebx
  810d68:	eb 35                	jmp    810d9f <tcp_input+0x288>
  810d6a:	c7 44 24 08 30 4d 81 	movl   $0x814d30,0x8(%esp)
  810d71:	00 
  810d72:	c7 44 24 04 b7 00 00 	movl   $0xb7,0x4(%esp)
  810d79:	00 
  810d7a:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  810d81:	e8 62 fc fe ff       	call   8009e8 <_panic>
    if (pcb->remote_port == tcphdr->src &&
  810d86:	8b 3d f0 c1 b3 00    	mov    0xb3c1f0,%edi
  810d8c:	0f b7 0f             	movzwl (%edi),%ecx
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  810d8f:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  810d94:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  810d97:	ba 00 00 00 00       	mov    $0x0,%edx
  810d9c:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  810d9f:	66 39 4b 1e          	cmp    %cx,0x1e(%ebx)
  810da3:	75 7b                	jne    810e20 <tcp_input+0x309>
       pcb->local_port == tcphdr->dest &&
  810da5:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  810da9:	66 3b 47 02          	cmp    0x2(%edi),%ax
  810dad:	75 71                	jne    810e20 <tcp_input+0x309>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  810daf:	8b 43 04             	mov    0x4(%ebx),%eax
  810db2:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  810db5:	3b 46 0c             	cmp    0xc(%esi),%eax
  810db8:	75 66                	jne    810e20 <tcp_input+0x309>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  810dba:	8b 03                	mov    (%ebx),%eax
  810dbc:	3b 46 10             	cmp    0x10(%esi),%eax
  810dbf:	75 5f                	jne    810e20 <tcp_input+0x309>
  810dc1:	8b 75 c4             	mov    -0x3c(%ebp),%esi
  810dc4:	89 d8                	mov    %ebx,%eax

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  810dc6:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  810dc9:	39 d9                	cmp    %ebx,%ecx
  810dcb:	75 1c                	jne    810de9 <tcp_input+0x2d2>
  810dcd:	c7 44 24 08 58 4d 81 	movl   $0x814d58,0x8(%esp)
  810dd4:	00 
  810dd5:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  810ddc:	00 
  810ddd:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  810de4:	e8 ff fb fe ff       	call   8009e8 <_panic>
      if (prev != NULL) {
  810de9:	85 d2                	test   %edx,%edx
  810deb:	74 43                	je     810e30 <tcp_input+0x319>
        prev->next = pcb->next;
  810ded:	89 4a 0c             	mov    %ecx,0xc(%edx)
        pcb->next = tcp_active_pcbs;
  810df0:	8b 15 0c f0 b3 00    	mov    0xb3f00c,%edx
  810df6:	89 53 0c             	mov    %edx,0xc(%ebx)
        tcp_active_pcbs = pcb;
  810df9:	89 1d 0c f0 b3 00    	mov    %ebx,0xb3f00c
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  810dff:	39 5b 0c             	cmp    %ebx,0xc(%ebx)
  810e02:	75 2c                	jne    810e30 <tcp_input+0x319>
  810e04:	c7 44 24 08 84 4d 81 	movl   $0x814d84,0x8(%esp)
  810e0b:	00 
  810e0c:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
  810e13:	00 
  810e14:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  810e1b:	e8 c8 fb fe ff       	call   8009e8 <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810e20:	8b 43 0c             	mov    0xc(%ebx),%eax
  810e23:	85 c0                	test   %eax,%eax
  810e25:	0f 85 ef fe ff ff    	jne    810d1a <tcp_input+0x203>
  810e2b:	8b 75 c4             	mov    -0x3c(%ebp),%esi
  810e2e:	eb 08                	jmp    810e38 <tcp_input+0x321>
      break;
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  810e30:	85 c0                	test   %eax,%eax
  810e32:	0f 85 be 02 00 00    	jne    8110f6 <tcp_input+0x5df>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810e38:	8b 1d 20 f0 b3 00    	mov    0xb3f020,%ebx
  810e3e:	85 db                	test   %ebx,%ebx
  810e40:	0f 84 ad 00 00 00    	je     810ef3 <tcp_input+0x3dc>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  810e46:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  810e4a:	74 2a                	je     810e76 <tcp_input+0x35f>
  810e4c:	eb 0c                	jmp    810e5a <tcp_input+0x343>
  810e4e:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  810e52:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810e58:	74 2b                	je     810e85 <tcp_input+0x36e>
  810e5a:	c7 44 24 08 b0 4d 81 	movl   $0x814db0,0x8(%esp)
  810e61:	00 
  810e62:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
  810e69:	00 
  810e6a:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  810e71:	e8 72 fb fe ff       	call   8009e8 <_panic>
      if (pcb->remote_port == tcphdr->src &&
  810e76:	8b 0d f0 c1 b3 00    	mov    0xb3c1f0,%ecx
  810e7c:	0f b7 01             	movzwl (%ecx),%eax
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  810e7f:	8b 3d f4 c1 b3 00    	mov    0xb3c1f4,%edi
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
  810e85:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  810e89:	75 5d                	jne    810ee8 <tcp_input+0x3d1>
         pcb->local_port == tcphdr->dest &&
  810e8b:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  810e8f:	66 3b 51 02          	cmp    0x2(%ecx),%dx
  810e93:	75 53                	jne    810ee8 <tcp_input+0x3d1>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  810e95:	8b 53 04             	mov    0x4(%ebx),%edx
  810e98:	3b 57 0c             	cmp    0xc(%edi),%edx
  810e9b:	75 4b                	jne    810ee8 <tcp_input+0x3d1>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  810e9d:	8b 13                	mov    (%ebx),%edx
  810e9f:	3b 57 10             	cmp    0x10(%edi),%edx
  810ea2:	75 44                	jne    810ee8 <tcp_input+0x3d1>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  810ea4:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  810eab:	03 05 f8 c1 b3 00    	add    0xb3c1f8,%eax
  810eb1:	89 c2                	mov    %eax,%edx
  810eb3:	2b 53 24             	sub    0x24(%ebx),%edx
  810eb6:	85 d2                	test   %edx,%edx
  810eb8:	7e 03                	jle    810ebd <tcp_input+0x3a6>
    pcb->rcv_nxt = seqno + tcplen;
  810eba:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  810ebd:	66 83 3d 02 c2 b3 00 	cmpw   $0x0,0xb3c202
  810ec4:	00 
  810ec5:	74 0c                	je     810ed3 <tcp_input+0x3bc>
    tcp_ack_now(pcb);
  810ec7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810ecb:	89 1c 24             	mov    %ebx,(%esp)
  810ece:	e8 28 a4 ff ff       	call   80b2fb <tcp_output>
  }
  return tcp_output(pcb);
  810ed3:	89 1c 24             	mov    %ebx,(%esp)
  810ed6:	e8 20 a4 ff ff       	call   80b2fb <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  810edb:	89 34 24             	mov    %esi,(%esp)
  810ede:	e8 95 6f ff ff       	call   807e78 <pbuf_free>
        return;
  810ee3:	e9 3c 0a 00 00       	jmp    811924 <tcp_input+0xe0d>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810ee8:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  810eeb:	85 db                	test   %ebx,%ebx
  810eed:	0f 85 5b ff ff ff    	jne    810e4e <tcp_input+0x337>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  810ef3:	8b 3d 14 f0 b3 00    	mov    0xb3f014,%edi
  810ef9:	85 ff                	test   %edi,%edi
  810efb:	0f 84 ed 01 00 00    	je     8110ee <tcp_input+0x5d7>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  810f01:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
        lpcb->local_port == tcphdr->dest) {
  810f06:	8b 0d f0 c1 b3 00    	mov    0xb3c1f0,%ecx
  810f0c:	ba 00 00 00 00       	mov    $0x0,%edx
  810f11:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  810f14:	89 c3                	mov    %eax,%ebx

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  810f16:	85 ff                	test   %edi,%edi
  810f18:	74 0f                	je     810f29 <tcp_input+0x412>
  810f1a:	8b 07                	mov    (%edi),%eax
  810f1c:	85 c0                	test   %eax,%eax
  810f1e:	74 09                	je     810f29 <tcp_input+0x412>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  810f20:	3b 43 10             	cmp    0x10(%ebx),%eax
  810f23:	0f 85 b1 01 00 00    	jne    8110da <tcp_input+0x5c3>
        lpcb->local_port == tcphdr->dest) {
  810f29:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  810f2d:	66 3b 41 02          	cmp    0x2(%ecx),%ax
  810f31:	0f 85 a3 01 00 00    	jne    8110da <tcp_input+0x5c3>
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  810f37:	85 d2                	test   %edx,%edx
  810f39:	74 14                	je     810f4f <tcp_input+0x438>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  810f3b:	8b 47 0c             	mov    0xc(%edi),%eax
  810f3e:	89 42 0c             	mov    %eax,0xc(%edx)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  810f41:	a1 14 f0 b3 00       	mov    0xb3f014,%eax
  810f46:	89 47 0c             	mov    %eax,0xc(%edi)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  810f49:	89 3d 14 f0 b3 00    	mov    %edi,0xb3f014
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  810f4f:	0f b6 05 00 c2 b3 00 	movzbl 0xb3c200,%eax
  810f56:	a8 10                	test   $0x10,%al
  810f58:	74 4e                	je     810fa8 <tcp_input+0x491>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  810f5a:	8b 15 f0 c1 b3 00    	mov    0xb3c1f0,%edx
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
  810f60:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  810f65:	0f b7 0a             	movzwl (%edx),%ecx
  810f68:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  810f6c:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  810f70:	89 54 24 10          	mov    %edx,0x10(%esp)
  810f74:	8d 50 0c             	lea    0xc(%eax),%edx
  810f77:	89 54 24 0c          	mov    %edx,0xc(%esp)
  810f7b:	83 c0 10             	add    $0x10,%eax
  810f7e:	89 44 24 08          	mov    %eax,0x8(%esp)
  810f82:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  810f89:	03 05 f8 c1 b3 00    	add    0xb3c1f8,%eax
  810f8f:	89 44 24 04          	mov    %eax,0x4(%esp)
  810f93:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  810f98:	83 c0 01             	add    $0x1,%eax
  810f9b:	89 04 24             	mov    %eax,(%esp)
  810f9e:	e8 f9 a1 ff ff       	call   80b19c <tcp_rst>
  810fa3:	e9 25 01 00 00       	jmp    8110cd <tcp_input+0x5b6>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  810fa8:	a8 02                	test   $0x2,%al
  810faa:	0f 84 1d 01 00 00    	je     8110cd <tcp_input+0x5b6>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  810fb0:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  810fb4:	89 04 24             	mov    %eax,(%esp)
  810fb7:	e8 f2 80 ff ff       	call   8090ae <tcp_alloc>
  810fbc:	89 c3                	mov    %eax,%ebx
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  810fbe:	85 c0                	test   %eax,%eax
  810fc0:	0f 84 07 01 00 00    	je     8110cd <tcp_input+0x5b6>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  810fc6:	8b 15 f4 c1 b3 00    	mov    0xb3c1f4,%edx
  810fcc:	b8 00 00 00 00       	mov    $0x0,%eax
  810fd1:	83 fa f0             	cmp    $0xfffffff0,%edx
  810fd4:	74 03                	je     810fd9 <tcp_input+0x4c2>
  810fd6:	8b 42 10             	mov    0x10(%edx),%eax
  810fd9:	89 03                	mov    %eax,(%ebx)
    npcb->local_port = pcb->local_port;
  810fdb:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  810fdf:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  810fe3:	8b 15 f4 c1 b3 00    	mov    0xb3c1f4,%edx
  810fe9:	b8 00 00 00 00       	mov    $0x0,%eax
  810fee:	83 fa f4             	cmp    $0xfffffff4,%edx
  810ff1:	74 03                	je     810ff6 <tcp_input+0x4df>
  810ff3:	8b 42 0c             	mov    0xc(%edx),%eax
  810ff6:	89 43 04             	mov    %eax,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  810ff9:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  810ffe:	0f b7 00             	movzwl (%eax),%eax
  811001:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  811005:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  81100c:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  811011:	83 c0 01             	add    $0x1,%eax
  811014:	89 43 24             	mov    %eax,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  811017:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  81101c:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  811020:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  811024:	66 89 43 50          	mov    %ax,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  811028:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  81102d:	83 e8 01             	sub    $0x1,%eax
  811030:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  811033:	8b 47 18             	mov    0x18(%edi),%eax
  811036:	89 43 18             	mov    %eax,0x18(%ebx)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  811039:	8b 47 20             	mov    0x20(%edi),%eax
  81103c:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  811042:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  811046:	66 25 99 01          	and    $0x199,%ax
  81104a:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  81104e:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  811053:	89 43 0c             	mov    %eax,0xc(%ebx)
  811056:	89 1d 0c f0 b3 00    	mov    %ebx,0xb3f00c
  81105c:	e8 bc 3e ff ff       	call   804f1d <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  811061:	89 d8                	mov    %ebx,%eax
  811063:	e8 88 ed ff ff       	call   80fdf0 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  811068:	8d 43 04             	lea    0x4(%ebx),%eax
  81106b:	89 44 24 04          	mov    %eax,0x4(%esp)
  81106f:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  811073:	89 04 24             	mov    %eax,(%esp)
  811076:	e8 e6 77 ff ff       	call   808861 <tcp_eff_send_mss>
  81107b:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  81107f:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  811086:	e8 0a 9c ff ff       	call   80ac95 <htonl>
  81108b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  81108e:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  811095:	00 
  811096:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  811099:	89 44 24 14          	mov    %eax,0x14(%esp)
  81109d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8110a4:	00 
  8110a5:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  8110ac:	00 
  8110ad:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8110b4:	00 
  8110b5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8110bc:	00 
  8110bd:	89 1c 24             	mov    %ebx,(%esp)
  8110c0:	e8 83 a7 ff ff       	call   80b848 <tcp_enqueue>
    return tcp_output(npcb);
  8110c5:	89 1c 24             	mov    %ebx,(%esp)
  8110c8:	e8 2e a2 ff ff       	call   80b2fb <tcp_output>
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  8110cd:	89 34 24             	mov    %esi,(%esp)
  8110d0:	e8 a3 6d ff ff       	call   807e78 <pbuf_free>
        return;
  8110d5:	e9 4a 08 00 00       	jmp    811924 <tcp_input+0xe0d>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8110da:	8b 47 0c             	mov    0xc(%edi),%eax
  8110dd:	85 c0                	test   %eax,%eax
  8110df:	90                   	nop
  8110e0:	74 09                	je     8110eb <tcp_input+0x5d4>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
        return;
      }
      prev = (struct tcp_pcb *)lpcb;
  8110e2:	89 fa                	mov    %edi,%edx
  8110e4:	89 c7                	mov    %eax,%edi
  8110e6:	e9 2b fe ff ff       	jmp    810f16 <tcp_input+0x3ff>
  8110eb:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  8110ee:	85 db                	test   %ebx,%ebx
  8110f0:	0f 84 9b 07 00 00    	je     811891 <tcp_input+0xd7a>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  8110f6:	c7 05 dc c1 b3 00 00 	movl   $0x0,0xb3c1dc
  8110fd:	00 00 00 
    inseg.len = p->tot_len;
  811100:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  811104:	66 a3 e8 c1 b3 00    	mov    %ax,0xb3c1e8
    inseg.dataptr = p->payload;
  81110a:	8b 46 04             	mov    0x4(%esi),%eax
  81110d:	a3 e4 c1 b3 00       	mov    %eax,0xb3c1e4
    inseg.p = p;
  811112:	89 35 e0 c1 b3 00    	mov    %esi,0xb3c1e0
    inseg.tcphdr = tcphdr;
  811118:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  81111d:	a3 ec c1 b3 00       	mov    %eax,0xb3c1ec

    recv_data = NULL;
  811122:	c7 05 08 c2 b3 00 00 	movl   $0x0,0xb3c208
  811129:	00 00 00 
    recv_flags = 0;
  81112c:	c6 05 04 c2 b3 00 00 	movb   $0x0,0xb3c204

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  811133:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  811139:	85 c0                	test   %eax,%eax
  81113b:	74 49                	je     811186 <tcp_input+0x66f>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  81113d:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  811143:	85 d2                	test   %edx,%edx
  811145:	74 1e                	je     811165 <tcp_input+0x64e>
  811147:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  81114e:	00 
  81114f:	89 44 24 08          	mov    %eax,0x8(%esp)
  811153:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811157:	8b 43 18             	mov    0x18(%ebx),%eax
  81115a:	89 04 24             	mov    %eax,(%esp)
  81115d:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  81115f:	84 c0                	test   %al,%al
  811161:	74 0a                	je     81116d <tcp_input+0x656>
  811163:	eb 14                	jmp    811179 <tcp_input+0x662>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  811165:	89 04 24             	mov    %eax,(%esp)
  811168:	e8 0b 6d ff ff       	call   807e78 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  81116d:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  811174:	00 00 00 
  811177:	eb 0d                	jmp    811186 <tcp_input+0x66f>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  811179:	89 34 24             	mov    %esi,(%esp)
  81117c:	e8 f7 6c ff ff       	call   807e78 <pbuf_free>
        return;
  811181:	e9 9e 07 00 00       	jmp    811924 <tcp_input+0xe0d>
      }
    }

    tcp_input_pcb = pcb;
  811186:	89 1d 28 f0 b3 00    	mov    %ebx,0xb3f028
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  81118c:	f6 05 00 c2 b3 00 04 	testb  $0x4,0xb3c200
  811193:	74 68                	je     8111fd <tcp_input+0x6e6>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  811195:	8b 43 10             	mov    0x10(%ebx),%eax
  811198:	83 f8 02             	cmp    $0x2,%eax
  81119b:	75 0e                	jne    8111ab <tcp_input+0x694>
  81119d:	8b 53 54             	mov    0x54(%ebx),%edx
  8111a0:	3b 15 fc c1 b3 00    	cmp    0xb3c1fc,%edx
  8111a6:	0f 94 c2             	sete   %dl
  8111a9:	eb 1a                	jmp    8111c5 <tcp_input+0x6ae>
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  8111ab:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  8111b1:	2b 53 24             	sub    0x24(%ebx),%edx
  8111b4:	0f 88 51 07 00 00    	js     81190b <tcp_input+0xdf4>
  8111ba:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  8111be:	29 ca                	sub    %ecx,%edx
  8111c0:	85 d2                	test   %edx,%edx
  8111c2:	0f 9e c2             	setle  %dl
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  8111c5:	84 d2                	test   %dl,%dl
  8111c7:	0f 84 3e 07 00 00    	je     81190b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  8111cd:	85 c0                	test   %eax,%eax
  8111cf:	75 1c                	jne    8111ed <tcp_input+0x6d6>
  8111d1:	c7 44 24 08 e0 4d 81 	movl   $0x814de0,0x8(%esp)
  8111d8:	00 
  8111d9:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
  8111e0:	00 
  8111e1:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  8111e8:	e8 fb f7 fe ff       	call   8009e8 <_panic>
      recv_flags = TF_RESET;
  8111ed:	c6 05 04 c2 b3 00 08 	movb   $0x8,0xb3c204
      pcb->flags &= ~TF_ACK_DELAY;
  8111f4:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  8111f8:	e9 0e 07 00 00       	jmp    81190b <tcp_input+0xdf4>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  8111fd:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  811202:	89 43 2c             	mov    %eax,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  811205:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  81120c:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  811210:	0f 87 07 05 00 00    	ja     81171d <tcp_input+0xc06>
  811216:	8b 43 10             	mov    0x10(%ebx),%eax
  811219:	ff 24 85 84 4e 81 00 	jmp    *0x814e84(,%eax,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  811220:	0f b6 05 00 c2 b3 00 	movzbl 0xb3c200,%eax
  811227:	83 e0 12             	and    $0x12,%eax
  81122a:	83 f8 12             	cmp    $0x12,%eax
  81122d:	0f 85 0a 01 00 00    	jne    81133d <tcp_input+0x826>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  811233:	8b 43 78             	mov    0x78(%ebx),%eax
  811236:	8b 40 10             	mov    0x10(%eax),%eax
  811239:	8b 40 04             	mov    0x4(%eax),%eax
  81123c:	89 04 24             	mov    %eax,(%esp)
  81123f:	e8 76 9c ff ff       	call   80aeba <ntohl>
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  811244:	83 c0 01             	add    $0x1,%eax
  811247:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  81124d:	0f 85 ea 00 00 00    	jne    81133d <tcp_input+0x826>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
  811253:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  811258:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  81125d:	83 c0 01             	add    $0x1,%eax
  811260:	89 43 24             	mov    %eax,0x24(%ebx)
      pcb->lastack = ackno;
  811263:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  811268:	89 43 48             	mov    %eax,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  81126b:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  811270:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  811274:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  811278:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  81127d:	83 e8 01             	sub    $0x1,%eax
  811280:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  811283:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  81128a:	89 d8                	mov    %ebx,%eax
  81128c:	e8 5f eb ff ff       	call   80fdf0 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  811291:	8d 43 04             	lea    0x4(%ebx),%eax
  811294:	89 44 24 04          	mov    %eax,0x4(%esp)
  811298:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  81129c:	89 04 24             	mov    %eax,(%esp)
  81129f:	e8 bd 75 ff ff       	call   808861 <tcp_eff_send_mss>
  8112a4:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  8112a8:	6b d0 0a             	imul   $0xa,%eax,%edx
  8112ab:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  8112af:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  8112b4:	75 02                	jne    8112b8 <tcp_input+0x7a1>
  8112b6:	01 c0                	add    %eax,%eax
  8112b8:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  8112bc:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  8112c0:	66 85 c0             	test   %ax,%ax
  8112c3:	75 1c                	jne    8112e1 <tcp_input+0x7ca>
  8112c5:	c7 44 24 08 59 4e 81 	movl   $0x814e59,0x8(%esp)
  8112cc:	00 
  8112cd:	c7 44 24 04 35 02 00 	movl   $0x235,0x4(%esp)
  8112d4:	00 
  8112d5:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  8112dc:	e8 07 f7 fe ff       	call   8009e8 <_panic>
      --pcb->snd_queuelen;
  8112e1:	83 e8 01             	sub    $0x1,%eax
  8112e4:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  8112e8:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  8112eb:	8b 10                	mov    (%eax),%edx
  8112ed:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  8112f0:	85 d2                	test   %edx,%edx
  8112f2:	75 08                	jne    8112fc <tcp_input+0x7e5>
        pcb->rtime = -1;
  8112f4:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  8112fa:	eb 0a                	jmp    811306 <tcp_input+0x7ef>
      else {
        pcb->rtime = 0;
  8112fc:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  811302:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  811306:	89 04 24             	mov    %eax,(%esp)
  811309:	e8 e3 76 ff ff       	call   8089f1 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  81130e:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  811314:	85 c0                	test   %eax,%eax
  811316:	74 14                	je     81132c <tcp_input+0x815>
  811318:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81131f:	00 
  811320:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811324:	8b 53 18             	mov    0x18(%ebx),%edx
  811327:	89 14 24             	mov    %edx,(%esp)
  81132a:	ff d0                	call   *%eax
      tcp_ack_now(pcb);
  81132c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  811330:	89 1c 24             	mov    %ebx,(%esp)
  811333:	e8 c3 9f ff ff       	call   80b2fb <tcp_output>
  811338:	e9 ce 05 00 00       	jmp    81190b <tcp_input+0xdf4>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  81133d:	f6 05 00 c2 b3 00 10 	testb  $0x10,0xb3c200
  811344:	0f 84 c1 05 00 00    	je     81190b <tcp_input+0xdf4>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81134a:	8b 15 f0 c1 b3 00    	mov    0xb3c1f0,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  811350:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  811355:	0f b7 0a             	movzwl (%edx),%ecx
  811358:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  81135c:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  811360:	89 54 24 10          	mov    %edx,0x10(%esp)
  811364:	8d 50 0c             	lea    0xc(%eax),%edx
  811367:	89 54 24 0c          	mov    %edx,0xc(%esp)
  81136b:	83 c0 10             	add    $0x10,%eax
  81136e:	89 44 24 08          	mov    %eax,0x8(%esp)
  811372:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  811379:	03 05 f8 c1 b3 00    	add    0xb3c1f8,%eax
  81137f:	89 44 24 04          	mov    %eax,0x4(%esp)
  811383:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  811388:	89 04 24             	mov    %eax,(%esp)
  81138b:	e8 0c 9e ff ff       	call   80b19c <tcp_rst>
  811390:	e9 76 05 00 00       	jmp    81190b <tcp_input+0xdf4>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  811395:	0f b6 05 00 c2 b3 00 	movzbl 0xb3c200,%eax
  81139c:	83 e0 14             	and    $0x14,%eax
  81139f:	83 f8 10             	cmp    $0x10,%eax
  8113a2:	0f 85 63 05 00 00    	jne    81190b <tcp_input+0xdf4>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  8113a8:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  8113ad:	8b 53 48             	mov    0x48(%ebx),%edx
  8113b0:	f7 d2                	not    %edx
  8113b2:	01 c2                	add    %eax,%edx
  8113b4:	0f 88 b7 00 00 00    	js     811471 <tcp_input+0x95a>
  8113ba:	89 c2                	mov    %eax,%edx
  8113bc:	2b 53 54             	sub    0x54(%ebx),%edx
  8113bf:	85 d2                	test   %edx,%edx
  8113c1:	0f 8f aa 00 00 00    	jg     811471 <tcp_input+0x95a>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  8113c7:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  8113ce:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  8113d4:	85 c0                	test   %eax,%eax
  8113d6:	75 1c                	jne    8113f4 <tcp_input+0x8dd>
  8113d8:	c7 44 24 08 6f 4e 81 	movl   $0x814e6f,0x8(%esp)
  8113df:	00 
  8113e0:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
  8113e7:	00 
  8113e8:	c7 04 24 00 4e 81 00 	movl   $0x814e00,(%esp)
  8113ef:	e8 f4 f5 fe ff       	call   8009e8 <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  8113f4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8113fb:	00 
  8113fc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811400:	8b 53 18             	mov    0x18(%ebx),%edx
  811403:	89 14 24             	mov    %edx,(%esp)
  811406:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  811408:	84 c0                	test   %al,%al
  81140a:	74 17                	je     811423 <tcp_input+0x90c>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  81140c:	89 1c 24             	mov    %ebx,(%esp)
  81140f:	e8 8a 7b ff ff       	call   808f9e <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  811414:	c7 05 28 f0 b3 00 00 	movl   $0x0,0xb3f028
  81141b:	00 00 00 
  81141e:	e9 4a 04 00 00       	jmp    81186d <tcp_input+0xd56>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  811423:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  811427:	89 d8                	mov    %ebx,%eax
  811429:	e8 71 ea ff ff       	call   80fe9f <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81142e:	66 83 fe 01          	cmp    $0x1,%si
  811432:	75 08                	jne    81143c <tcp_input+0x925>
  811434:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  811438:	01 d2                	add    %edx,%edx
  81143a:	eb 04                	jmp    811440 <tcp_input+0x929>
  81143c:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  811440:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  811444:	f6 05 00 c2 b3 00 01 	testb  $0x1,0xb3c200
  81144b:	0f 84 ba 04 00 00    	je     81190b <tcp_input+0xdf4>
  811451:	84 c0                	test   %al,%al
  811453:	0f 84 b2 04 00 00    	je     81190b <tcp_input+0xdf4>
          tcp_ack_now(pcb);
  811459:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81145d:	89 1c 24             	mov    %ebx,(%esp)
  811460:	e8 96 9e ff ff       	call   80b2fb <tcp_output>
          pcb->state = CLOSE_WAIT;
  811465:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  81146c:	e9 9a 04 00 00       	jmp    81190b <tcp_input+0xdf4>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  811471:	8b 0d f0 c1 b3 00    	mov    0xb3c1f0,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  811477:	8b 15 f4 c1 b3 00    	mov    0xb3c1f4,%edx
  81147d:	0f b7 31             	movzwl (%ecx),%esi
  811480:	89 74 24 14          	mov    %esi,0x14(%esp)
  811484:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  811488:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  81148c:	8d 4a 0c             	lea    0xc(%edx),%ecx
  81148f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  811493:	83 c2 10             	add    $0x10,%edx
  811496:	89 54 24 08          	mov    %edx,0x8(%esp)
  81149a:	0f b7 15 02 c2 b3 00 	movzwl 0xb3c202,%edx
  8114a1:	03 15 f8 c1 b3 00    	add    0xb3c1f8,%edx
  8114a7:	89 54 24 04          	mov    %edx,0x4(%esp)
  8114ab:	89 04 24             	mov    %eax,(%esp)
  8114ae:	e8 e9 9c ff ff       	call   80b19c <tcp_rst>
  8114b3:	e9 53 04 00 00       	jmp    81190b <tcp_input+0xdf4>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  8114b8:	89 d8                	mov    %ebx,%eax
  8114ba:	e8 e0 e9 ff ff       	call   80fe9f <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  8114bf:	f6 05 00 c2 b3 00 01 	testb  $0x1,0xb3c200
  8114c6:	0f 84 3f 04 00 00    	je     81190b <tcp_input+0xdf4>
  8114cc:	84 c0                	test   %al,%al
  8114ce:	0f 84 37 04 00 00    	je     81190b <tcp_input+0xdf4>
      tcp_ack_now(pcb);
  8114d4:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8114d8:	89 1c 24             	mov    %ebx,(%esp)
  8114db:	e8 1b 9e ff ff       	call   80b2fb <tcp_output>
      pcb->state = CLOSE_WAIT;
  8114e0:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  8114e7:	e9 1f 04 00 00       	jmp    81190b <tcp_input+0xdf4>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  8114ec:	89 d8                	mov    %ebx,%eax
  8114ee:	e8 ac e9 ff ff       	call   80fe9f <tcp_receive>
    if (flags & TCP_FIN) {
  8114f3:	0f b6 05 00 c2 b3 00 	movzbl 0xb3c200,%eax
  8114fa:	a8 01                	test   $0x1,%al
  8114fc:	0f 84 a3 00 00 00    	je     8115a5 <tcp_input+0xa8e>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  811502:	a8 10                	test   $0x10,%al
  811504:	0f 84 81 00 00 00    	je     81158b <tcp_input+0xa74>
  81150a:	8b 43 54             	mov    0x54(%ebx),%eax
  81150d:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  811513:	75 76                	jne    81158b <tcp_input+0xa74>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  811515:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  811519:	89 1c 24             	mov    %ebx,(%esp)
  81151c:	e8 da 9d ff ff       	call   80b2fb <tcp_output>
        tcp_pcb_purge(pcb);
  811521:	89 1c 24             	mov    %ebx,(%esp)
  811524:	e8 3e 75 ff ff       	call   808a67 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  811529:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  81152e:	39 c3                	cmp    %eax,%ebx
  811530:	75 0a                	jne    81153c <tcp_input+0xa25>
  811532:	8b 43 0c             	mov    0xc(%ebx),%eax
  811535:	a3 0c f0 b3 00       	mov    %eax,0xb3f00c
  81153a:	eb 29                	jmp    811565 <tcp_input+0xa4e>
  81153c:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  811541:	eb 19                	jmp    81155c <tcp_input+0xa45>
  811543:	8b 50 0c             	mov    0xc(%eax),%edx
  811546:	85 d2                	test   %edx,%edx
  811548:	74 0c                	je     811556 <tcp_input+0xa3f>
  81154a:	39 d3                	cmp    %edx,%ebx
  81154c:	75 08                	jne    811556 <tcp_input+0xa3f>
  81154e:	8b 53 0c             	mov    0xc(%ebx),%edx
  811551:	89 50 0c             	mov    %edx,0xc(%eax)
  811554:	eb 0f                	jmp    811565 <tcp_input+0xa4e>
  811556:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  81155c:	a1 18 f0 b3 00       	mov    0xb3f018,%eax
  811561:	85 c0                	test   %eax,%eax
  811563:	75 de                	jne    811543 <tcp_input+0xa2c>
  811565:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
        pcb->state = TIME_WAIT;
  81156c:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  811573:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  811578:	89 43 0c             	mov    %eax,0xc(%ebx)
  81157b:	89 1d 20 f0 b3 00    	mov    %ebx,0xb3f020
  811581:	e8 97 39 ff ff       	call   804f1d <tcp_timer_needed>
  811586:	e9 80 03 00 00       	jmp    81190b <tcp_input+0xdf4>
      } else {
        tcp_ack_now(pcb);
  81158b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81158f:	89 1c 24             	mov    %ebx,(%esp)
  811592:	e8 64 9d ff ff       	call   80b2fb <tcp_output>
        pcb->state = CLOSING;
  811597:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  81159e:	66 90                	xchg   %ax,%ax
  8115a0:	e9 66 03 00 00       	jmp    81190b <tcp_input+0xdf4>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  8115a5:	a8 10                	test   $0x10,%al
  8115a7:	0f 84 5e 03 00 00    	je     81190b <tcp_input+0xdf4>
  8115ad:	8b 43 54             	mov    0x54(%ebx),%eax
  8115b0:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  8115b6:	0f 85 4f 03 00 00    	jne    81190b <tcp_input+0xdf4>
      pcb->state = FIN_WAIT_2;
  8115bc:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  8115c3:	e9 43 03 00 00       	jmp    81190b <tcp_input+0xdf4>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  8115c8:	89 d8                	mov    %ebx,%eax
  8115ca:	e8 d0 e8 ff ff       	call   80fe9f <tcp_receive>
    if (flags & TCP_FIN) {
  8115cf:	f6 05 00 c2 b3 00 01 	testb  $0x1,0xb3c200
  8115d6:	0f 84 2f 03 00 00    	je     81190b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  8115dc:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8115e0:	89 1c 24             	mov    %ebx,(%esp)
  8115e3:	e8 13 9d ff ff       	call   80b2fb <tcp_output>
      tcp_pcb_purge(pcb);
  8115e8:	89 1c 24             	mov    %ebx,(%esp)
  8115eb:	e8 77 74 ff ff       	call   808a67 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  8115f0:	8b 15 0c f0 b3 00    	mov    0xb3f00c,%edx
  8115f6:	39 d3                	cmp    %edx,%ebx
  8115f8:	75 0a                	jne    811604 <tcp_input+0xaed>
  8115fa:	8b 43 0c             	mov    0xc(%ebx),%eax
  8115fd:	a3 0c f0 b3 00       	mov    %eax,0xb3f00c
  811602:	eb 2a                	jmp    81162e <tcp_input+0xb17>
  811604:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  81160a:	85 d2                	test   %edx,%edx
  81160c:	74 20                	je     81162e <tcp_input+0xb17>
  81160e:	8b 42 0c             	mov    0xc(%edx),%eax
  811611:	85 c0                	test   %eax,%eax
  811613:	0f 84 dd 02 00 00    	je     8118f6 <tcp_input+0xddf>
  811619:	39 c3                	cmp    %eax,%ebx
  81161b:	75 08                	jne    811625 <tcp_input+0xb0e>
  81161d:	8b 43 0c             	mov    0xc(%ebx),%eax
  811620:	89 42 0c             	mov    %eax,0xc(%edx)
  811623:	eb 09                	jmp    81162e <tcp_input+0xb17>
  811625:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  81162a:	89 c2                	mov    %eax,%edx
  81162c:	eb e0                	jmp    81160e <tcp_input+0xaf7>
  81162e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      pcb->state = TIME_WAIT;
  811635:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81163c:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  811641:	89 43 0c             	mov    %eax,0xc(%ebx)
  811644:	89 1d 20 f0 b3 00    	mov    %ebx,0xb3f020
  81164a:	e8 ce 38 ff ff       	call   804f1d <tcp_timer_needed>
  81164f:	e9 b7 02 00 00       	jmp    81190b <tcp_input+0xdf4>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  811654:	89 d8                	mov    %ebx,%eax
  811656:	e8 44 e8 ff ff       	call   80fe9f <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81165b:	f6 05 00 c2 b3 00 10 	testb  $0x10,0xb3c200
  811662:	0f 84 a3 02 00 00    	je     81190b <tcp_input+0xdf4>
  811668:	8b 43 54             	mov    0x54(%ebx),%eax
  81166b:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  811671:	0f 85 94 02 00 00    	jne    81190b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  811677:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81167b:	89 1c 24             	mov    %ebx,(%esp)
  81167e:	e8 78 9c ff ff       	call   80b2fb <tcp_output>
      tcp_pcb_purge(pcb);
  811683:	89 1c 24             	mov    %ebx,(%esp)
  811686:	e8 dc 73 ff ff       	call   808a67 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  81168b:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  811690:	39 c3                	cmp    %eax,%ebx
  811692:	75 0a                	jne    81169e <tcp_input+0xb87>
  811694:	8b 43 0c             	mov    0xc(%ebx),%eax
  811697:	a3 0c f0 b3 00       	mov    %eax,0xb3f00c
  81169c:	eb 2a                	jmp    8116c8 <tcp_input+0xbb1>
  81169e:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  8116a3:	85 c0                	test   %eax,%eax
  8116a5:	74 21                	je     8116c8 <tcp_input+0xbb1>
  8116a7:	8b 50 0c             	mov    0xc(%eax),%edx
  8116aa:	85 d2                	test   %edx,%edx
  8116ac:	0f 84 4e 02 00 00    	je     811900 <tcp_input+0xde9>
  8116b2:	39 d3                	cmp    %edx,%ebx
  8116b4:	75 08                	jne    8116be <tcp_input+0xba7>
  8116b6:	8b 53 0c             	mov    0xc(%ebx),%edx
  8116b9:	89 50 0c             	mov    %edx,0xc(%eax)
  8116bc:	eb 0a                	jmp    8116c8 <tcp_input+0xbb1>
  8116be:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  8116c4:	89 d0                	mov    %edx,%eax
  8116c6:	eb df                	jmp    8116a7 <tcp_input+0xb90>
  8116c8:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      pcb->state = TIME_WAIT;
  8116cf:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  8116d6:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  8116db:	89 43 0c             	mov    %eax,0xc(%ebx)
  8116de:	89 1d 20 f0 b3 00    	mov    %ebx,0xb3f020
  8116e4:	e8 34 38 ff ff       	call   804f1d <tcp_timer_needed>
  8116e9:	e9 1d 02 00 00       	jmp    81190b <tcp_input+0xdf4>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  8116ee:	89 d8                	mov    %ebx,%eax
  8116f0:	e8 aa e7 ff ff       	call   80fe9f <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  8116f5:	f6 05 00 c2 b3 00 10 	testb  $0x10,0xb3c200
  8116fc:	0f 84 09 02 00 00    	je     81190b <tcp_input+0xdf4>
  811702:	8b 43 54             	mov    0x54(%ebx),%eax
  811705:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  81170b:	0f 85 fa 01 00 00    	jne    81190b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  811711:	c6 05 04 c2 b3 00 10 	movb   $0x10,0xb3c204
  811718:	e9 ee 01 00 00       	jmp    81190b <tcp_input+0xdf4>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  81171d:	c7 05 28 f0 b3 00 00 	movl   $0x0,0xb3f028
  811724:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  811727:	0f b6 05 04 c2 b3 00 	movzbl 0xb3c204,%eax
  81172e:	a8 08                	test   $0x8,%al
  811730:	74 3f                	je     811771 <tcp_input+0xc5a>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  811732:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  811738:	85 c0                	test   %eax,%eax
  81173a:	74 10                	je     81174c <tcp_input+0xc35>
  81173c:	c7 44 24 04 fa ff ff 	movl   $0xfffffffa,0x4(%esp)
  811743:	ff 
  811744:	8b 53 18             	mov    0x18(%ebx),%edx
  811747:	89 14 24             	mov    %edx,(%esp)
  81174a:	ff d0                	call   *%eax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81174c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811750:	c7 04 24 0c f0 b3 00 	movl   $0xb3f00c,(%esp)
  811757:	e8 84 73 ff ff       	call   808ae0 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  81175c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811760:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  811767:	e8 74 5f ff ff       	call   8076e0 <memp_free>
  81176c:	e9 fc 00 00 00       	jmp    81186d <tcp_input+0xd56>
      } else if (recv_flags & TF_CLOSED) {
  811771:	a8 10                	test   $0x10,%al
  811773:	74 25                	je     81179a <tcp_input+0xc83>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  811775:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811779:	c7 04 24 0c f0 b3 00 	movl   $0xb3f00c,(%esp)
  811780:	e8 5b 73 ff ff       	call   808ae0 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  811785:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811789:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  811790:	e8 4b 5f ff ff       	call   8076e0 <memp_free>
  811795:	e9 d3 00 00 00       	jmp    81186d <tcp_input+0xd56>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  81179a:	0f b7 43 6c          	movzwl 0x6c(%ebx),%eax
  81179e:	66 85 c0             	test   %ax,%ax
  8117a1:	74 1f                	je     8117c2 <tcp_input+0xcab>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  8117a3:	8b 93 84 00 00 00    	mov    0x84(%ebx),%edx
  8117a9:	85 d2                	test   %edx,%edx
  8117ab:	74 15                	je     8117c2 <tcp_input+0xcab>
  8117ad:	0f b7 c0             	movzwl %ax,%eax
  8117b0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8117b4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8117b8:	8b 43 18             	mov    0x18(%ebx),%eax
  8117bb:	89 04 24             	mov    %eax,(%esp)
  8117be:	ff d2                	call   *%edx
  8117c0:	eb 05                	jmp    8117c7 <tcp_input+0xcb0>
  8117c2:	b8 00 00 00 00       	mov    $0x0,%eax
        }
      
        if (recv_data != NULL) {
  8117c7:	8b 15 08 c2 b3 00    	mov    0xb3c208,%edx
  8117cd:	85 d2                	test   %edx,%edx
  8117cf:	74 61                	je     811832 <tcp_input+0xd1b>
          if(flags & TCP_PSH) {
  8117d1:	f6 05 00 c2 b3 00 08 	testb  $0x8,0xb3c200
  8117d8:	74 04                	je     8117de <tcp_input+0xcc7>
            recv_data->flags |= PBUF_FLAG_PUSH;
  8117da:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  8117de:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  8117e4:	85 c0                	test   %eax,%eax
  8117e6:	74 24                	je     81180c <tcp_input+0xcf5>
  8117e8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8117ef:	00 
  8117f0:	8b 15 08 c2 b3 00    	mov    0xb3c208,%edx
  8117f6:	89 54 24 08          	mov    %edx,0x8(%esp)
  8117fa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8117fe:	8b 53 18             	mov    0x18(%ebx),%edx
  811801:	89 14 24             	mov    %edx,(%esp)
  811804:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  811806:	84 c0                	test   %al,%al
  811808:	75 1c                	jne    811826 <tcp_input+0xd0f>
  81180a:	eb 26                	jmp    811832 <tcp_input+0xd1b>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81180c:	a1 08 c2 b3 00       	mov    0xb3c208,%eax
  811811:	85 c0                	test   %eax,%eax
  811813:	0f 84 01 01 00 00    	je     81191a <tcp_input+0xe03>
  811819:	89 04 24             	mov    %eax,(%esp)
  81181c:	e8 57 66 ff ff       	call   807e78 <pbuf_free>
  811821:	e9 f4 00 00 00       	jmp    81191a <tcp_input+0xe03>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  811826:	8b 15 08 c2 b3 00    	mov    0xb3c208,%edx
  81182c:	89 93 80 00 00 00    	mov    %edx,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  811832:	f6 05 04 c2 b3 00 20 	testb  $0x20,0xb3c204
  811839:	74 26                	je     811861 <tcp_input+0xd4a>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  81183b:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  811841:	85 c0                	test   %eax,%eax
  811843:	74 20                	je     811865 <tcp_input+0xd4e>
  811845:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  81184c:	00 
  81184d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811854:	00 
  811855:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811859:	8b 53 18             	mov    0x18(%ebx),%edx
  81185c:	89 14 24             	mov    %edx,(%esp)
  81185f:	ff d0                	call   *%eax
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  811861:	84 c0                	test   %al,%al
  811863:	75 08                	jne    81186d <tcp_input+0xd56>
          tcp_output(pcb);
  811865:	89 1c 24             	mov    %ebx,(%esp)
  811868:	e8 8e 9a ff ff       	call   80b2fb <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  81186d:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  811872:	85 c0                	test   %eax,%eax
  811874:	0f 84 aa 00 00 00    	je     811924 <tcp_input+0xe0d>
    {
      pbuf_free(inseg.p);
  81187a:	89 04 24             	mov    %eax,(%esp)
  81187d:	e8 f6 65 ff ff       	call   807e78 <pbuf_free>
      inseg.p = NULL;
  811882:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  811889:	00 00 00 
  81188c:	e9 93 00 00 00       	jmp    811924 <tcp_input+0xe0d>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  811891:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  811896:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81189a:	89 04 24             	mov    %eax,(%esp)
  81189d:	e8 df 93 ff ff       	call   80ac81 <ntohs>
  8118a2:	a8 04                	test   $0x4,%al
  8118a4:	75 46                	jne    8118ec <tcp_input+0xdd5>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  8118a6:	8b 15 f0 c1 b3 00    	mov    0xb3c1f0,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  8118ac:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  8118b1:	0f b7 0a             	movzwl (%edx),%ecx
  8118b4:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  8118b8:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  8118bc:	89 54 24 10          	mov    %edx,0x10(%esp)
  8118c0:	8d 50 0c             	lea    0xc(%eax),%edx
  8118c3:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8118c7:	83 c0 10             	add    $0x10,%eax
  8118ca:	89 44 24 08          	mov    %eax,0x8(%esp)
  8118ce:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  8118d5:	03 05 f8 c1 b3 00    	add    0xb3c1f8,%eax
  8118db:	89 44 24 04          	mov    %eax,0x4(%esp)
  8118df:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  8118e4:	89 04 24             	mov    %eax,(%esp)
  8118e7:	e8 b0 98 ff ff       	call   80b19c <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  8118ec:	89 34 24             	mov    %esi,(%esp)
  8118ef:	e8 84 65 ff ff       	call   807e78 <pbuf_free>
  8118f4:	eb 2e                	jmp    811924 <tcp_input+0xe0d>
    tcp_receive(pcb);
    if (flags & TCP_FIN) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
  8118f6:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  8118fb:	e9 2e fd ff ff       	jmp    81162e <tcp_input+0xb17>
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
  811900:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  811906:	e9 bd fd ff ff       	jmp    8116c8 <tcp_input+0xbb1>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  81190b:	c7 05 28 f0 b3 00 00 	movl   $0x0,0xb3f028
  811912:	00 00 00 
  811915:	e9 0d fe ff ff       	jmp    811727 <tcp_input+0xc10>
  81191a:	b8 00 00 00 00       	mov    $0x0,%eax
  81191f:	e9 0e ff ff ff       	jmp    811832 <tcp_input+0xd1b>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  811924:	83 c4 5c             	add    $0x5c,%esp
  811927:	5b                   	pop    %ebx
  811928:	5e                   	pop    %esi
  811929:	5f                   	pop    %edi
  81192a:	5d                   	pop    %ebp
  81192b:	c3                   	ret    
  81192c:	00 00                	add    %al,(%eax)
	...

00811930 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  811930:	55                   	push   %ebp
  811931:	89 e5                	mov    %esp,%ebp
  811933:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  811936:	b8 00 00 00 00       	mov    $0x0,%eax
  81193b:	85 d2                	test   %edx,%edx
  81193d:	74 02                	je     811941 <raw_bind+0x11>
  81193f:	8b 02                	mov    (%edx),%eax
  811941:	8b 55 08             	mov    0x8(%ebp),%edx
  811944:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  811946:	b8 00 00 00 00       	mov    $0x0,%eax
  81194b:	5d                   	pop    %ebp
  81194c:	c3                   	ret    

0081194d <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81194d:	55                   	push   %ebp
  81194e:	89 e5                	mov    %esp,%ebp
  811950:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  811953:	b8 00 00 00 00       	mov    $0x0,%eax
  811958:	85 d2                	test   %edx,%edx
  81195a:	74 02                	je     81195e <raw_connect+0x11>
  81195c:	8b 02                	mov    (%edx),%eax
  81195e:	8b 55 08             	mov    0x8(%ebp),%edx
  811961:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  811964:	b8 00 00 00 00       	mov    $0x0,%eax
  811969:	5d                   	pop    %ebp
  81196a:	c3                   	ret    

0081196b <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  81196b:	55                   	push   %ebp
  81196c:	89 e5                	mov    %esp,%ebp
  81196e:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  811971:	8b 55 0c             	mov    0xc(%ebp),%edx
  811974:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  811977:	8b 55 10             	mov    0x10(%ebp),%edx
  81197a:	89 50 18             	mov    %edx,0x18(%eax)
}
  81197d:	5d                   	pop    %ebp
  81197e:	c3                   	ret    

0081197f <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  81197f:	55                   	push   %ebp
  811980:	89 e5                	mov    %esp,%ebp
  811982:	83 ec 18             	sub    $0x18,%esp
  811985:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  811988:	89 75 fc             	mov    %esi,-0x4(%ebp)
  81198b:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  81198f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811996:	e8 89 5d ff ff       	call   807724 <memp_malloc>
  81199b:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  81199d:	85 c0                	test   %eax,%eax
  81199f:	74 2f                	je     8119d0 <raw_new+0x51>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  8119a1:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  8119a8:	00 
  8119a9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8119b0:	00 
  8119b1:	89 04 24             	mov    %eax,(%esp)
  8119b4:	e8 9d fb fe ff       	call   801556 <memset>
    pcb->protocol = proto;
  8119b9:	89 f0                	mov    %esi,%eax
  8119bb:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  8119be:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  8119c2:	a1 0c c2 b3 00       	mov    0xb3c20c,%eax
  8119c7:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  8119ca:	89 1d 0c c2 b3 00    	mov    %ebx,0xb3c20c
  }
  return pcb;
}
  8119d0:	89 d8                	mov    %ebx,%eax
  8119d2:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8119d5:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8119d8:	89 ec                	mov    %ebp,%esp
  8119da:	5d                   	pop    %ebp
  8119db:	c3                   	ret    

008119dc <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  8119dc:	55                   	push   %ebp
  8119dd:	89 e5                	mov    %esp,%ebp
  8119df:	83 ec 18             	sub    $0x18,%esp
  8119e2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  8119e5:	8b 15 0c c2 b3 00    	mov    0xb3c20c,%edx
  8119eb:	39 ca                	cmp    %ecx,%edx
  8119ed:	74 06                	je     8119f5 <raw_remove+0x19>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8119ef:	85 d2                	test   %edx,%edx
  8119f1:	75 0e                	jne    811a01 <raw_remove+0x25>
  8119f3:	eb 21                	jmp    811a16 <raw_remove+0x3a>
{
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  8119f5:	8b 42 0c             	mov    0xc(%edx),%eax
  8119f8:	a3 0c c2 b3 00       	mov    %eax,0xb3c20c
  8119fd:	eb 17                	jmp    811a16 <raw_remove+0x3a>
  8119ff:	89 c2                	mov    %eax,%edx
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  811a01:	8b 42 0c             	mov    0xc(%edx),%eax
  811a04:	85 c0                	test   %eax,%eax
  811a06:	74 0e                	je     811a16 <raw_remove+0x3a>
  811a08:	39 c1                	cmp    %eax,%ecx
  811a0a:	75 f3                	jne    8119ff <raw_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  811a0c:	8b 41 0c             	mov    0xc(%ecx),%eax
  811a0f:	89 42 0c             	mov    %eax,0xc(%edx)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  811a12:	85 c0                	test   %eax,%eax
  811a14:	75 e9                	jne    8119ff <raw_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  811a16:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  811a1a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811a21:	e8 ba 5c ff ff       	call   8076e0 <memp_free>
}
  811a26:	c9                   	leave  
  811a27:	c3                   	ret    

00811a28 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  811a28:	55                   	push   %ebp
  811a29:	89 e5                	mov    %esp,%ebp
  811a2b:	57                   	push   %edi
  811a2c:	56                   	push   %esi
  811a2d:	53                   	push   %ebx
  811a2e:	83 ec 3c             	sub    $0x3c,%esp
  811a31:	8b 5d 08             	mov    0x8(%ebp),%ebx
  811a34:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  811a37:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  811a3e:	00 
  811a3f:	89 3c 24             	mov    %edi,(%esp)
  811a42:	e8 bc 60 ff ff       	call   807b03 <pbuf_header>
  811a47:	84 c0                	test   %al,%al
  811a49:	74 38                	je     811a83 <raw_sendto+0x5b>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  811a4b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811a52:	00 
  811a53:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811a5a:	00 
  811a5b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811a62:	e8 cc 66 ff ff       	call   808133 <pbuf_alloc>
  811a67:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  811a69:	c6 45 e7 ff          	movb   $0xff,-0x19(%ebp)
  811a6d:	85 c0                	test   %eax,%eax
  811a6f:	0f 84 b1 00 00 00    	je     811b26 <raw_sendto+0xfe>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  811a75:	89 7c 24 04          	mov    %edi,0x4(%esp)
  811a79:	89 04 24             	mov    %eax,(%esp)
  811a7c:	e8 5b 60 ff ff       	call   807adc <pbuf_chain>
  811a81:	eb 32                	jmp    811ab5 <raw_sendto+0x8d>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  811a83:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  811a8a:	ff 
  811a8b:	89 3c 24             	mov    %edi,(%esp)
  811a8e:	e8 70 60 ff ff       	call   807b03 <pbuf_header>
  811a93:	84 c0                	test   %al,%al
  811a95:	74 1c                	je     811ab3 <raw_sendto+0x8b>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  811a97:	c7 44 24 08 ac 4e 81 	movl   $0x814eac,0x8(%esp)
  811a9e:	00 
  811a9f:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  811aa6:	00 
  811aa7:	c7 04 24 d2 4e 81 00 	movl   $0x814ed2,(%esp)
  811aae:	e8 35 ef fe ff       	call   8009e8 <_panic>
  811ab3:	89 fe                	mov    %edi,%esi
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  811ab5:	8b 45 10             	mov    0x10(%ebp),%eax
  811ab8:	89 04 24             	mov    %eax,(%esp)
  811abb:	e8 a1 7f ff ff       	call   809a61 <ip_route>
  811ac0:	85 c0                	test   %eax,%eax
  811ac2:	75 16                	jne    811ada <raw_sendto+0xb2>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  811ac4:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  811ac8:	39 fe                	cmp    %edi,%esi
  811aca:	74 5a                	je     811b26 <raw_sendto+0xfe>
      pbuf_free(q);
  811acc:	89 34 24             	mov    %esi,(%esp)
  811acf:	e8 a4 63 ff ff       	call   807e78 <pbuf_free>
  811ad4:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  811ad8:	eb 4c                	jmp    811b26 <raw_sendto+0xfe>
    }
    return ERR_RTE;
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  811ada:	89 da                	mov    %ebx,%edx
  811adc:	85 db                	test   %ebx,%ebx
  811ade:	74 05                	je     811ae5 <raw_sendto+0xbd>
  811ae0:	83 3b 00             	cmpl   $0x0,(%ebx)
  811ae3:	75 03                	jne    811ae8 <raw_sendto+0xc0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  811ae5:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  811ae8:	89 44 24 18          	mov    %eax,0x18(%esp)
  811aec:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  811af0:	89 44 24 14          	mov    %eax,0x14(%esp)
  811af4:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  811af8:	89 44 24 10          	mov    %eax,0x10(%esp)
  811afc:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  811b00:	89 44 24 0c          	mov    %eax,0xc(%esp)
  811b04:	8b 45 10             	mov    0x10(%ebp),%eax
  811b07:	89 44 24 08          	mov    %eax,0x8(%esp)
  811b0b:	89 54 24 04          	mov    %edx,0x4(%esp)
  811b0f:	89 34 24             	mov    %esi,(%esp)
  811b12:	e8 99 7d ff ff       	call   8098b0 <ip_output_if>
  811b17:	88 45 e7             	mov    %al,-0x19(%ebp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  811b1a:	39 fe                	cmp    %edi,%esi
  811b1c:	74 08                	je     811b26 <raw_sendto+0xfe>
    /* free the header */
    pbuf_free(q);
  811b1e:	89 34 24             	mov    %esi,(%esp)
  811b21:	e8 52 63 ff ff       	call   807e78 <pbuf_free>
  }
  return err;
}
  811b26:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  811b2a:	83 c4 3c             	add    $0x3c,%esp
  811b2d:	5b                   	pop    %ebx
  811b2e:	5e                   	pop    %esi
  811b2f:	5f                   	pop    %edi
  811b30:	5d                   	pop    %ebp
  811b31:	c3                   	ret    

00811b32 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  811b32:	55                   	push   %ebp
  811b33:	89 e5                	mov    %esp,%ebp
  811b35:	83 ec 18             	sub    $0x18,%esp
  811b38:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  811b3b:	8d 50 04             	lea    0x4(%eax),%edx
  811b3e:	89 54 24 08          	mov    %edx,0x8(%esp)
  811b42:	8b 55 0c             	mov    0xc(%ebp),%edx
  811b45:	89 54 24 04          	mov    %edx,0x4(%esp)
  811b49:	89 04 24             	mov    %eax,(%esp)
  811b4c:	e8 d7 fe ff ff       	call   811a28 <raw_sendto>
}
  811b51:	c9                   	leave  
  811b52:	c3                   	ret    

00811b53 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  811b53:	55                   	push   %ebp
  811b54:	89 e5                	mov    %esp,%ebp
  811b56:	57                   	push   %edi
  811b57:	56                   	push   %esi
  811b58:	53                   	push   %ebx
  811b59:	83 ec 2c             	sub    $0x2c,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  811b5c:	8b 45 08             	mov    0x8(%ebp),%eax
  811b5f:	8b 70 04             	mov    0x4(%eax),%esi
  proto = IPH_PROTO(iphdr);
  811b62:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  811b66:	89 04 24             	mov    %eax,(%esp)
  811b69:	e8 13 91 ff ff       	call   80ac81 <ntohs>
  811b6e:	66 25 ff 00          	and    $0xff,%ax

  prev = NULL;
  pcb = raw_pcbs;
  811b72:	8b 1d 0c c2 b3 00    	mov    0xb3c20c,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  811b78:	85 db                	test   %ebx,%ebx
  811b7a:	74 6c                	je     811be8 <raw_input+0x95>
    if (pcb->protocol == proto) {
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  811b7c:	83 c6 0c             	add    $0xc,%esi
  811b7f:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  811b82:	be 00 00 00 00       	mov    $0x0,%esi
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  811b87:	0f bf f8             	movswl %ax,%edi
  811b8a:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  811b8e:	39 f8                	cmp    %edi,%eax
  811b90:	75 49                	jne    811bdb <raw_input+0x88>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  811b92:	8b 43 14             	mov    0x14(%ebx),%eax
  811b95:	85 c0                	test   %eax,%eax
  811b97:	74 42                	je     811bdb <raw_input+0x88>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  811b99:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  811b9c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  811ba0:	8b 55 08             	mov    0x8(%ebp),%edx
  811ba3:	89 54 24 08          	mov    %edx,0x8(%esp)
  811ba7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811bab:	8b 53 18             	mov    0x18(%ebx),%edx
  811bae:	89 14 24             	mov    %edx,(%esp)
  811bb1:	ff d0                	call   *%eax
  811bb3:	84 c0                	test   %al,%al
  811bb5:	74 24                	je     811bdb <raw_input+0x88>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  811bb7:	b8 01 00 00 00       	mov    $0x1,%eax
  811bbc:	85 f6                	test   %esi,%esi
  811bbe:	74 2d                	je     811bed <raw_input+0x9a>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  811bc0:	8b 43 0c             	mov    0xc(%ebx),%eax
  811bc3:	89 46 0c             	mov    %eax,0xc(%esi)
            pcb->next = raw_pcbs;
  811bc6:	a1 0c c2 b3 00       	mov    0xb3c20c,%eax
  811bcb:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  811bce:	89 1d 0c c2 b3 00    	mov    %ebx,0xb3c20c
  811bd4:	b8 01 00 00 00       	mov    $0x1,%eax
  811bd9:	eb 12                	jmp    811bed <raw_input+0x9a>
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  811bdb:	8b 43 0c             	mov    0xc(%ebx),%eax

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  811bde:	85 c0                	test   %eax,%eax
  811be0:	74 06                	je     811be8 <raw_input+0x95>
  811be2:	89 de                	mov    %ebx,%esi
  811be4:	89 c3                	mov    %eax,%ebx
  811be6:	eb a2                	jmp    811b8a <raw_input+0x37>
  811be8:	b8 00 00 00 00       	mov    $0x0,%eax
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  811bed:	83 c4 2c             	add    $0x2c,%esp
  811bf0:	5b                   	pop    %ebx
  811bf1:	5e                   	pop    %esi
  811bf2:	5f                   	pop    %edi
  811bf3:	5d                   	pop    %ebp
  811bf4:	c3                   	ret    
	...

00811c00 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  811c00:	55                   	push   %ebp
  811c01:	89 e5                	mov    %esp,%ebp
  811c03:	57                   	push   %edi
  811c04:	56                   	push   %esi
  811c05:	53                   	push   %ebx
  811c06:	83 ec 3c             	sub    $0x3c,%esp
  811c09:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  811c0c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811c13:	00 
  811c14:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  811c1b:	00 
  811c1c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811c23:	e8 0b 65 ff ff       	call   808133 <pbuf_alloc>
  811c28:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  811c2a:	85 c0                	test   %eax,%eax
  811c2c:	0f 84 d8 00 00 00    	je     811d0a <icmp_time_exceeded+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  811c32:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  811c37:	77 1c                	ja     811c55 <icmp_time_exceeded+0x55>
  811c39:	c7 44 24 08 e8 4e 81 	movl   $0x814ee8,0x8(%esp)
  811c40:	00 
  811c41:	c7 44 24 04 1e 01 00 	movl   $0x11e,0x4(%esp)
  811c48:	00 
  811c49:	c7 04 24 dc 4f 81 00 	movl   $0x814fdc,(%esp)
  811c50:	e8 93 ed fe ff       	call   8009e8 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  811c55:	8b 47 04             	mov    0x4(%edi),%eax
  811c58:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  811c5b:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  811c5e:	0f b7 06             	movzwl (%esi),%eax
  811c61:	89 04 24             	mov    %eax,(%esp)
  811c64:	e8 18 90 ff ff       	call   80ac81 <ntohs>
  811c69:	0f b6 c0             	movzbl %al,%eax
  811c6c:	80 cc 0b             	or     $0xb,%ah
  811c6f:	89 04 24             	mov    %eax,(%esp)
  811c72:	e8 fd 8f ff ff       	call   80ac74 <htons>
  811c77:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  811c7a:	0f b7 c0             	movzwl %ax,%eax
  811c7d:	89 04 24             	mov    %eax,(%esp)
  811c80:	e8 fc 8f ff ff       	call   80ac81 <ntohs>
  811c85:	b0 00                	mov    $0x0,%al
  811c87:	66 0b 45 0c          	or     0xc(%ebp),%ax
  811c8b:	0f b7 c0             	movzwl %ax,%eax
  811c8e:	89 04 24             	mov    %eax,(%esp)
  811c91:	e8 de 8f ff ff       	call   80ac74 <htons>
  811c96:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  811c99:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  811ca0:	00 
  811ca1:	8b 47 04             	mov    0x4(%edi),%eax
  811ca4:	89 44 24 04          	mov    %eax,0x4(%esp)
  811ca8:	8b 43 04             	mov    0x4(%ebx),%eax
  811cab:	83 c0 08             	add    $0x8,%eax
  811cae:	89 04 24             	mov    %eax,(%esp)
  811cb1:	e8 7b f9 fe ff       	call   801631 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  811cb6:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  811cbc:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  811cc0:	89 44 24 04          	mov    %eax,0x4(%esp)
  811cc4:	89 34 24             	mov    %esi,(%esp)
  811cc7:	e8 8e 8c ff ff       	call   80a95a <inet_chksum>
  811ccc:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  811cd0:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  811cd7:	00 
  811cd8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  811cdf:	00 
  811ce0:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811ce7:	00 
  811ce8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  811ceb:	83 c0 0c             	add    $0xc,%eax
  811cee:	89 44 24 08          	mov    %eax,0x8(%esp)
  811cf2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811cf9:	00 
  811cfa:	89 1c 24             	mov    %ebx,(%esp)
  811cfd:	e8 bb 7d ff ff       	call   809abd <ip_output>
  pbuf_free(q);
  811d02:	89 1c 24             	mov    %ebx,(%esp)
  811d05:	e8 6e 61 ff ff       	call   807e78 <pbuf_free>
}
  811d0a:	83 c4 3c             	add    $0x3c,%esp
  811d0d:	5b                   	pop    %ebx
  811d0e:	5e                   	pop    %esi
  811d0f:	5f                   	pop    %edi
  811d10:	5d                   	pop    %ebp
  811d11:	c3                   	ret    

00811d12 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  811d12:	55                   	push   %ebp
  811d13:	89 e5                	mov    %esp,%ebp
  811d15:	57                   	push   %edi
  811d16:	56                   	push   %esi
  811d17:	53                   	push   %ebx
  811d18:	83 ec 3c             	sub    $0x3c,%esp
  811d1b:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  811d1e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811d25:	00 
  811d26:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  811d2d:	00 
  811d2e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811d35:	e8 f9 63 ff ff       	call   808133 <pbuf_alloc>
  811d3a:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  811d3c:	85 c0                	test   %eax,%eax
  811d3e:	0f 84 d8 00 00 00    	je     811e1c <icmp_dest_unreach+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  811d44:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  811d49:	77 1c                	ja     811d67 <icmp_dest_unreach+0x55>
  811d4b:	c7 44 24 08 e8 4e 81 	movl   $0x814ee8,0x8(%esp)
  811d52:	00 
  811d53:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
  811d5a:	00 
  811d5b:	c7 04 24 dc 4f 81 00 	movl   $0x814fdc,(%esp)
  811d62:	e8 81 ec fe ff       	call   8009e8 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  811d67:	8b 47 04             	mov    0x4(%edi),%eax
  811d6a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  idur = q->payload;
  811d6d:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  811d70:	0f b7 06             	movzwl (%esi),%eax
  811d73:	89 04 24             	mov    %eax,(%esp)
  811d76:	e8 06 8f ff ff       	call   80ac81 <ntohs>
  811d7b:	0f b6 c0             	movzbl %al,%eax
  811d7e:	80 cc 03             	or     $0x3,%ah
  811d81:	89 04 24             	mov    %eax,(%esp)
  811d84:	e8 eb 8e ff ff       	call   80ac74 <htons>
  811d89:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  811d8c:	0f b7 c0             	movzwl %ax,%eax
  811d8f:	89 04 24             	mov    %eax,(%esp)
  811d92:	e8 ea 8e ff ff       	call   80ac81 <ntohs>
  811d97:	b0 00                	mov    $0x0,%al
  811d99:	66 0b 45 0c          	or     0xc(%ebp),%ax
  811d9d:	0f b7 c0             	movzwl %ax,%eax
  811da0:	89 04 24             	mov    %eax,(%esp)
  811da3:	e8 cc 8e ff ff       	call   80ac74 <htons>
  811da8:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  811dab:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  811db2:	00 
  811db3:	8b 47 04             	mov    0x4(%edi),%eax
  811db6:	89 44 24 04          	mov    %eax,0x4(%esp)
  811dba:	8b 43 04             	mov    0x4(%ebx),%eax
  811dbd:	83 c0 08             	add    $0x8,%eax
  811dc0:	89 04 24             	mov    %eax,(%esp)
  811dc3:	e8 69 f8 fe ff       	call   801631 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  811dc8:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  811dce:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  811dd2:	89 44 24 04          	mov    %eax,0x4(%esp)
  811dd6:	89 34 24             	mov    %esi,(%esp)
  811dd9:	e8 7c 8b ff ff       	call   80a95a <inet_chksum>
  811dde:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  811de2:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  811de9:	00 
  811dea:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  811df1:	00 
  811df2:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811df9:	00 
  811dfa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  811dfd:	83 c0 0c             	add    $0xc,%eax
  811e00:	89 44 24 08          	mov    %eax,0x8(%esp)
  811e04:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811e0b:	00 
  811e0c:	89 1c 24             	mov    %ebx,(%esp)
  811e0f:	e8 a9 7c ff ff       	call   809abd <ip_output>
  pbuf_free(q);
  811e14:	89 1c 24             	mov    %ebx,(%esp)
  811e17:	e8 5c 60 ff ff       	call   807e78 <pbuf_free>
}
  811e1c:	83 c4 3c             	add    $0x3c,%esp
  811e1f:	5b                   	pop    %ebx
  811e20:	5e                   	pop    %esi
  811e21:	5f                   	pop    %edi
  811e22:	5d                   	pop    %ebp
  811e23:	c3                   	ret    

00811e24 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  811e24:	55                   	push   %ebp
  811e25:	89 e5                	mov    %esp,%ebp
  811e27:	83 ec 48             	sub    $0x48,%esp
  811e2a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  811e2d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  811e30:	89 7d fc             	mov    %edi,-0x4(%ebp)
  811e33:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  811e36:	8b 73 04             	mov    0x4(%ebx),%esi
  hlen = IPH_HL(iphdr) * 4;
  811e39:	0f b7 06             	movzwl (%esi),%eax
  811e3c:	89 04 24             	mov    %eax,(%esp)
  811e3f:	e8 3d 8e ff ff       	call   80ac81 <ntohs>
  811e44:	66 c1 e8 06          	shr    $0x6,%ax
  811e48:	83 e0 3c             	and    $0x3c,%eax
  811e4b:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  811e4f:	89 c7                	mov    %eax,%edi
  811e51:	f7 df                	neg    %edi
  811e53:	0f bf ff             	movswl %di,%edi
  811e56:	89 7c 24 04          	mov    %edi,0x4(%esp)
  811e5a:	89 1c 24             	mov    %ebx,(%esp)
  811e5d:	e8 a1 5c ff ff       	call   807b03 <pbuf_header>
  811e62:	84 c0                	test   %al,%al
  811e64:	0f 85 ee 02 00 00    	jne    812158 <icmp_input+0x334>
  811e6a:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  811e6f:	0f 86 e3 02 00 00    	jbe    812158 <icmp_input+0x334>

  type = *((u8_t *)p->payload);
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  811e75:	8b 43 04             	mov    0x4(%ebx),%eax
  811e78:	80 38 08             	cmpb   $0x8,(%eax)
  811e7b:	0f 85 cd 02 00 00    	jne    81214e <icmp_input+0x32a>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  811e81:	8b 45 0c             	mov    0xc(%ebp),%eax
  811e84:	89 44 24 04          	mov    %eax,0x4(%esp)
  811e88:	8d 46 10             	lea    0x10(%esi),%eax
  811e8b:	89 04 24             	mov    %eax,(%esp)
  811e8e:	e8 d5 79 ff ff       	call   809868 <ip_addr_isbroadcast>
  811e93:	84 c0                	test   %al,%al
  811e95:	75 2b                	jne    811ec2 <icmp_input+0x9e>
  811e97:	8b 56 10             	mov    0x10(%esi),%edx
  811e9a:	89 55 dc             	mov    %edx,-0x24(%ebp)
  811e9d:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  811ea4:	e8 11 90 ff ff       	call   80aeba <ntohl>
  811ea9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  811eac:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  811eb3:	e8 02 90 ff ff       	call   80aeba <ntohl>
  811eb8:	8b 55 e0             	mov    -0x20(%ebp),%edx
  811ebb:	23 55 dc             	and    -0x24(%ebp),%edx
  811ebe:	39 c2                	cmp    %eax,%edx
  811ec0:	75 0d                	jne    811ecf <icmp_input+0xab>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  811ec2:	89 1c 24             	mov    %ebx,(%esp)
  811ec5:	e8 ae 5f ff ff       	call   807e78 <pbuf_free>
      return;
  811eca:	e9 9b 02 00 00       	jmp    81216a <icmp_input+0x346>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  811ecf:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  811ed4:	0f 86 7e 02 00 00    	jbe    812158 <icmp_input+0x334>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  811eda:	89 1c 24             	mov    %ebx,(%esp)
  811edd:	8d 76 00             	lea    0x0(%esi),%esi
  811ee0:	e8 f0 89 ff ff       	call   80a8d5 <inet_chksum_pbuf>
  811ee5:	66 85 c0             	test   %ax,%ax
  811ee8:	74 0d                	je     811ef7 <icmp_input+0xd3>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  811eea:	89 1c 24             	mov    %ebx,(%esp)
  811eed:	e8 86 5f ff ff       	call   807e78 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  811ef2:	e9 73 02 00 00       	jmp    81216a <icmp_input+0x346>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  811ef7:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  811efe:	00 
  811eff:	89 1c 24             	mov    %ebx,(%esp)
  811f02:	e8 fc 5b ff ff       	call   807b03 <pbuf_header>
  811f07:	84 c0                	test   %al,%al
  811f09:	0f 84 f0 00 00 00    	je     811fff <icmp_input+0x1db>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  811f0f:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  811f13:	89 44 24 04          	mov    %eax,0x4(%esp)
  811f17:	89 1c 24             	mov    %ebx,(%esp)
  811f1a:	e8 e4 5b ff ff       	call   807b03 <pbuf_header>
  811f1f:	84 c0                	test   %al,%al
  811f21:	74 1c                	je     811f3f <icmp_input+0x11b>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  811f23:	c7 44 24 08 14 4f 81 	movl   $0x814f14,0x8(%esp)
  811f2a:	00 
  811f2b:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  811f32:	00 
  811f33:	c7 04 24 dc 4f 81 00 	movl   $0x814fdc,(%esp)
  811f3a:	e8 a9 ea fe ff       	call   8009e8 <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  811f3f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811f46:	00 
  811f47:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  811f4b:	89 44 24 04          	mov    %eax,0x4(%esp)
  811f4f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  811f56:	e8 d8 61 ff ff       	call   808133 <pbuf_alloc>
  811f5b:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  811f5e:	85 c0                	test   %eax,%eax
  811f60:	0f 84 fc 01 00 00    	je     812162 <icmp_input+0x33e>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  811f66:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  811f6a:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  811f6e:	83 c0 08             	add    $0x8,%eax
  811f71:	39 c2                	cmp    %eax,%edx
  811f73:	73 1c                	jae    811f91 <icmp_input+0x16d>
  811f75:	c7 44 24 08 48 4f 81 	movl   $0x814f48,0x8(%esp)
  811f7c:	00 
  811f7d:	c7 44 24 04 85 00 00 	movl   $0x85,0x4(%esp)
  811f84:	00 
  811f85:	c7 04 24 dc 4f 81 00 	movl   $0x814fdc,(%esp)
  811f8c:	e8 57 ea fe ff       	call   8009e8 <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  811f91:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811f95:	8b 45 e0             	mov    -0x20(%ebp),%eax
  811f98:	89 04 24             	mov    %eax,(%esp)
  811f9b:	e8 25 5d ff ff       	call   807cc5 <pbuf_copy>
  811fa0:	84 c0                	test   %al,%al
  811fa2:	74 1c                	je     811fc0 <icmp_input+0x19c>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  811fa4:	c7 44 24 08 80 4f 81 	movl   $0x814f80,0x8(%esp)
  811fab:	00 
  811fac:	c7 44 24 04 88 00 00 	movl   $0x88,0x4(%esp)
  811fb3:	00 
  811fb4:	c7 04 24 dc 4f 81 00 	movl   $0x814fdc,(%esp)
  811fbb:	e8 28 ea fe ff       	call   8009e8 <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  811fc0:	8b 55 e0             	mov    -0x20(%ebp),%edx
  811fc3:	8b 72 04             	mov    0x4(%edx),%esi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  811fc6:	89 7c 24 04          	mov    %edi,0x4(%esp)
  811fca:	89 14 24             	mov    %edx,(%esp)
  811fcd:	e8 31 5b ff ff       	call   807b03 <pbuf_header>
  811fd2:	84 c0                	test   %al,%al
  811fd4:	74 1c                	je     811ff2 <icmp_input+0x1ce>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  811fd6:	c7 44 24 08 a8 4f 81 	movl   $0x814fa8,0x8(%esp)
  811fdd:	00 
  811fde:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  811fe5:	00 
  811fe6:	c7 04 24 dc 4f 81 00 	movl   $0x814fdc,(%esp)
  811fed:	e8 f6 e9 fe ff       	call   8009e8 <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  811ff2:	89 1c 24             	mov    %ebx,(%esp)
  811ff5:	e8 7e 5e ff ff       	call   807e78 <pbuf_free>
  811ffa:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  811ffd:	eb 30                	jmp    81202f <icmp_input+0x20b>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  811fff:	c7 44 24 04 de ff ff 	movl   $0xffffffde,0x4(%esp)
  812006:	ff 
  812007:	89 1c 24             	mov    %ebx,(%esp)
  81200a:	e8 f4 5a ff ff       	call   807b03 <pbuf_header>
  81200f:	84 c0                	test   %al,%al
  812011:	74 1c                	je     81202f <icmp_input+0x20b>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  812013:	c7 44 24 08 a8 4f 81 	movl   $0x814fa8,0x8(%esp)
  81201a:	00 
  81201b:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  812022:	00 
  812023:	c7 04 24 dc 4f 81 00 	movl   $0x814fdc,(%esp)
  81202a:	e8 b9 e9 fe ff       	call   8009e8 <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  81202f:	8b 7b 04             	mov    0x4(%ebx),%edi
    tmpaddr.addr = iphdr->src.addr;
  812032:	8b 46 0c             	mov    0xc(%esi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  812035:	8b 56 10             	mov    0x10(%esi),%edx
  812038:	89 56 0c             	mov    %edx,0xc(%esi)
    iphdr->dest.addr = tmpaddr.addr;
  81203b:	89 46 10             	mov    %eax,0x10(%esi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  81203e:	0f b7 07             	movzwl (%edi),%eax
  812041:	89 04 24             	mov    %eax,(%esp)
  812044:	e8 38 8c ff ff       	call   80ac81 <ntohs>
  812049:	0f b6 c0             	movzbl %al,%eax
  81204c:	89 04 24             	mov    %eax,(%esp)
  81204f:	e8 20 8c ff ff       	call   80ac74 <htons>
  812054:	66 89 07             	mov    %ax,(%edi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  812057:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  81205b:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  81205f:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  812066:	e8 09 8c ff ff       	call   80ac74 <htons>
  81206b:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  81206f:	72 22                	jb     812093 <icmp_input+0x26f>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  812071:	0f b7 57 02          	movzwl 0x2(%edi),%edx
  812075:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
  812079:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  812080:	e8 ef 8b ff ff       	call   80ac74 <htons>
  812085:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
  812089:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  81208d:	66 89 47 02          	mov    %ax,0x2(%edi)
  812091:	eb 1c                	jmp    8120af <icmp_input+0x28b>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  812093:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  812097:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  81209b:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  8120a2:	e8 cd 8b ff ff       	call   80ac74 <htons>
  8120a7:	66 03 45 e0          	add    -0x20(%ebp),%ax
  8120ab:	66 89 47 02          	mov    %ax,0x2(%edi)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  8120af:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8120b3:	89 04 24             	mov    %eax,(%esp)
  8120b6:	e8 c6 8b ff ff       	call   80ac81 <ntohs>
  8120bb:	66 0d 00 ff          	or     $0xff00,%ax
  8120bf:	0f b7 c0             	movzwl %ax,%eax
  8120c2:	89 04 24             	mov    %eax,(%esp)
  8120c5:	e8 aa 8b ff ff       	call   80ac74 <htons>
  8120ca:	66 89 46 08          	mov    %ax,0x8(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  8120ce:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8120d4:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8120db:	00 
  8120dc:	89 34 24             	mov    %esi,(%esp)
  8120df:	e8 76 88 ff ff       	call   80a95a <inet_chksum>
  8120e4:	66 89 46 0a          	mov    %ax,0xa(%esi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  8120e8:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  8120ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  8120f0:	89 1c 24             	mov    %ebx,(%esp)
  8120f3:	e8 0b 5a ff ff       	call   807b03 <pbuf_header>
  8120f8:	84 c0                	test   %al,%al
  8120fa:	74 1c                	je     812118 <icmp_input+0x2f4>
      LWIP_ASSERT("Can't move over header in packet", 0);
  8120fc:	c7 44 24 08 ec 3f 81 	movl   $0x813fec,0x8(%esp)
  812103:	00 
  812104:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  81210b:	00 
  81210c:	c7 04 24 dc 4f 81 00 	movl   $0x814fdc,(%esp)
  812113:	e8 d0 e8 fe ff       	call   8009e8 <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  812118:	8b 55 0c             	mov    0xc(%ebp),%edx
  81211b:	89 54 24 18          	mov    %edx,0x18(%esp)
  81211f:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  812126:	00 
  812127:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  81212e:	00 
  81212f:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  812136:	00 
  812137:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81213e:	00 
  81213f:	83 c6 0c             	add    $0xc,%esi
  812142:	89 74 24 04          	mov    %esi,0x4(%esp)
  812146:	89 1c 24             	mov    %ebx,(%esp)
  812149:	e8 62 77 ff ff       	call   8098b0 <ip_output_if>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  81214e:	89 1c 24             	mov    %ebx,(%esp)
  812151:	e8 22 5d ff ff       	call   807e78 <pbuf_free>
  return;
  812156:	eb 12                	jmp    81216a <icmp_input+0x346>
lenerr:
  pbuf_free(p);
  812158:	89 1c 24             	mov    %ebx,(%esp)
  81215b:	e8 18 5d ff ff       	call   807e78 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  812160:	eb 08                	jmp    81216a <icmp_input+0x346>
memerr:
  pbuf_free(p);
  812162:	89 1c 24             	mov    %ebx,(%esp)
  812165:	e8 0e 5d ff ff       	call   807e78 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  81216a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  81216d:	8b 75 f8             	mov    -0x8(%ebp),%esi
  812170:	8b 7d fc             	mov    -0x4(%ebp),%edi
  812173:	89 ec                	mov    %ebp,%esp
  812175:	5d                   	pop    %ebp
  812176:	c3                   	ret    
	...

00812180 <__udivdi3>:
  812180:	55                   	push   %ebp
  812181:	89 e5                	mov    %esp,%ebp
  812183:	57                   	push   %edi
  812184:	56                   	push   %esi
  812185:	83 ec 10             	sub    $0x10,%esp
  812188:	8b 45 14             	mov    0x14(%ebp),%eax
  81218b:	8b 55 08             	mov    0x8(%ebp),%edx
  81218e:	8b 75 10             	mov    0x10(%ebp),%esi
  812191:	8b 7d 0c             	mov    0xc(%ebp),%edi
  812194:	85 c0                	test   %eax,%eax
  812196:	89 55 f0             	mov    %edx,-0x10(%ebp)
  812199:	75 35                	jne    8121d0 <__udivdi3+0x50>
  81219b:	39 fe                	cmp    %edi,%esi
  81219d:	77 61                	ja     812200 <__udivdi3+0x80>
  81219f:	85 f6                	test   %esi,%esi
  8121a1:	75 0b                	jne    8121ae <__udivdi3+0x2e>
  8121a3:	b8 01 00 00 00       	mov    $0x1,%eax
  8121a8:	31 d2                	xor    %edx,%edx
  8121aa:	f7 f6                	div    %esi
  8121ac:	89 c6                	mov    %eax,%esi
  8121ae:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  8121b1:	31 d2                	xor    %edx,%edx
  8121b3:	89 f8                	mov    %edi,%eax
  8121b5:	f7 f6                	div    %esi
  8121b7:	89 c7                	mov    %eax,%edi
  8121b9:	89 c8                	mov    %ecx,%eax
  8121bb:	f7 f6                	div    %esi
  8121bd:	89 c1                	mov    %eax,%ecx
  8121bf:	89 fa                	mov    %edi,%edx
  8121c1:	89 c8                	mov    %ecx,%eax
  8121c3:	83 c4 10             	add    $0x10,%esp
  8121c6:	5e                   	pop    %esi
  8121c7:	5f                   	pop    %edi
  8121c8:	5d                   	pop    %ebp
  8121c9:	c3                   	ret    
  8121ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  8121d0:	39 f8                	cmp    %edi,%eax
  8121d2:	77 1c                	ja     8121f0 <__udivdi3+0x70>
  8121d4:	0f bd d0             	bsr    %eax,%edx
  8121d7:	83 f2 1f             	xor    $0x1f,%edx
  8121da:	89 55 f4             	mov    %edx,-0xc(%ebp)
  8121dd:	75 39                	jne    812218 <__udivdi3+0x98>
  8121df:	3b 75 f0             	cmp    -0x10(%ebp),%esi
  8121e2:	0f 86 a0 00 00 00    	jbe    812288 <__udivdi3+0x108>
  8121e8:	39 f8                	cmp    %edi,%eax
  8121ea:	0f 82 98 00 00 00    	jb     812288 <__udivdi3+0x108>
  8121f0:	31 ff                	xor    %edi,%edi
  8121f2:	31 c9                	xor    %ecx,%ecx
  8121f4:	89 c8                	mov    %ecx,%eax
  8121f6:	89 fa                	mov    %edi,%edx
  8121f8:	83 c4 10             	add    $0x10,%esp
  8121fb:	5e                   	pop    %esi
  8121fc:	5f                   	pop    %edi
  8121fd:	5d                   	pop    %ebp
  8121fe:	c3                   	ret    
  8121ff:	90                   	nop
  812200:	89 d1                	mov    %edx,%ecx
  812202:	89 fa                	mov    %edi,%edx
  812204:	89 c8                	mov    %ecx,%eax
  812206:	31 ff                	xor    %edi,%edi
  812208:	f7 f6                	div    %esi
  81220a:	89 c1                	mov    %eax,%ecx
  81220c:	89 fa                	mov    %edi,%edx
  81220e:	89 c8                	mov    %ecx,%eax
  812210:	83 c4 10             	add    $0x10,%esp
  812213:	5e                   	pop    %esi
  812214:	5f                   	pop    %edi
  812215:	5d                   	pop    %ebp
  812216:	c3                   	ret    
  812217:	90                   	nop
  812218:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  81221c:	89 f2                	mov    %esi,%edx
  81221e:	d3 e0                	shl    %cl,%eax
  812220:	89 45 ec             	mov    %eax,-0x14(%ebp)
  812223:	b8 20 00 00 00       	mov    $0x20,%eax
  812228:	2b 45 f4             	sub    -0xc(%ebp),%eax
  81222b:	89 c1                	mov    %eax,%ecx
  81222d:	d3 ea                	shr    %cl,%edx
  81222f:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  812233:	0b 55 ec             	or     -0x14(%ebp),%edx
  812236:	d3 e6                	shl    %cl,%esi
  812238:	89 c1                	mov    %eax,%ecx
  81223a:	89 75 e8             	mov    %esi,-0x18(%ebp)
  81223d:	89 fe                	mov    %edi,%esi
  81223f:	d3 ee                	shr    %cl,%esi
  812241:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  812245:	89 55 ec             	mov    %edx,-0x14(%ebp)
  812248:	8b 55 f0             	mov    -0x10(%ebp),%edx
  81224b:	d3 e7                	shl    %cl,%edi
  81224d:	89 c1                	mov    %eax,%ecx
  81224f:	d3 ea                	shr    %cl,%edx
  812251:	09 d7                	or     %edx,%edi
  812253:	89 f2                	mov    %esi,%edx
  812255:	89 f8                	mov    %edi,%eax
  812257:	f7 75 ec             	divl   -0x14(%ebp)
  81225a:	89 d6                	mov    %edx,%esi
  81225c:	89 c7                	mov    %eax,%edi
  81225e:	f7 65 e8             	mull   -0x18(%ebp)
  812261:	39 d6                	cmp    %edx,%esi
  812263:	89 55 ec             	mov    %edx,-0x14(%ebp)
  812266:	72 30                	jb     812298 <__udivdi3+0x118>
  812268:	8b 55 f0             	mov    -0x10(%ebp),%edx
  81226b:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  81226f:	d3 e2                	shl    %cl,%edx
  812271:	39 c2                	cmp    %eax,%edx
  812273:	73 05                	jae    81227a <__udivdi3+0xfa>
  812275:	3b 75 ec             	cmp    -0x14(%ebp),%esi
  812278:	74 1e                	je     812298 <__udivdi3+0x118>
  81227a:	89 f9                	mov    %edi,%ecx
  81227c:	31 ff                	xor    %edi,%edi
  81227e:	e9 71 ff ff ff       	jmp    8121f4 <__udivdi3+0x74>
  812283:	90                   	nop
  812284:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  812288:	31 ff                	xor    %edi,%edi
  81228a:	b9 01 00 00 00       	mov    $0x1,%ecx
  81228f:	e9 60 ff ff ff       	jmp    8121f4 <__udivdi3+0x74>
  812294:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  812298:	8d 4f ff             	lea    -0x1(%edi),%ecx
  81229b:	31 ff                	xor    %edi,%edi
  81229d:	89 c8                	mov    %ecx,%eax
  81229f:	89 fa                	mov    %edi,%edx
  8122a1:	83 c4 10             	add    $0x10,%esp
  8122a4:	5e                   	pop    %esi
  8122a5:	5f                   	pop    %edi
  8122a6:	5d                   	pop    %ebp
  8122a7:	c3                   	ret    
	...

008122b0 <__umoddi3>:
  8122b0:	55                   	push   %ebp
  8122b1:	89 e5                	mov    %esp,%ebp
  8122b3:	57                   	push   %edi
  8122b4:	56                   	push   %esi
  8122b5:	83 ec 20             	sub    $0x20,%esp
  8122b8:	8b 55 14             	mov    0x14(%ebp),%edx
  8122bb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8122be:	8b 7d 10             	mov    0x10(%ebp),%edi
  8122c1:	8b 75 0c             	mov    0xc(%ebp),%esi
  8122c4:	85 d2                	test   %edx,%edx
  8122c6:	89 c8                	mov    %ecx,%eax
  8122c8:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  8122cb:	75 13                	jne    8122e0 <__umoddi3+0x30>
  8122cd:	39 f7                	cmp    %esi,%edi
  8122cf:	76 3f                	jbe    812310 <__umoddi3+0x60>
  8122d1:	89 f2                	mov    %esi,%edx
  8122d3:	f7 f7                	div    %edi
  8122d5:	89 d0                	mov    %edx,%eax
  8122d7:	31 d2                	xor    %edx,%edx
  8122d9:	83 c4 20             	add    $0x20,%esp
  8122dc:	5e                   	pop    %esi
  8122dd:	5f                   	pop    %edi
  8122de:	5d                   	pop    %ebp
  8122df:	c3                   	ret    
  8122e0:	39 f2                	cmp    %esi,%edx
  8122e2:	77 4c                	ja     812330 <__umoddi3+0x80>
  8122e4:	0f bd ca             	bsr    %edx,%ecx
  8122e7:	83 f1 1f             	xor    $0x1f,%ecx
  8122ea:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  8122ed:	75 51                	jne    812340 <__umoddi3+0x90>
  8122ef:	3b 7d f4             	cmp    -0xc(%ebp),%edi
  8122f2:	0f 87 e0 00 00 00    	ja     8123d8 <__umoddi3+0x128>
  8122f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8122fb:	29 f8                	sub    %edi,%eax
  8122fd:	19 d6                	sbb    %edx,%esi
  8122ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  812302:	8b 45 f4             	mov    -0xc(%ebp),%eax
  812305:	89 f2                	mov    %esi,%edx
  812307:	83 c4 20             	add    $0x20,%esp
  81230a:	5e                   	pop    %esi
  81230b:	5f                   	pop    %edi
  81230c:	5d                   	pop    %ebp
  81230d:	c3                   	ret    
  81230e:	66 90                	xchg   %ax,%ax
  812310:	85 ff                	test   %edi,%edi
  812312:	75 0b                	jne    81231f <__umoddi3+0x6f>
  812314:	b8 01 00 00 00       	mov    $0x1,%eax
  812319:	31 d2                	xor    %edx,%edx
  81231b:	f7 f7                	div    %edi
  81231d:	89 c7                	mov    %eax,%edi
  81231f:	89 f0                	mov    %esi,%eax
  812321:	31 d2                	xor    %edx,%edx
  812323:	f7 f7                	div    %edi
  812325:	8b 45 f4             	mov    -0xc(%ebp),%eax
  812328:	f7 f7                	div    %edi
  81232a:	eb a9                	jmp    8122d5 <__umoddi3+0x25>
  81232c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  812330:	89 c8                	mov    %ecx,%eax
  812332:	89 f2                	mov    %esi,%edx
  812334:	83 c4 20             	add    $0x20,%esp
  812337:	5e                   	pop    %esi
  812338:	5f                   	pop    %edi
  812339:	5d                   	pop    %ebp
  81233a:	c3                   	ret    
  81233b:	90                   	nop
  81233c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  812340:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  812344:	d3 e2                	shl    %cl,%edx
  812346:	89 55 f4             	mov    %edx,-0xc(%ebp)
  812349:	ba 20 00 00 00       	mov    $0x20,%edx
  81234e:	2b 55 f0             	sub    -0x10(%ebp),%edx
  812351:	89 55 ec             	mov    %edx,-0x14(%ebp)
  812354:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  812358:	89 fa                	mov    %edi,%edx
  81235a:	d3 ea                	shr    %cl,%edx
  81235c:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  812360:	0b 55 f4             	or     -0xc(%ebp),%edx
  812363:	d3 e7                	shl    %cl,%edi
  812365:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  812369:	89 55 f4             	mov    %edx,-0xc(%ebp)
  81236c:	89 f2                	mov    %esi,%edx
  81236e:	89 7d e8             	mov    %edi,-0x18(%ebp)
  812371:	89 c7                	mov    %eax,%edi
  812373:	d3 ea                	shr    %cl,%edx
  812375:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  812379:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  81237c:	89 c2                	mov    %eax,%edx
  81237e:	d3 e6                	shl    %cl,%esi
  812380:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  812384:	d3 ea                	shr    %cl,%edx
  812386:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  81238a:	09 d6                	or     %edx,%esi
  81238c:	89 f0                	mov    %esi,%eax
  81238e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  812391:	d3 e7                	shl    %cl,%edi
  812393:	89 f2                	mov    %esi,%edx
  812395:	f7 75 f4             	divl   -0xc(%ebp)
  812398:	89 d6                	mov    %edx,%esi
  81239a:	f7 65 e8             	mull   -0x18(%ebp)
  81239d:	39 d6                	cmp    %edx,%esi
  81239f:	72 2b                	jb     8123cc <__umoddi3+0x11c>
  8123a1:	39 c7                	cmp    %eax,%edi
  8123a3:	72 23                	jb     8123c8 <__umoddi3+0x118>
  8123a5:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  8123a9:	29 c7                	sub    %eax,%edi
  8123ab:	19 d6                	sbb    %edx,%esi
  8123ad:	89 f0                	mov    %esi,%eax
  8123af:	89 f2                	mov    %esi,%edx
  8123b1:	d3 ef                	shr    %cl,%edi
  8123b3:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  8123b7:	d3 e0                	shl    %cl,%eax
  8123b9:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  8123bd:	09 f8                	or     %edi,%eax
  8123bf:	d3 ea                	shr    %cl,%edx
  8123c1:	83 c4 20             	add    $0x20,%esp
  8123c4:	5e                   	pop    %esi
  8123c5:	5f                   	pop    %edi
  8123c6:	5d                   	pop    %ebp
  8123c7:	c3                   	ret    
  8123c8:	39 d6                	cmp    %edx,%esi
  8123ca:	75 d9                	jne    8123a5 <__umoddi3+0xf5>
  8123cc:	2b 45 e8             	sub    -0x18(%ebp),%eax
  8123cf:	1b 55 f4             	sbb    -0xc(%ebp),%edx
  8123d2:	eb d1                	jmp    8123a5 <__umoddi3+0xf5>
  8123d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8123d8:	39 f2                	cmp    %esi,%edx
  8123da:	0f 82 18 ff ff ff    	jb     8122f8 <__umoddi3+0x48>
  8123e0:	e9 1d ff ff ff       	jmp    812302 <__umoddi3+0x52>
